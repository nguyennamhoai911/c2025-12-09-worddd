Directory structure:
‚îî‚îÄ‚îÄ c2025-12-09-full-app-english/
    ‚îú‚îÄ‚îÄ AI_CONTEXT.md
    ‚îú‚îÄ‚îÄ docker-compose.yml
    ‚îú‚îÄ‚îÄ setup-guide.md
    ‚îî‚îÄ‚îÄ apps/
        ‚îú‚îÄ‚îÄ backend/
        ‚îÇ   ‚îú‚îÄ‚îÄ README.md
        ‚îÇ   ‚îú‚îÄ‚îÄ eslint.config.mjs
        ‚îÇ   ‚îú‚îÄ‚îÄ nest-cli.json
        ‚îÇ   ‚îú‚îÄ‚îÄ package.json
        ‚îÇ   ‚îú‚îÄ‚îÄ tree.txt
        ‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.build.json
        ‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
        ‚îÇ   ‚îú‚îÄ‚îÄ .prettierrc
        ‚îÇ   ‚îú‚îÄ‚îÄ certificates/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ localhost-key.pem
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ localhost.pem
        ‚îÇ   ‚îú‚îÄ‚îÄ prisma/
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema.prisma
        ‚îÇ   ‚îú‚îÄ‚îÄ src/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.controller.spec.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.controller.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.service.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.interceptor.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ interceptors/
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ performance.interceptor.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ modules/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.module.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-auth.dto.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ update-auth.dto.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.entity.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guards/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ google-auth.guard.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt-auth.guard.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ local-auth.guard.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ strategies/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ google.strategy.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ jwt.strategy.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ local.strategy.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.controller.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.module.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.service.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-user.dto.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ update-user.dto.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ entities/
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ user.entity.ts
        ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vocabulary/
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ vocabulary.controller.ts
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ vocabulary.module.ts
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ vocabulary.service.ts
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dto/
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ create-vocabulary.dto.ts
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ update-vocabulary.dto.ts
        ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ entities/
        ‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ vocabulary.entity.ts
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prisma/
        ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ prisma.module.ts
        ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ prisma.service.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ test/
        ‚îÇ       ‚îú‚îÄ‚îÄ app.e2e-spec.ts
        ‚îÇ       ‚îî‚îÄ‚îÄ jest-e2e.json
        ‚îú‚îÄ‚îÄ extension/
        ‚îÇ   ‚îú‚îÄ‚îÄ background.js
        ‚îÇ   ‚îú‚îÄ‚îÄ config.js
        ‚îÇ   ‚îú‚îÄ‚îÄ content.js
        ‚îÇ   ‚îú‚îÄ‚îÄ manifest.json
        ‚îÇ   ‚îú‚îÄ‚îÄ popup.css
        ‚îÇ   ‚îú‚îÄ‚îÄ popup.html
        ‚îÇ   ‚îú‚îÄ‚îÄ popup.js
        ‚îÇ   ‚îî‚îÄ‚îÄ content-scripts/
        ‚îÇ       ‚îú‚îÄ‚îÄ lookup-main.js
        ‚îÇ       ‚îú‚îÄ‚îÄ lookup-services.js
        ‚îÇ       ‚îú‚îÄ‚îÄ lookup-ui.js
        ‚îÇ       ‚îú‚îÄ‚îÄ main.js
        ‚îÇ       ‚îú‚îÄ‚îÄ messager.js
        ‚îÇ       ‚îú‚îÄ‚îÄ metrics.js
        ‚îÇ       ‚îú‚îÄ‚îÄ native-core.js
        ‚îÇ       ‚îú‚îÄ‚îÄ native-ui.js
        ‚îÇ       ‚îú‚îÄ‚îÄ shortcuts.js
        ‚îÇ       ‚îî‚îÄ‚îÄ ui.js
        ‚îî‚îÄ‚îÄ frontend/
            ‚îú‚îÄ‚îÄ README.md
            ‚îú‚îÄ‚îÄ eslint.config.mjs
            ‚îú‚îÄ‚îÄ next.config.ts
            ‚îú‚îÄ‚îÄ package.json
            ‚îú‚îÄ‚îÄ postcss.config.js
            ‚îú‚îÄ‚îÄ postcss.config.mjs
            ‚îú‚îÄ‚îÄ tailwind.config.ts
            ‚îú‚îÄ‚îÄ tsconfig.json
            ‚îú‚îÄ‚îÄ app/
            ‚îÇ   ‚îú‚îÄ‚îÄ globals.css
            ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
            ‚îÇ   ‚îú‚îÄ‚îÄ page.module.css
            ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
            ‚îÇ   ‚îú‚îÄ‚îÄ admin/
            ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users/
            ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
            ‚îÇ   ‚îú‚îÄ‚îÄ app/
            ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth/
            ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ callback/
            ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ page.tsx
            ‚îÇ   ‚îú‚îÄ‚îÄ login/
            ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
            ‚îÇ   ‚îú‚îÄ‚îÄ register/
            ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
            ‚îÇ   ‚îî‚îÄ‚îÄ vocabulary/
            ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
            ‚îú‚îÄ‚îÄ certificates/
            ‚îÇ   ‚îú‚îÄ‚îÄ localhost-key.pem
            ‚îÇ   ‚îî‚îÄ‚îÄ localhost.pem
            ‚îú‚îÄ‚îÄ components/
            ‚îÇ   ‚îú‚îÄ‚îÄ Icons.tsx
            ‚îÇ   ‚îî‚îÄ‚îÄ vocabulary/
            ‚îÇ       ‚îú‚îÄ‚îÄ AssessmentModal.tsx
            ‚îÇ       ‚îú‚îÄ‚îÄ QuickSearchModal.tsx
            ‚îÇ       ‚îú‚îÄ‚îÄ VocabFormModal.tsx
            ‚îÇ       ‚îî‚îÄ‚îÄ VocabTable.tsx
            ‚îú‚îÄ‚îÄ contexts/
            ‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.tsx
            ‚îú‚îÄ‚îÄ hooks/
            ‚îÇ   ‚îî‚îÄ‚îÄ vocabulary/
            ‚îÇ       ‚îú‚îÄ‚îÄ usePronunciationAssessment.ts
            ‚îÇ       ‚îú‚îÄ‚îÄ usePronunciationAssessmentWithExtension.ts
            ‚îÇ       ‚îú‚îÄ‚îÄ useQuickSearch.ts
            ‚îÇ       ‚îú‚îÄ‚îÄ useVocabData.ts
            ‚îÇ       ‚îú‚îÄ‚îÄ useVocabModals.ts
            ‚îÇ       ‚îî‚îÄ‚îÄ .gitkeep
            ‚îî‚îÄ‚îÄ lib/
                ‚îú‚îÄ‚îÄ api-metrics.ts
                ‚îî‚îÄ‚îÄ api.ts

================================================
FILE: AI_CONTEXT.md
================================================
[Empty file]


================================================
FILE: docker-compose.yml
================================================
# c2025-12-09-full-app-english\docker-compose.yml

# --- PH·∫¶N 1: GLOBAL SETTINGS (C√ÄI ƒê·∫∂T CHUNG) ---

# Version: X√°c ƒë·ªãnh 'grammar' (ng·ªØ ph√°p) m√† file n√†y s·ª≠ d·ª•ng.
# Version 3.8 l√† b·∫£n stable (·ªïn ƒë·ªãnh) v√† ph·ªï bi·∫øn nh·∫•t hi·ªán nay.
version: "3.8"

# --- PH·∫¶N 2: SERVICES (C√ÅC ·ª®NG D·ª§NG C·∫¶N CH·∫†Y) ---
# Services l√† tr√°i tim c·ªßa file. N∆°i b·∫°n list ra c√°c 'app' mu·ªën ch·∫°y.
services:
  # === SERVICE 1: DATABASE (POSTGRESQL) ===
  postgres:
    # 1. Image (Source Code):
    # - 'postgres': T√™n ph·∫ßn m·ªÅm tr√™n Docker Hub.
    # - ':15-alpine': Tag phi√™n b·∫£n.
    #   + '15': Version ch√≠nh.
    #   + 'alpine': L√† h·ªá ƒëi·ªÅu h√†nh Linux si√™u nh·ªè (ch·ªâ ~5MB), gi√∫p container nh·∫π v√† b·∫£o m·∫≠t h∆°n.
    image: postgres:15-alpine

    # 2. Container Name (ƒê·ªãnh danh):
    # - N·∫øu kh√¥ng ƒë·∫∑t, Docker s·∫Ω t·ª± random t√™n (vd: project_postgres_1).
    # - ƒê·∫∑t t√™n c·ªë ƒë·ªãnh 'vocab_db' gi√∫p b·∫°n d·ªÖ g√µ l·ªánh (CLI) sau n√†y.
    container_name: vocab_db

    # 3. Environment Variables (Bi·∫øn m√¥i tr∆∞·ªùng):
    # - ƒê√¢y l√† c√°ch ta 'inject' (ti√™m) c·∫•u h√¨nh v√†o trong container l√∫c n√≥ kh·ªüi ƒë·ªông (runtime).
    # - C√°c bi·∫øn b·∫Øt ƒë·∫ßu b·∫±ng 'POSTGRES_...' l√† quy ƒë·ªãnh ri√™ng c·ªßa image Postgres.
    environment:
      POSTGRES_USER: myuser # T·∫°o user m·∫∑c ƒë·ªãnh c√≥ quy·ªÅn cao nh·∫•t (superuser)
      POSTGRES_PASSWORD: mypassword # Set m·∫≠t kh·∫©u cho user ƒë√≥
      POSTGRES_DB: vocab_db # T·ª± ƒë·ªông t·∫°o s·∫µn 1 database r·ªóng t√™n l√† 'vocab_db'

    # 4. Ports Mapping (√Ånh x·∫° c·ªïng - Quan tr·ªçng!):
    # - C√∫ ph√°p: "HOST_PORT : CONTAINER_PORT" (Ngo√†i : Trong).
    # - "5432" (Tr√°i): C·ªïng tr√™n m√°y t√≠nh c·ªßa b·∫°n (Localhost).
    # - "5432" (Ph·∫£i): C·ªïng m·∫∑c ƒë·ªãnh m√† Postgres l·∫Øng nghe b√™n trong container.
    # -> √ù nghƒ©a: B·∫•t c·ª© ai g√µ v√†o 'localhost:5432' tr√™n m√°y b·∫°n s·∫Ω ƒë∆∞·ª£c 'tunnel' (ƒëi ƒë∆∞·ªùng h·∫ßm) th·∫≥ng v√†o database.
    ports:
      - "5433:5432"  # üëà S·ª≠a 5432 th√†nh 5433 (C·ªïng ngo√†i m√°y th·∫≠t : C·ªïng trong docker)

    # 5. Volumes (L∆∞u tr·ªØ d·ªØ li·ªáu):
    # - C√∫ ph√°p: "VOLUME_NAME : CONTAINER_PATH"
    # - 'postgres_data': T√™n c√°i 'k√©t s·∫Øt' (volume) do Docker qu·∫£n l√Ω.
    # - '/var/lib/postgresql/data': ƒê∆∞·ªùng d·∫´n b·∫Øt bu·ªôc n∆°i Postgres l∆∞u file d·ªØ li·ªáu b√™n trong.
    # -> √ù nghƒ©a: Sync (ƒë·ªìng b·ªô) d·ªØ li·ªáu t·ª´ trong ra ngo√†i. Container ch·∫øt, data v·∫´n c√≤n ·ªü 'postgres_data'.
    volumes:
      - postgres_data:/var/lib/postgresql/data

    # 6. Restart Policy (C∆° ch·∫ø t·ª± ph·ª•c h·ªìi):
    # - 'always': N·∫øu container b·ªã crash (l·ªói) ho·∫∑c m√°y t√≠nh kh·ªüi ƒë·ªông l·∫°i,
    #   Docker s·∫Ω t·ª± ƒë·ªông b·∫≠t n√≥ d·∫≠y. Gi·ªØ cho service lu√¥n 'Alive'.
    restart: always

  # === SERVICE 2: REDIS (CACHE / QUEUE) ===
  redis:
    # D√πng image redis b·∫£n nh·∫π nh·∫•t (alpine)
    image: redis:alpine

    # ƒê·∫∑t t√™n ƒë·ªÉ d·ªÖ qu·∫£n l√Ω
    container_name: vocab_redis

    # Mapping c·ªïng Redis.
    # C·ªïng 6379 l√† c·ªïng chu·∫©n c·ªßa Redis.
    ports:
      - "6379:6379"

    # T·ª± ƒë·ªông kh·ªüi ƒë·ªông l·∫°i n·∫øu c√≥ s·ª± c·ªë
    restart: always

# --- PH·∫¶N 3: VOLUMES DECLARATION (KHAI B√ÅO KHO CH·ª®A) ---
# B·∫°n ƒë√£ d√πng 'postgres_data' ·ªü tr√™n, n√™n b·∫°n ph·∫£i ƒëƒÉng k√Ω n√≥ ·ªü ƒë√¢y.
volumes:
  postgres_data:
    # M·∫∑c ƒë·ªãnh Docker s·∫Ω t·∫°o volume n√†y ·ªü s√¢u trong h·ªá th·ªëng file c·ªßa Docker
    # (th∆∞·ªùng l√† /var/lib/docker/volumes/...)



================================================
FILE: setup-guide.md
================================================
[Empty file]


================================================
FILE: apps/backend/README.md
================================================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil My≈õliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).



================================================
FILE: apps/backend/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);



================================================
FILE: apps/backend/nest-cli.json
================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================
FILE: apps/backend/package.json
================================================
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "prebuild": "npx prisma generate",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.2",
    "@nestjs/core": "^11.0.1",
    "@nestjs/jwt": "^11.0.2",
    "@nestjs/mapped-types": "*",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.1",
    "@prisma/client": "^5.10.2",
    "@types/passport-local": "^1.0.38",
    "bcrypt": "^6.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.3",
    "csv-parser": "^3.2.0",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@types/bcrypt": "^6.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^30.0.0",
    "@types/multer": "^2.0.0",
    "@types/node": "^22.19.2",
    "@types/passport-google-oauth20": "^2.0.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^30.0.0",
    "prettier": "^3.4.2",
    "prisma": "^5.10.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: apps/backend/tree.txt
================================================
backend
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ eslint.config.mjs
‚îú‚îÄ‚îÄ nest-cli.json
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ prisma
‚îÇ   ‚îî‚îÄ‚îÄ schema.prisma
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ app.controller.spec.ts
‚îÇ   ‚îú‚îÄ‚îÄ app.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts
‚îÇ   ‚îú‚îÄ‚îÄ app.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ main.ts
‚îú‚îÄ‚îÄ test
‚îÇ   ‚îú‚îÄ‚îÄ app.e2e-spec.ts
‚îÇ   ‚îî‚îÄ‚îÄ jest-e2e.json
‚îú‚îÄ‚îÄ tree.txt
‚îú‚îÄ‚îÄ tsconfig.build.json
‚îî‚îÄ‚îÄ tsconfig.json



================================================
FILE: apps/backend/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: apps/backend/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "nodenext",
    "moduleResolution": "nodenext",
    "resolvePackageJsonExports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}



================================================
FILE: apps/backend/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}



================================================
FILE: apps/backend/certificates/localhost-key.pem
================================================
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDNADwYED/YiApX
mHjclA2Z/ruibwSxMzPO0zzlF3llfz7gf6PkMMaOb4iADHBRfxvAdgMhb4uZU8JC
c4s4e6Y8ma/C7FRLAT/uohP4H3jL5EELpEThzFECoN6j5WYvjxTMxFEsU2Y0OwwM
XhURMpjx85pLt9BDNx4isun0kBydGKnGzK4qoStmQB4Lh9dOjJBXIyQxZ0bYKDcC
9QiRpeppaQX64VtAygQbRbZDnrPEElOXHeYSYWsENctEUsd83pXeb37LS65iOI53
OHQrIuz8qFDIEzErcQvKkWkx9aDmMr99C+CAwZi/fMq5FJGPrf5M6hEMPiTi31r0
dHqG9gfFAgMBAAECggEAPKyWHLUqgGb7UKPDGd4EDJEVbeUX6W5zJgLlYhTJjF3V
+VIt6sr46Y1fRC7qS2SojRUgphPCqJXeyBY0nXoTYJpIKBQUesKa7oEwEd8WvJoJ
Gm37KS10yKdeXfn2fZsGl/h+4fSpKkpTrZFnANkN5YapI0H7NPmqRLDZh9Xjcicj
eTi1SsOFqKzPHK/80ujVD4NzvBj27TT4IWWnFpZmVWDPqX7BEX+vNJ5XykWWZyGI
/y5BUR5tgQmWOk9EStjEAX8lfpLPi6L2SPxXJ6bDytiwS/tMb/9x2Hhx9jlSKui3
MMKpjeVKiSvP+fQ/+euNBXHUbtZ888kM+LtOCiDMHQKBgQDShDnjAdwk2zgo8l1C
BuWYfZFGjki8aySlGlYBqrEVotxKXXEhm7+CBRgQbciipfW9VL520NPNjYPQIWWY
M/o/9YPVYDOqrDALPRAvokyjjZ0L9RqgfoyxuMI0/KolCyQ7UQrfSXzQdKL9bqVq
P3XmY/Rf7xwMhYEoJG545Za1swKBgQD5SvBBJHTUVeqfCpTR0fHM/d7Yj9qz/zwr
3ukPlU6/5j/NOuxzIai3KicYosgbllhzdcnehdRSQXrjr2KqJISIqmMGHGrAK+JK
320y1hKEK2y7y2My4xWORLkePO7GxviUfc56nb1GD/vFew1lw373jHvgbsbLdPPd
tx2HMASApwKBgBHu/7tt+iINptAeLYGlcsO11r1q+5lJi1qhTrhfoSxVrmyLX0rc
qMjbxDwKDjCE8NVLNdqLWa/GIXeGkNARhX0TXkK8Kkqc1o7uicV1DxBTzRAqtjT7
8uJk+e5no9r6AwEmm0WATii39vaeCWtuso2I8FWH2hza9rDDwcF81YTvAoGBAPVw
fpLkXdIgtNrZBCSAW1zEJn95Qo4tIQTgdv3Mtrfg7bgV526DGSUc71kmC3Z905/5
vELF6IEDzwYUS0PQqFwVxWDi4YdKrYWh7FU8xwYx6uAKIySax0JHDytiOoSiqWMp
afz3CL7ORcfsmwgyLfNz8RLKfhcakm8cNoo/EG/JAoGBAK1nBVp+sC+2n/ge1Fo3
wKIdldV5kIGJHaFqPNuTndgEgzMbuAr0vqclzQGaDuS1iqovHgXuXNHr8yWQIFHg
2yb2d93pYDjPrh5o4dJsrrpLJzufUv1P93B5BNsILsCcO/F43zyvF8kMMocrrUDx
M4EZhN1756tA2eNGmccjdYT9
-----END PRIVATE KEY-----



================================================
FILE: apps/backend/certificates/localhost.pem
================================================
-----BEGIN CERTIFICATE-----
MIIElDCCAvygAwIBAgIQLnE8pEEiFfjiYZShYz9NUjANBgkqhkiG9w0BAQsFADCB
qTEeMBwGA1UEChMVbWtjZXJ0IGRldmVsb3BtZW50IENBMT8wPQYDVQQLDDZERVNL
VE9QLUxKVlM3UktcOTk5OUBERVNLVE9QLUxKVlM3UksgKEhvYWkgTmFtIE5ndXll
bikxRjBEBgNVBAMMPW1rY2VydCBERVNLVE9QLUxKVlM3UktcOTk5OUBERVNLVE9Q
LUxKVlM3UksgKEhvYWkgTmFtIE5ndXllbikwHhcNMjUxMjEyMTQ1NzE0WhcNMjgw
MzEyMTQ1NzE0WjBqMScwJQYDVQQKEx5ta2NlcnQgZGV2ZWxvcG1lbnQgY2VydGlm
aWNhdGUxPzA9BgNVBAsMNkRFU0tUT1AtTEpWUzdSS1w5OTk5QERFU0tUT1AtTEpW
UzdSSyAoSG9haSBOYW0gTmd1eWVuKTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBAM0APBgQP9iICleYeNyUDZn+u6JvBLEzM87TPOUXeWV/PuB/o+Qwxo5v
iIAMcFF/G8B2AyFvi5lTwkJzizh7pjyZr8LsVEsBP+6iE/gfeMvkQQukROHMUQKg
3qPlZi+PFMzEUSxTZjQ7DAxeFREymPHzmku30EM3HiKy6fSQHJ0YqcbMriqhK2ZA
HguH106MkFcjJDFnRtgoNwL1CJGl6mlpBfrhW0DKBBtFtkOes8QSU5cd5hJhawQ1
y0RSx3zeld5vfstLrmI4jnc4dCsi7PyoUMgTMStxC8qRaTH1oOYyv30L4IDBmL98
yrkUkY+t/kzqEQw+JOLfWvR0eob2B8UCAwEAAaN2MHQwDgYDVR0PAQH/BAQDAgWg
MBMGA1UdJQQMMAoGCCsGAQUFBwMBMB8GA1UdIwQYMBaAFA2aGeHX2DmBZI6zbeRs
WntSBbbFMCwGA1UdEQQlMCOCCWxvY2FsaG9zdIcEfwAAAYcQAAAAAAAAAAAAAAAA
AAAAATANBgkqhkiG9w0BAQsFAAOCAYEAAzPIuSx9l6ITKMyoj91SBskwaa/gVzLJ
JiiqBHDzvLpt8RTA8eTS7U45iCOLGI3r65ZY17uK0MeF4mprrDi69kV3+rjgGnXP
BxFXGBuz/T2YfrsNA3rebLrCQUaBdee9ZLoryK9Mo/J1EdgDRXhipvAY8xv66/wY
/UuUiotnvBFeTks82+q5Iy30hdAGwvLW6SmWAbfT9tamTb0vlQQGKJZblo+G+A+g
VJSOb3Zq8DMbG8QU8AMN37wmQJw+U/iBj3KIIh39jOWmJ+oHcJW8OJ6eYwE33cjG
2PTxsBHkbS8lmw/Cr4n1hGdR0knbQbAFkSMG6dYkyqsL6jgY3XjcBq/osgKofxzN
cTT2FQmK4uEKBWmu3PBG2MEJP/jWQPRGTJxEjGot1IMmrCZ1FtmQsNdRDDfbjPxl
wmKqMeV5AC301uBEDRyOXqw2M+u4wX5Yvh7MqJ46y2FgHS+XnsP+yeba7eh3SzYs
tHyO6uYQqD6J3x9LDzxMopjW5UWbqgRx
-----END CERTIFICATE-----



================================================
FILE: apps/backend/prisma/schema.prisma
================================================
// c2025-12-09-full-app-english\apps\backend\prisma\schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// 1. B·∫£ng User (Ng∆∞·ªùi d√πng)
model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String? // üëà Th√™m d·∫•u ? ƒë·ªÉ cho ph√©p Null (User Google kh√¥ng c√≥ pass)
  name     String?
  avatar   String? // üëà Th√™m tr∆∞·ªùng n√†y ƒë·ªÉ l∆∞u ·∫£nh ƒë·∫°i di·ªán t·ª´ Google
  provider String  @default("local") // "local" ho·∫∑c "google"
  googleId String? @unique // ID ri√™ng c·ªßa Google tr·∫£ v·ªÅ

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  vocabItems VocabItem[]

  @@map("users")
}

// 2. B·∫£ng VocabItem (T·ª´ v·ª±ng)
// apps/backend/prisma/schema.prisma

model VocabItem {
  id                  String  @id @default(uuid())
  // üëá TH√äM D√íNG N√ÄY: L∆∞u l·ªãch s·ª≠ ƒëi·ªÉm s·ªë (PostgreSQL h·ªó tr·ª£ m·∫£ng Int[])
  pronunciationScores Int[]   @default([])
  // --- C√ÅC C·ªòT KH·ªöP V·ªöI EXCEL ---
  topic               String? // Topic
  word                String // Word (B·∫Øt bu·ªôc)
  partOfSpeech        String? @map("part_of_speech") // Part of speech
  pronunciation       String? // Pronunciation
  meaning             String? // Meaning
  example             String? // Example
  relatedWords        String? @map("related_words") // Related words
  occurrence          Int?    @default(1)
  isStarred           Boolean @default(false) // üëà New field: M·∫∑c ƒë·ªãnh l√† false, ƒë√°nh d·∫•u th√¨ true

  // --- C√ÅC C·ªòT H·ªÜ TH·ªêNG (B·∫Øt bu·ªôc ph·∫£i gi·ªØ) ---
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id])

  // Map c·ªôt "Time" trong Excel v√†o createdAt
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // X√≥a c√°c tr∆∞·ªùng c≈© kh√¥ng d√πng n·ªØa (imageUrl, audioUrl, tags, masteryLevel...)
  // Ho·∫∑c c·ª© ƒë·ªÉ ƒë√≥ n·∫øu sau n√†y mu·ªën d√πng l·∫°i, nh∆∞ng ·ªü ƒë√¢y m√¨nh x√≥a cho g·ªçn theo √Ω b·∫°n.

  @@index([userId])
  @@map("vocab_items")
}



================================================
FILE: apps/backend/src/app.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});



================================================
FILE: apps/backend/src/app.controller.ts
================================================
// apps/backend/src/app.controller.ts
import { Controller, Get, Res } from '@nestjs/common';
import { AppService } from './app.service';
import type { Response } from 'express'; // üëà Th√™m ch·ªØ "type" v√†o ƒë√¢y

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  async getHealthCheck(@Res() res: Response) {
    // 1. L·∫•y d·ªØ li·ªáu raw t·ª´ Service
    const data = await this.appService.getHealthCheck();

    // 2. T·∫°o giao di·ªán Hacker (HTML + CSS)
    const html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SYSTEM STATUS :: CLASSIFIED</title>
        <style>
          :root {
            --bg-color: #0a0a0a;
            --text-color: #00ff41; /* Hacker Green */
            --dim-color: #008f11;
            --alert-color: #ff3333;
            --font-stack: 'Courier New', 'Consolas', monospace;
          }
          body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            text-shadow: 0 0 2px rgba(0, 255, 65, 0.5);
          }
          .terminal {
            width: 100%;
            max-width: 900px;
            border: 2px solid var(--dim-color);
            padding: 30px;
            box-shadow: 0 0 20px rgba(0, 143, 17, 0.2);
            position: relative;
            overflow: hidden;
          }
          .terminal::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
          }
          h1, h2 { text-transform: uppercase; margin: 0; letter-spacing: 2px; }
          h1 { border-bottom: 2px solid var(--dim-color); padding-bottom: 10px; margin-bottom: 20px; font-size: 24px; }
          .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 20px; }
          .card { border: 1px dashed var(--dim-color); padding: 15px; }
          .card-title { color: var(--dim-color); font-size: 12px; margin-bottom: 10px; display: block; }
          .row { display: flex; justify-content: space-between; margin-bottom: 8px; border-bottom: 1px dotted #333; padding-bottom: 4px; }
          .label { font-weight: bold; }
          .value { color: #fff; }
          .status-ok { color: var(--text-color); font-weight: bold; }
          .status-err { color: var(--alert-color); font-weight: bold; blink: 1s; }
          
          /* ASCII ART */
          .ascii { white-space: pre; font-size: 10px; color: var(--dim-color); margin-bottom: 20px; line-height: 10px; text-align: center;}
          
          /* Footer & Blink */
          .footer { margin-top: 30px; font-size: 12px; color: #555; text-align: right; }
          .blink { animation: blinker 1s linear infinite; }
          @keyframes blinker { 50% { opacity: 0; } }
          
          /* Scanline animation */
          @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
          }
        </style>
      </head>
      <body>
        <div class="terminal">
          <div class="ascii">
      ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
      ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
       ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
        ‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
          SYSTEM INITIALIZED... ACCESS GRANTED
          </div>

          <h1>üöÄ SYSTEM STATUS REPORT</h1>

          <div class="grid">
            <div class="card">
              <span class="card-title">[ SYSTEM_INTEGRITY ]</span>
              <div class="row"><span class="label">STATUS:</span> <span class="value status-ok">${data.status}</span></div>
              <div class="row"><span class="label">PLATFORM:</span> <span class="value">${data.system.platform}</span></div>
              <div class="row"><span class="label">PORT:</span> <span class="value">${data.system.port}</span></div>
              <div class="row"><span class="label">PROTOCOL:</span> <span class="value">${data.system.protocol}</span></div>
              <div class="row"><span class="label">ENV:</span> <span class="value">${data.system.environment}</span></div>
            </div>

            <div class="card">
              <span class="card-title">[ NETWORK_UPLINK ]</span>
              <div class="row"><span class="label">DATABASE:</span> <span class="value">${data.connectivity.database.includes('Connected') ? '<span class="status-ok">ONLINE ‚úÖ</span>' : '<span class="status-err">OFFLINE ‚ùå</span>'}</span></div>
              <div class="row"><span class="label">USER COUNT:</span> <span class="value">${data.connectivity.total_users}</span></div>
              <div class="row"><span class="label">CORS POLICY:</span> <span class="value">ACTIVE (Universal)</span></div>
            </div>
          </div>

          <div class="card">
            <span class="card-title">[ SECURITY_PROTOCOLS ]</span>
            <div class="row"><span class="label">DB CONNECTION STRING:</span> <span class="value">${data.configuration_checks.database_url}</span></div>
            <div class="row"><span class="label">GOOGLE OAUTH:</span> <span class="value">${data.configuration_checks.google_oauth}</span></div>
            <div class="row"><span class="label">JWT SECRET:</span> <span class="value">${data.configuration_checks.jwt_secret}</span></div>
          </div>

          <div style="margin-top: 20px; border: 1px solid var(--text-color); padding: 10px;">
            <span class="blink">‚ñà</span> ${data.message}
          </div>

          <div class="footer">
            TIMESTAMP: ${data.timestamp} | SERVER_ID: ${Math.random().toString(36).substring(7).toUpperCase()}
          </div>
        </div>
      </body>
      </html>
    `;

    // 3. Tr·∫£ v·ªÅ HTML thay v√¨ JSON
    res.send(html);
  }
}



================================================
FILE: apps/backend/src/app.module.ts
================================================
// apps/backend/src/app.module.ts
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { AuthModule } from './modules/auth/auth.module';
import { UsersModule } from './modules/users/users.module';
import { VocabularyModule } from './modules/vocabulary/vocabulary.module';
import { PerformanceInterceptor } from './common/interceptors/performance.interceptor';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true, // üëà Quan tr·ªçng!
    }),
    PrismaModule,
    AuthModule,
    UsersModule,
    VocabularyModule,
  ],
  controllers: [AppController],
  providers: [
    AppService,
    // üëá ƒêƒÉng k√Ω Performance Interceptor globally
    {
      provide: APP_INTERCEPTOR,
      useClass: PerformanceInterceptor,
    },
  ],
})
export class AppModule {}



================================================
FILE: apps/backend/src/app.service.ts
================================================
// apps/backend/src/app.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from './prisma/prisma.service';

@Injectable()
export class AppService {
  constructor(private prisma: PrismaService) {}

  async getHealthCheck() {
    // 1. Ki·ªÉm tra k·∫øt n·ªëi Database (Supabase)
    let dbStatus = 'Disconnected ‚ùå';
    let userCount = 0;
    try {
      // Th·ª≠ query nh·∫π ƒë·∫øm s·ªë user ƒë·ªÉ xem DB s·ªëng kh√¥ng
      userCount = await this.prisma.user.count();
      dbStatus = 'Connected (Supabase PostgreSQL) ‚úÖ';
    } catch (error) {
      dbStatus = `Error: ${error.message} ‚ùå`;
    }

    // 2. Ki·ªÉm tra m√¥i tr∆∞·ªùng
    const isProduction = process.env.NODE_ENV === 'production';
    const protocol = isProduction ? 'https (Render Managed)' : 'https (Local Certificate)';

    // 3. Ki·ªÉm tra c√°c Config quan tr·ªçng
    const checks = {
      database_url: process.env.DATABASE_URL ? 'Configured ‚úÖ' : 'Missing ‚ùå',
      google_oauth: (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) ? 'Ready ‚úÖ' : 'Missing Keys ‚ö†Ô∏è',
      jwt_secret: process.env.JWT_SECRET ? 'Set ‚úÖ' : 'Missing (Auth will fail) ‚ùå',
    };

    // 4. Tr·∫£ v·ªÅ b√°o c√°o chi ti·∫øt
    return {
      status: 'üöÄ Backend is OPERATIONAL',
      timestamp: new Date().toISOString(),
      system: {
        environment: process.env.NODE_ENV || 'development',
        port: process.env.PORT || 5001,
        protocol: protocol,
        platform: isProduction ? 'Render Cloud' : 'Localhost Windows',
      },
      connectivity: {
        database: dbStatus,
        total_users: userCount,
        cors_policy: 'Allow All (Frontend & Extension Compatible) ‚úÖ',
      },
      configuration_checks: checks,
      message: 'S·∫µn s√†ng ph·ª•c v·ª• Frontend (Next.js) v√† Extension!',
    };
  }
}



================================================
FILE: apps/backend/src/logging.interceptor.ts
================================================
[Binary file]


================================================
FILE: apps/backend/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';
import { HttpsOptions } from '@nestjs/common/interfaces/external/https-options.interface'; // üëà 
// 1. Import interface n√†y
import { LoggingInterceptor } from './logging.interceptor';
import * as fs from 'fs';
import * as path from 'path';

async function bootstrap() {
  // üëá 2. Khai b√°o ki·ªÉu r√µ r√†ng: l√† HttpsOptions HO·∫∂C undefined (kh√¥ng d√πng null)
  let httpsOptions: HttpsOptions | undefined = undefined;
  
  const isProduction = process.env.NODE_ENV === 'production';

  if (!isProduction) {
    try {
      const keyPath = path.join(__dirname, '..', 'certificates', 'localhost-key.pem');
      const certPath = path.join(__dirname, '..', 'certificates', 'localhost.pem');

      if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
        // üëá 3. L√∫c n√†y g√°n object v√†o bi·∫øn l√† h·ª£p l·ªá
        httpsOptions = {
          key: fs.readFileSync(keyPath),
          cert: fs.readFileSync(certPath),
        };
        console.log('üîí Using Local HTTPS Certificates');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not load SSL certs, falling back to HTTP');
    }
  }

  // üëá 4. Truy·ªÅn th·∫≥ng bi·∫øn v√†o (v√¨ n√≥ ƒë√£ l√† undefined n·∫øu l√† production)
  const app = await NestFactory.create(AppModule, {
    httpsOptions, 
  });
  app.useGlobalInterceptors(new LoggingInterceptor());
  app.enableCors({
    origin: true,
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  });

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
    }),
  );

  const port = process.env.PORT || 5001;
  await app.listen(port);
  
  console.log(`üöÄ Backend running on ${isProduction ? 'HTTP (Render managed SSL)' : 'HTTPS'} port ${port}`);
}
bootstrap();


================================================
FILE: apps/backend/src/common/interceptors/performance.interceptor.ts
================================================
// apps/backend/src/common/interceptors/performance.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class PerformanceInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const t2_start = performance.now(); // üïí B·∫Øt ƒë·∫ßu T2 (Server processing)

    return next.handle().pipe(
      tap((data) => {
        const t2_end = performance.now(); // üèÅ K·∫øt th√∫c T2
        const t2_duration = (t2_end - t2_start).toFixed(2); // ms

        const response = context.switchToHttp().getResponse();
        
        // üëá TH√äM HEADER: Server processing time
        response.setHeader('x-server-time', t2_duration);
        
        // Log chi ti·∫øt (n·∫øu c·∫ßn debug)
        const request = context.switchToHttp().getRequest();
        console.log(`‚è±Ô∏è [${request.method} ${request.url}] Server time: ${t2_duration}ms`);
      }),
    );
  }
}



================================================
FILE: apps/backend/src/modules/auth/auth.controller.ts
================================================
import {
  Controller,
  Post,
  Body,
  Get,
  UseGuards,
  Req,
  Res,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { GoogleAuthGuard } from './guards/google-auth.guard';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import type { Response } from 'express'; // üëà Th√™m "type"

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  async register(
    @Body() body: { email: string; password: string; name?: string },
  ) {
    return this.authService.register(body.email, body.password, body.name);
  }

  @Post('login')
  async login(
    @Body() body: { email: string; password: string },
    @Res({ passthrough: true }) res: Response, // üëà Inject Response v√†o ƒë√¢y
  ) {
    const result = await this.authService.login(body.email, body.password);

    // üëá TH√äM ƒêO·∫†N N√ÄY: G·∫Øn Cookie "token"
    res.cookie('token', result.token, {
      httpOnly: true,
      secure: true, // B·∫Øt bu·ªôc true v√¨ Render ch·∫°y HTTPS
      sameSite: 'none', // B·∫Øt bu·ªôc 'none' ƒë·ªÉ Extension (trang kh√°c) ƒë·ªçc ƒë∆∞·ª£c
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 ng√†y
    });

    return result;
  }

  @Get('google')
  @UseGuards(GoogleAuthGuard)
  async googleAuth() {
    // Redirects to Google
  }

  @Get('google/callback')
  @UseGuards(GoogleAuthGuard)
  async googleAuthRedirect(@Req() req, @Res() res: Response) {
    const result = await this.authService.googleLogin(req.user);

    // üëá TH√äM ƒêO·∫†N N√ÄY: G·∫Øn Cookie "token"
    res.cookie('token', result.token, {
      httpOnly: true,
      secure: true,
      sameSite: 'none',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });

    // Frontend URL tr√™n Vercel (ho·∫∑c Localhost n·∫øu ƒëang dev)
    const frontendUrl = `http://localhost:3000/auth/callback?token=${result.token}`;
    return res.redirect(frontendUrl);
  }

  @Get('me')
  @UseGuards(JwtAuthGuard)
  async getMe(@Req() req) {
    return this.authService.getUserById(req.user.id);
  }
}



================================================
FILE: apps/backend/src/modules/auth/auth.module.ts
================================================
// apps/backend/src/modules/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaModule } from '../../prisma/prisma.module';
import { LocalStrategy } from './strategies/local.strategy';
import { JwtStrategy } from './strategies/jwt.strategy';
import { GoogleStrategy } from './strategies/google.strategy';

@Module({
  imports: [
    PrismaModule,
    PassportModule,
    ConfigModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get('JWT_SECRET') || 'your-secret-key-change-in-production',
        signOptions: { expiresIn: '7d' },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, LocalStrategy, JwtStrategy, GoogleStrategy],
  exports: [AuthService],
})
export class AuthModule {}


================================================
FILE: apps/backend/src/modules/auth/auth.service.ts
================================================
// apps/backend/src/modules/auth/auth.service.ts

import { Injectable, UnauthorizedException, ConflictException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../../prisma/prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
  ) {}

  // ========== REGISTER WITH EMAIL/PASSWORD ==========
  async register(email: string, password: string, name?: string) {
    // Check if user exists
    const existingUser = await this.prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const user = await this.prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name: name || email.split('@')[0], // Default name from email
        provider: 'local',
      },
    });

    // Generate token
    const token = this.generateToken(user.id, user.email);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        avatar: user.avatar,
      },
      token,
    };
  }

  // ========== LOGIN WITH EMAIL/PASSWORD ==========
  async login(email: string, password: string) {
    // Find user
    const user = await this.prisma.user.findUnique({
      where: { email },
    });

    if (!user || !user.password) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Check password
    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Generate token
    const token = this.generateToken(user.id, user.email);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        avatar: user.avatar,
      },
      token,
    };
  }

  // ========== GOOGLE OAUTH LOGIN ==========
  async googleLogin(googleUser: {
    email: string;
    firstName: string;
    lastName: string;
    picture: string;
    googleId: string;
  }) {
    // Check if user exists
    let user = await this.prisma.user.findUnique({
      where: { email: googleUser.email },
    });

    if (!user) {
      // Create new user from Google
      user = await this.prisma.user.create({
        data: {
          email: googleUser.email,
          name: `${googleUser.firstName} ${googleUser.lastName}`,
          avatar: googleUser.picture,
          provider: 'google',
          googleId: googleUser.googleId,
          password: null, // Google users don't have password
        },
      });
    } else if (user.provider === 'local') {
      // Link Google to existing local account
      user = await this.prisma.user.update({
        where: { id: user.id },
        data: {
          googleId: googleUser.googleId,
          avatar: googleUser.picture, // Update avatar
        },
      });
    }

    // Generate token
    const token = this.generateToken(user.id, user.email);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        avatar: user.avatar,
      },
      token,
    };
  }

  // ========== VALIDATE USER (For Passport) ==========
  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.prisma.user.findUnique({
      where: { email },
    });

    if (user && user.password) {
      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (isPasswordValid) {
        const { password, ...result } = user;
        return result;
      }
    }
    return null;
  }

  // ========== GET USER BY ID ==========
  async getUserById(id: string) {
    const user = await this.prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        name: true,
        avatar: true,
        provider: true,
        createdAt: true,
      },
    });

    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    return user;
  }

  // ========== HELPER: GENERATE JWT TOKEN ==========
  private generateToken(userId: string, email: string) {
    return this.jwtService.sign({
      sub: userId,
      email,
    });
  }
}


================================================
FILE: apps/backend/src/modules/auth/dto/create-auth.dto.ts
================================================
export class CreateAuthDto {}



================================================
FILE: apps/backend/src/modules/auth/dto/update-auth.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateAuthDto } from './create-auth.dto';

export class UpdateAuthDto extends PartialType(CreateAuthDto) {}



================================================
FILE: apps/backend/src/modules/auth/entities/auth.entity.ts
================================================
export class Auth {}



================================================
FILE: apps/backend/src/modules/auth/guards/google-auth.guard.ts
================================================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class GoogleAuthGuard extends AuthGuard('google') {}


================================================
FILE: apps/backend/src/modules/auth/guards/jwt-auth.guard.ts
================================================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}



================================================
FILE: apps/backend/src/modules/auth/guards/local-auth.guard.ts
================================================
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}



================================================
FILE: apps/backend/src/modules/auth/strategies/google.strategy.ts
================================================
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy, VerifyCallback, Profile, StrategyOptions } from 'passport-google-oauth20';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(private configService: ConfigService) {
    super({
      clientID: configService.get<string>('GOOGLE_CLIENT_ID') || '',
      clientSecret: configService.get<string>('GOOGLE_CLIENT_SECRET') || '',
      callbackURL: configService.get<string>('GOOGLE_CALLBACK_URL') || 'http://localhost:5001/auth/google/callback',
      scope: ['email', 'profile'],
    } as StrategyOptions); // üëà Th√™m "as StrategyOptions"
  }

  async validate(
    accessToken: string,
    refreshToken: string,
    profile: Profile,
    done: VerifyCallback,
  ): Promise<any> {
    const { name, emails, photos, id } = profile;
    
    const user = {
      email: emails?.[0]?.value || '',
      firstName: name?.givenName || '',
      lastName: name?.familyName || '',
      picture: photos?.[0]?.value || '',
      googleId: id,
    };

    done(null, user);
  }
}


================================================
FILE: apps/backend/src/modules/auth/strategies/jwt.strategy.ts
================================================
// apps/backend/src/modules/auth/strategies/jwt.strategy.ts
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    super({
      // üëá LOGIC M·ªöI: Th·ª≠ l·∫•y t·ª´ Custom Extractor tr∆∞·ªõc, sau ƒë√≥ m·ªõi th·ª≠ Header
      jwtFromRequest: ExtractJwt.fromExtractors([
        JwtStrategy.extractJWT,
        ExtractJwt.fromAuthHeaderAsBearerToken(),
      ]),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET') || 'your-secret-key-change-in-production',
    });
  }

  // H√†m th·ªß c√¥ng ƒë·ªÉ moi Token t·ª´ Cookie
  private static extractJWT(req: Request): string | null {
    // 1. N·∫øu c√≥ c√†i cookie-parser
    if (req.cookies && 'token' in req.cookies && req.cookies.token.length > 0) {
      return req.cookies.token;
    }
    // 2. N·∫øu ch∆∞a c√†i cookie-parser (Parsing th·ªß c√¥ng t·ª´ header string)
    if (req.headers.cookie) {
       const match = req.headers.cookie.match(/token=([^;]+)/);
       if (match) return match[1];
    }
    return null;
  }

  async validate(payload: any) {
    return { 
      id: payload.sub, 
      email: payload.email 
    };
  }
}


================================================
FILE: apps/backend/src/modules/auth/strategies/local.strategy.ts
================================================
// apps/backend/src/modules/auth/strategies/local.strategy.ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      usernameField: 'email', // M·∫∑c ƒë·ªãnh l√† 'username', m√¨nh ƒë·ªïi th√†nh 'email' cho ƒë√∫ng project
    });
  }

  // H√†m n√†y s·∫Ω t·ª± ƒë·ªông ch·∫°y khi user login
  async validate(email: string, pass: string): Promise<any> {
    const user = await this.authService.validateUser(email, pass);
    if (!user) {
      throw new UnauthorizedException('Sai email ho·∫∑c m·∫≠t kh·∫©u');
    }
    return user;
  }
}



================================================
FILE: apps/backend/src/modules/users/users.controller.ts
================================================
import { Controller, Post, Body } from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  // T·∫°m th·ªùi b·ªè c√°c route findAll, findOne, update, remove 
  // v√¨ Service ch∆∞a implement logic ƒë√≥.
}


================================================
FILE: apps/backend/src/modules/users/users.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}



================================================
FILE: apps/backend/src/modules/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { PrismaService } from '../../prisma/prisma.service'; // Import global service
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  async create(createUserDto: CreateUserDto) {
    const { email, password, name } = createUserDto;
    // Hash password logic
    const hashedPassword = password ? await bcrypt.hash(password, 10) : null;

    return this.prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
      },
    });
  }

  // Find user for Auth logic
  async findOneByEmail(email: string) {
    return this.prisma.user.findUnique({
      where: { email },
    });
  }
}



================================================
FILE: apps/backend/src/modules/users/dto/create-user.dto.ts
================================================
export class CreateUserDto {
  email: string;
  password?: string; // Optional v√¨ sau n√†y c√≥ th·ªÉ login b·∫±ng Google
  name?: string;
}



================================================
FILE: apps/backend/src/modules/users/dto/update-user.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}



================================================
FILE: apps/backend/src/modules/users/entities/user.entity.ts
================================================
export class User {}



================================================
FILE: apps/backend/src/modules/vocabulary/vocabulary.controller.ts
================================================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Request,
  UseInterceptors,
  UploadedFile,
  Query,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { VocabularyService } from './vocabulary.service';
import { CreateVocabularyDto } from './dto/create-vocabulary.dto';
import { UpdateVocabularyDto } from './dto/update-vocabulary.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('vocabulary')
@UseGuards(JwtAuthGuard)
export class VocabularyController {
  constructor(private readonly vocabularyService: VocabularyService) {}
  @Patch(':id/score')
  async addScore(
    @Request() req,
    @Param('id') id: string,
    @Body('score') score: number,
  ) {
    return this.vocabularyService.addScore(id, req.user.id, score);
  }
  @Get('check')
  async findByWord(@Request() req, @Query('word') word: string) {
    return this.vocabularyService.findByWord(req.user.id, word);
  }
  @Post()
  create(@Request() req, @Body() createDto: CreateVocabularyDto) {
    // üëá UPDATE: S·ª≠ d·ª•ng upsertVocab ƒë·ªÉ handle logic create ho·∫∑c update n·∫øu ƒë√£ t·ªìn t·∫°i
    return this.vocabularyService.upsertVocab(req.user.id, createDto);
  }

  @Post('import/csv')
  @UseInterceptors(FileInterceptor('file'))
  async importCsv(@Request() req, @UploadedFile() file: Express.Multer.File) {
    return this.vocabularyService.importFromCsv(req.user.id, file);
  }

  @Get()
  findAll(
    @Request() req,
    @Query('page') page: string,
    @Query('limit') limit: string,
    @Query('search') search: string, // Quick search (t√¨m chung)
    // Filter Params
    @Query('word') word: string,
    @Query('topic') topic: string,
    @Query('partOfSpeech') partOfSpeech: string,
    @Query('meaning') meaning: string,
    @Query('isStarred') isStarred: string, // Filter t·ª´ y√™u th√≠ch
    // Sort Params
    @Query('sortBy') sortBy: string,
    @Query('sortOrder') sortOrder: string,
  ) {
    const pageNumber = page ? parseInt(page) : 1;
    const limitNumber = limit ? parseInt(limit) : 20;

    // Gom c√°c filter criteria v√†o m·ªôt object
    const filters = {
      word,
      topic,
      partOfSpeech,
      meaning,
      // Convert string 'true' th√†nh boolean true, ng∆∞·ª£c l·∫°i l√† false/undefined
      isStarred: isStarred === 'true',
    };

    // Config sort option
    const sort = {
      field: sortBy || 'createdAt',
      order: (sortOrder === 'asc' ? 'asc' : 'desc') as 'asc' | 'desc',
    };

    // Call service v·ªõi full arguments
    return this.vocabularyService.findAll(
      req.user.id,
      pageNumber,
      limitNumber,
      filters,
      sort,
      search,
    );
  }

  @Get(':id')
  findOne(@Request() req, @Param('id') id: string) {
    return this.vocabularyService.findOne(id, req.user.id);
  }

  @Patch(':id')
  update(
    @Request() req,
    @Param('id') id: string,
    @Body() updateDto: UpdateVocabularyDto,
  ) {
    return this.vocabularyService.update(id, req.user.id, updateDto);
  }

  @Delete(':id')
  remove(@Request() req, @Param('id') id: string) {
    return this.vocabularyService.remove(id, req.user.id);
  }
}



================================================
FILE: apps/backend/src/modules/vocabulary/vocabulary.module.ts
================================================
// apps/backend/src/modules/vocabulary/vocabulary.module.ts
import { Module } from '@nestjs/common';
import { VocabularyService } from './vocabulary.service';
import { VocabularyController } from './vocabulary.controller';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [VocabularyController],
  providers: [VocabularyService],
})
export class VocabularyModule {}



================================================
FILE: apps/backend/src/modules/vocabulary/vocabulary.service.ts
================================================
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Prisma } from '@prisma/client';
import { CreateVocabularyDto } from './dto/create-vocabulary.dto';
import { UpdateVocabularyDto } from './dto/update-vocabulary.dto';
import csv from 'csv-parser';
import { Readable } from 'stream';

interface VocabFilters {
  word?: string;
  topic?: string;
  partOfSpeech?: string;
  meaning?: string;
  isStarred?: boolean;
}

@Injectable()
export class VocabularyService {
  constructor(private prisma: PrismaService) {}
// üëá UPDATE: L∆∞u ƒëi·ªÉm, tƒÉng l∆∞·ª£t t∆∞∆°ng t√°c v√† c·∫≠p nh·∫≠t th·ªùi gian
  async addScore(id: string, userId: string, score: number) {
    const vocab = await this.findOne(id, userId);
    
    // Logic m·∫£ng ƒëi·ªÉm (Gi·ªØ 10 l·∫ßn g·∫ßn nh·∫•t)
    const currentScores = vocab.pronunciationScores || [];
    const newScores = [...currentScores, score];
    if (newScores.length > 10) newScores.shift();

    return this.prisma.vocabItem.update({
      where: { id },
      data: {
        pronunciationScores: newScores,
        occurrence: { increment: 1 }, // TƒÉng s·ªë l·∫ßn t∆∞∆°ng t√°c
        // updatedAt s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c Prisma c·∫≠p nh·∫≠t l√™n gi·ªù hi·ªán t·∫°i
      },
    });
  }
  // üëá [NEW] Helper t√¨m t·ª´ theo text (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
  async findByWord(userId: string, word: string) {
    const cleanWord = word.trim();
    return this.prisma.vocabItem.findFirst({
      where: {
        userId,
        word: { equals: cleanWord, mode: 'insensitive' },
      },
    });
  }
  // --- 1. SMART UPSERT (LOGIC TR√ÅNH TR√ôNG L·∫∂P) ---
  async upsertVocab(userId: string, createDto: CreateVocabularyDto) {
    const cleanWord = createDto.word.trim();
    console.log(
      `üîç Checking existence for word: "${cleanWord}" (User: ${userId})`,
    );

    // 1. T√¨m xem t·ª´ ƒë√£ c√≥ ch∆∞a (Kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
    const existing = await this.prisma.vocabItem.findFirst({
      where: {
        userId,
        word: {
          equals: cleanWord,
          mode: 'insensitive',
        },
      },
    });

    if (existing) {
      console.log(
        `‚úÖ Word exists (ID: ${existing.id}). Updating count only...`,
      );
      // 2a. N·∫øu c√≥ r·ªìi -> Ch·ªâ tƒÉng count & c·∫≠p nh·∫≠t time (B·ªé T·ª∞ ƒê·ªòNG STAR)
      return this.prisma.vocabItem.update({
        where: { id: existing.id },
        data: {
          // isStarred: true, // üëà ƒê√É X√ìA D√íNG N√ÄY (Kh√¥ng √©p star n·ªØa)
          occurrence: (existing.occurrence || 0) + 1,
          // N·∫øu mu·ªën update th√™m th√¥ng tin th√¨ uncomment d√≤ng d∆∞·ªõi:
          // ...createDto
        },
      });
    } else {
      console.log(`üÜï Word not found. Creating new entry...`);
      // 2b. N·∫øu ch∆∞a c√≥ -> T·∫°o m·ªõi
      return this.prisma.vocabItem.create({
        data: {
          ...createDto, // üëà Backend s·∫Ω d√πng gi√° tr·ªã isStarred t·ª´ Frontend g·ª≠i l√™n (false)
          word: cleanWord,
          userId,
          // isStarred: true, // üëà ƒê√É X√ìA D√íNG N√ÄY (ƒê·ªÉ kh√¥ng b·ªã override)
        },
      });
    }
  }

  // --- GI·ªÆ L·∫†I H√ÄM CREATE G·ªêC ---
  async create(userId: string, createDto: CreateVocabularyDto) {
    return this.prisma.vocabItem.create({
      data: { ...createDto, userId },
    });
  }

  // --- 2. FIND ALL ---
  async findAll(
    userId: string,
    page: number = 1,
    limit: number = 20,
    filters: VocabFilters = {},
    sort: { field: string; order: 'asc' | 'desc' } = {
      field: 'createdAt',
      order: 'desc',
    },
    search?: string,
  ) {
    const skip = (page - 1) * limit;
    const clean = (text?: string) => text?.trim();

    const whereCondition: Prisma.VocabItemWhereInput = {
      userId,

      word: filters.word
        ? { contains: clean(filters.word), mode: 'insensitive' }
        : undefined,
      topic: filters.topic
        ? { contains: clean(filters.topic), mode: 'insensitive' }
        : undefined,
      partOfSpeech: filters.partOfSpeech
        ? { contains: clean(filters.partOfSpeech), mode: 'insensitive' }
        : undefined,
      meaning: filters.meaning
        ? { contains: clean(filters.meaning), mode: 'insensitive' }
        : undefined,
      isStarred: filters.isStarred === true ? true : undefined,

      ...(search
        ? {
            OR: [
              { word: { contains: clean(search), mode: 'insensitive' } },
              { meaning: { contains: clean(search), mode: 'insensitive' } },
              { topic: { contains: clean(search), mode: 'insensitive' } },
            ],
          }
        : {}),
    };

    const orderByInput: Prisma.VocabItemOrderByWithRelationInput[] = [];
    if (sort.field) orderByInput.push({ [sort.field]: sort.order });
    orderByInput.push({ id: 'asc' });

    const [items, total] = await Promise.all([
      this.prisma.vocabItem.findMany({
        where: whereCondition,
        skip,
        take: limit,
        orderBy: orderByInput,
      }),
      this.prisma.vocabItem.count({ where: whereCondition }),
    ]);

    return {
      data: items,
      meta: { total, page, lastPage: Math.ceil(total / limit) },
    };
  }

  // --- 3. FIND ONE ---
  async findOne(id: string, userId: string) {
    const vocab = await this.prisma.vocabItem.findFirst({
      where: { id, userId },
    });
    if (!vocab) throw new NotFoundException('Vocabulary not found');
    return vocab;
  }

  // --- 4. UPDATE ---
  async update(id: string, userId: string, updateDto: UpdateVocabularyDto) {
    await this.findOne(id, userId);
    return this.prisma.vocabItem.update({ where: { id }, data: updateDto });
  }

  // --- 5. REMOVE ---
  async remove(id: string, userId: string) {
    await this.findOne(id, userId);
    return this.prisma.vocabItem.delete({ where: { id } });
  }

  // --- 6. IMPORT CSV ---
  async importFromCsv(userId: string, file: Express.Multer.File) {
    if (!file) throw new BadRequestException('File is required');
    const results: any[] = [];
    const stream = Readable.from(file.buffer.toString());

    return new Promise((resolve, reject) => {
      stream
        .pipe(csv())
        .on('data', (data) => results.push(data))
        .on('end', async () => {
          let successCount = 0;
          let errorCount = 0;
          for (const row of results) {
            try {
              await this.upsertVocab(userId, {
                word: row['Word']?.trim(),
                topic: row['Topic']?.trim(),
                partOfSpeech: row['Part of speech']?.trim(),
                pronunciation: row['Pronunciation']?.trim(),
                meaning: row['Meaning']?.trim(),
                example: row['Example']?.trim(),
                relatedWords: row['Related words']?.trim(),
                occurrence: row['Occurrence'] ? parseInt(row['Occurrence']) : 1,
                isStarred: false, // Import CSV c≈©ng m·∫∑c ƒë·ªãnh kh√¥ng Star
              });
              successCount++;
            } catch (error) {
              errorCount++;
            }
          }
          resolve({
            message: 'Import finished',
            total: results.length,
            success: successCount,
            failed: errorCount,
          });
        })
        .on('error', () => reject(new BadRequestException('Invalid CSV file')));
    });
  }
}



================================================
FILE: apps/backend/src/modules/vocabulary/dto/create-vocabulary.dto.ts
================================================
import {
  IsBoolean,
  IsString,
  IsOptional,
  IsInt,
  Min, // Minimum value
} from 'class-validator';

export class CreateVocabularyDto {
  // Field n√†y b·∫Øt bu·ªôc (Required), ph·∫£i l√† String
  @IsString()
  word: string;

  // M·∫•y c√°i d∆∞·ªõi n√†y l√† Optional (c√≥ c≈©ng ƒë∆∞·ª£c, kh√¥ng c√≥ c≈©ng kh√¥ng sao)
  @IsOptional()
  @IsString()
  topic?: string;

  @IsOptional()
  @IsString()
  partOfSpeech?: string; // Lo·∫°i t·ª´ (noun, verb...)

  @IsOptional()
  @IsString()
  pronunciation?: string;

  @IsOptional()
  @IsString()
  meaning?: string;

  @IsOptional()
  @IsString()
  example?: string;

  @IsOptional()
  @IsString()
  relatedWords?: string;

  @IsOptional()
  @IsInt() // Ph·∫£i l√† s·ªë nguy√™n (Integer)
  @Min(0) // Gi√° tr·ªã nh·ªè nh·∫•t l√† 0
  occurrence?: number;

  @IsOptional()
  @IsBoolean()
  isStarred?: boolean; // üëà Add this property
}



================================================
FILE: apps/backend/src/modules/vocabulary/dto/update-vocabulary.dto.ts
================================================
// apps\backend\src\modules\vocabulary\dto\update-vocabulary.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateVocabularyDto } from './create-vocabulary.dto';

export class UpdateVocabularyDto extends PartialType(CreateVocabularyDto) {}


================================================
FILE: apps/backend/src/modules/vocabulary/entities/vocabulary.entity.ts
================================================
export class Vocabulary {}



================================================
FILE: apps/backend/src/prisma/prisma.module.ts
================================================
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global() // Key concept: Make it global!
@Module({
  providers: [PrismaService],
  exports: [PrismaService], // Export to use in other modules
})
export class PrismaModule {}



================================================
FILE: apps/backend/src/prisma/prisma.service.ts
================================================
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor() {
    super({
      log: [{ emit: 'event', level: 'query' }], // B·∫Øt bu·ªôc d√≤ng n√†y ƒë·ªÉ log query
    });
  }

  async onModuleInit() {
    await this.$connect();
    console.log('‚úÖ DB Connected via Prisma');
    
    // @ts-ignore
    this.$on('query', (e: any) => {
      // üïí T3: Th·ªùi gian query th·ª±c thi
      const t3_db_ms = e.duration;
      
      // Ch·ªâ in ra n·∫øu query ch·∫≠m h∆°n 100ms (B·ªè qua c√°c query nhanh)
      if (t3_db_ms > 100) {
        console.log(`üî• SLOW DB [T3: ${t3_db_ms}ms] Query: ${e.query}`);
      }
    });
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}



================================================
FILE: apps/backend/test/app.e2e-spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});



================================================
FILE: apps/backend/test/jest-e2e.json
================================================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}



================================================
FILE: apps/extension/background.js
================================================
// apps/extension/background.js

chrome.runtime.onInstalled.addListener(() => {
  console.log("‚úÖ Extension Installed/Reloaded");
  createNextAlarm();
});

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === "vocab_review") {
    console.log(
      "‚è∞ Alarm Triggered: vocab_review at " + new Date().toLocaleTimeString()
    );

    // 1. G·ª≠i tin nh·∫Øn xu·ªëng Tab
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs.length === 0) {
        console.log("‚ö†Ô∏è No active tab found.");
        return;
      }

      console.log(`üì° Sending message to Tab ID: ${tabs[0].id}`);
      chrome.tabs
        .sendMessage(tabs[0].id, { action: "SHOW_FLASHCARD" })
        .catch((err) =>
          console.log(
            "‚ùå Could not send message (Content Script not ready?):",
            err
          )
        );
    });

    // 2. T·∫°o Alarm ti·∫øp theo (Recursive)
    createNextAlarm();
  }
});

function createNextAlarm() {
  // Setup alarm ch·∫°y sau 12 gi√¢y
  chrome.alarms.create("vocab_review", { when: Date.now() + 300000 });
  console.log("‚è≥ Next alarm scheduled in 12s...");
}



================================================
FILE: apps/extension/config.js
================================================
// apps/extension/config.js

// üëá C√îNG T·∫ÆC T·ªîNG: ƒê·ªïi true/false ·ªü ƒë√¢y
const IS_DEV_MODE = true;

const APP_CONFIG = {
  // Backend
  API_URL: IS_DEV_MODE
    ? "https://localhost:5001"
    : "https://vocab-backend-aveq.onrender.com",

  // Frontend
  FRONTEND_URL: IS_DEV_MODE
    ? "https://localhost:3001"
    : "https://c2025-12-09-full-app-english.vercel.app",
};

// Log ra ƒë·ªÉ bi·∫øt ƒëang ch·∫°y m√¥i tr∆∞·ªùng n√†o
console.log(
  `üöÄ Extension Mode: ${IS_DEV_MODE ? "DEV (Local)" : "PROD (Server)"}`
);



================================================
FILE: apps/extension/content.js
================================================
[Binary file]


================================================
FILE: apps/extension/manifest.json
================================================
{
  "manifest_version": 3,
  "name": "Vocabulary Coach & App Connector",
  "version": "2.0",
  "description": "Full App Integration: Iframe, TTS, Azure Speech & Flashcards",
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "permissions": ["storage", "microphone", "alarms"],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "32": "icons/icon32.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": [
        "config.js",
        "content-scripts/lookup-services.js",
        "content-scripts/lookup-ui.js",
        "content-scripts/native-ui.js",
        "content-scripts/native-core.js",
        "content-scripts/lookup-main.js"
      ],
      "css": ["popup.css"]
    }
  ],
  "host_permissions": [
    "https://translate.google.com/*",
    "https://translate.googleapis.com/*",
    "https://commons.wikimedia.org/*",
    "https://api.duckduckgo.com/*",
    "https://www.googleapis.com/*",
    "https://api.unsplash.com/*",
    "https://*.cognitiveservices.azure.com/*",
    "https://*.onrender.com/*",
    "http://localhost:3000/*",
    "https://localhost:3001/*",
    "http://localhost:5001/*"
  ],
  "web_accessible_resources": [
    {
      "resources": ["popup.css"],
      "matches": ["<all_urls>"]
    }
  ]
}



================================================
FILE: apps/extension/popup.css
================================================
:root {
  --primary-color: #58cc02; /* Xanh l√° ki·ªÉu Duolingo/Elsa */
  --primary-dark: #46a302;
  --accent-color: #1cb0f6; /* Xanh d∆∞∆°ng */
  --text-primary: #3c3c3c;
  --text-secondary: #777777;
  --bg-color: #ffffff;
  --card-bg: #f7f7f7;
  --danger-color: #ff4b4b;
  --warning-color: #ffc800;
  --shadow-soft: 0 10px 40px -10px rgba(0, 0, 0, 0.15);
  --border-radius: 16px;
}

/* Reset & Base */
* {
  box-sizing: border-box;
}

#tts-popup {
  position: absolute;
  background: var(--bg-color);
  color: var(--text-primary);
  padding: 0;
  border-radius: var(--border-radius);
  box-shadow: var(--shadow-soft);
  z-index: 999999;
  min-width: 320px;
  max-width: 400px;
  font-family: "Nunito", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    sans-serif; /* Font tr√≤n tr·ªãa hi·ªán ƒë·∫°i */
  border: 1px solid rgba(0, 0, 0, 0.08);
  overflow: hidden;
  animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes popIn {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(10px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

/* --- Header --- */
.tts-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  background: #fff;
  border-bottom: 1px solid #f0f0f0;
  cursor: move;
  user-select: none;
}

.sound-btn,
.close-btn {
  background: transparent;
  border: none;
  color: #bbbbbb;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  padding: 0;
}

.sound-btn:hover {
  background: #f0f8ff;
  color: var(--accent-color);
}

.close-btn:hover {
  background: #fff0f0;
  color: var(--danger-color);
}

/* --- Content Area --- */
.tts-content {
  padding: 0 20px 20px 20px;
  max-height: 500px;
  overflow-y: auto;
}

/* --- Images Grid --- */
.tts-images-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin: 15px 0;
  width: 100%;
}

.tts-image {
  width: 100%;
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 1;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  transition: transform 0.2s;
}

.tts-image:hover {
  transform: scale(1.05);
}

.tts-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* --- Phonetic & Meaning --- */
.tts-phonetic {
  display: flex;
  gap: 15px;
  margin-bottom: 15px;
  justify-content: center;
}

.phonetic-item {
  display: flex;
  align-items: center;
  font-size: 14px;
  color: var(--text-secondary);
  background: #f5f5f5;
  padding: 4px 10px;
  border-radius: 20px;
}

.phonetic-item .flag {
  margin-right: 6px;
  font-size: 16px;
}

.phonetic-text {
  font-family: "Lucida Console", monospace;
  font-weight: 600;
  color: var(--text-primary);
}

.tts-meaning {
  font-size: 16px;
  color: var(--text-primary);
  line-height: 1.6;
  text-align: center;
  font-weight: 500;
  margin-bottom: 10px;
}

/* --- Actions (Mic Button) --- */
.tts-actions {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px 0 20px 0;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0), #fff 20%);
}

.mic-btn {
  background: var(--accent-color); /* M√†u xanh ch·ªß ƒë·∫°o */
  border: none;
  box-shadow: 0 4px 0 #118ec7; /* Hi·ªáu ·ª©ng n√∫t b·∫•m 3D */
  color: white;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.1s;
  margin-bottom: 10px;
}

.mic-btn:hover {
  filter: brightness(1.1);
  transform: translateY(-2px);
  box-shadow: 0 6px 0 #118ec7;
}

.mic-btn:active {
  transform: translateY(4px);
  box-shadow: 0 0 0 #118ec7;
}

.mic-btn.recording {
  background: var(--danger-color);
  box-shadow: 0 4px 0 #d63e3e;
  animation: pulse-red 1.5s infinite;
}

@keyframes pulse-red {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 75, 75, 0.4);
  }
  70% {
    box-shadow: 0 0 0 15px rgba(255, 75, 75, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 75, 75, 0);
  }
}

/* --- Assessment Result (ELSA Style) --- */
#assessment-result {
  width: 100%;
}

.assessment-box {
  background: #ffffff;
  padding: 15px;
  text-align: center;
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* V√≤ng tr√≤n ƒëi·ªÉm s·ªë */
.total-score-circle {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  border: 5px solid #eee;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: 800;
  margin: 0 auto 5px auto;
  background: #fff;
  color: var(--text-primary);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
}

/* Text Word ch√≠nh */
.word-text {
  font-size: 32px;
  font-weight: 800;
  margin: 10px 0 5px 0;
  color: #2b3b4e; /* M√†u xanh ƒë·∫≠m sang tr·ªçng */
  letter-spacing: -0.5px;
}

/* Container Phonemes */
.analyzed-content {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-top: 5px;
}

.word-block {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.phoneme-row {
  display: flex;
  gap: 4px;
  padding: 4px;
  border-radius: 12px;
  background: transparent;
}

.phoneme-char {
  font-family: "Roboto Mono", monospace;
  font-size: 16px;
  font-weight: 600;
  padding: 6px 10px;
  border-radius: 8px;
  transition: all 0.2s;
  min-width: 32px;
  text-align: center;
}

/* M√†u s·∫Øc ƒëi·ªÉm s·ªë (Color Grading) */
/* Xanh (Excellent) */
.p-perfect {
  background-color: #dff6dd;
  color: #2e7d32;
  border: 1px solid #c8e6c9;
}

/* Xanh nh·∫°t (Good) */
.p-good {
  background-color: #f1f8e9;
  color: #558b2f;
  border: 1px solid #dcedc8;
}

/* V√†ng (Fair) */
.p-fair {
  background-color: #fff8e1;
  color: #fbc02d;
  border: 1px solid #ffecb3;
}

/* ƒê·ªè (Bad) */
.p-bad {
  background-color: #ffebee;
  color: #c62828;
  border: 1px solid #ffcdd2;
  position: relative;
}

/* Loading & Info */
.tts-loading,
.tts-info {
  font-size: 14px;
  color: #999;
  text-align: center;
  padding: 10px;
}
/* --- Flashcard Passive Learning --- */
#vocab-flashcard {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 280px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  z-index: 2147483647; /* Max z-index */
  font-family: "Nunito", sans-serif;
  border: 1px solid rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.flashcard-slide-in {
  animation: slideInRight 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

.flashcard-slide-out {
  animation: slideOutRight 0.5s forwards;
}

@keyframes slideInRight {
  from {
    transform: translateX(120%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(120%);
    opacity: 0;
  }
}

/* Style cho Context Box trong Popup ch√≠nh */
.context-box {
  margin-top: 10px;
  padding: 10px;
  background: #f8f9fa;
  border-left: 3px solid var(--accent-color);
  border-radius: 4px;
  font-size: 13px;
  color: var(--text-secondary);
  text-align: left;
  line-height: 1.4;
}
/* --- Dictionary Styles --- */
.dict-container {
  text-align: left;
  margin: 10px 0;
  padding: 0 10px;
}

.dict-row {
  margin-bottom: 8px;
  line-height: 1.5;
  display: flex;
  align-items: baseline;
}

.dict-pos {
  font-size: 11px;
  text-transform: uppercase;
  color: #888;
  background: #eee;
  padding: 2px 6px;
  border-radius: 4px;
  margin-right: 8px;
  font-weight: 700;
  min-width: 45px;
  text-align: center;
}

.dict-meanings {
  font-size: 15px;
  color: #333;
  font-weight: 500;
}
/* --- New: Primary Meaning Style --- */
.primary-meaning {
  font-size: 18px; /* To h∆°n text th∆∞·ªùng */
  color: var(--primary-dark); /* M√†u xanh ƒë·∫≠m cho d·ªÖ nh√¨n */
  font-weight: 700;
  text-align: center;
  margin: 5px 0 10px 0;
  padding-bottom: 8px;
  border-bottom: 1px dashed #eee; /* G·∫°ch ch√¢n nh·∫π ngƒÉn c√°ch v·ªõi dict */
  line-height: 1.4;
}
/* --- Assessment Action Buttons --- */
.assessment-actions {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
}

.action-btn-small {
  border: none;
  border-radius: 20px;
  padding: 6px 14px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.btn-user-audio {
  background: #ffffff;
  color: #d32f2f; /* M√†u ƒë·ªè ghi √¢m */
}
.btn-user-audio:hover {
  background: #ffebee;
}

.btn-ref-audio {
  background: #ffffff;
  color: #1976d2; /* M√†u xanh Azure */
}
.btn-ref-audio:hover {
  background: #e3f2fd;
}
/* --- FULL FORM MODAL STYLES (Ported from Frontend) --- */
.vocab-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  z-index: 2147483650; /* Cao h∆°n c·∫£ Search Wrapper */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  animation: fadeIn 0.2s ease-out;
}

.vocab-modal-content {
  background: #fff;
  width: 100%;
  max-width: 650px;
  max-height: 90vh;
  border-radius: 16px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
    0 10px 10px -5px rgba(0, 0, 0, 0.04);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: scaleIn 0.2s ease-out;
}

@keyframes scaleIn {
  from {
    transform: scale(0.95);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.vocab-modal-header {
  background: #4f46e5; /* Indigo-600 */
  padding: 24px;
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.vocab-modal-title {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  opacity: 0.8;
  margin-bottom: 8px;
}

.vocab-input-large {
  background: transparent;
  font-size: 36px;
  font-weight: 700;
  color: white;
  border: none;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  width: 100%;
  outline: none;
  padding-bottom: 4px;
  transition: border-color 0.2s;
}
.vocab-input-large:focus {
  border-color: white;
}
.vocab-input-large::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.vocab-modal-body {
  padding: 24px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.vocab-grid-2 {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

.vocab-label {
  display: block;
  font-size: 12px;
  font-weight: 700;
  color: #9ca3af; /* Gray-400 */
  text-transform: uppercase;
  margin-bottom: 4px;
}

.vocab-input-field,
.vocab-textarea-field,
.vocab-select-field {
  width: 100%;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 14px;
  outline: none;
  transition: box-shadow 0.2s, border-color 0.2s;
}

.vocab-input-field:focus,
.vocab-textarea-field:focus,
.vocab-select-field:focus {
  border-color: #6366f1;
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
}

.vocab-textarea-field {
  min-height: 80px;
  font-family: inherit;
  resize: vertical;
}

.vocab-modal-footer {
  background: #f9fafb; /* Gray-50 */
  padding: 16px;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.btn-cancel {
  background: transparent;
  color: #4b5563;
  padding: 8px 20px;
  border-radius: 8px;
  font-weight: 500;
  border: none;
  cursor: pointer;
}
.btn-cancel:hover {
  background: #e5e7eb;
}

.btn-save {
  background: #4f46e5;
  color: white;
  padding: 8px 24px;
  border-radius: 8px;
  font-weight: 700;
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  transition: transform 0.1s;
}
.btn-save:hover {
  background: #4338ca;
}
.btn-save:active {
  transform: scale(0.98);
}

/* Auto-fill Animation */
.autofill-loading {
  font-size: 12px;
  color: #bfdbfe;
  margin-left: 10px;
  animation: pulse 1.5s infinite;
}
/* =========================================
   NATIVE SEARCH BAR STYLES (QUICK SEARCH)
   ========================================= */

/* Root container ƒë·ªÉ c√¥ l·∫≠p style */
#vocab-root {
  all: initial; /* Reset style ƒë·ªÉ kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi trang web g·ªëc */
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

/* Wrapper: Trong su·ªët ho√†n to√†n & Click xuy√™n qua ƒë∆∞·ª£c */
#vocab-search-wrapper {
  position: fixed;
  inset: 0;
  background: transparent !important; /* Kh√¥ng m√†u n·ªÅn */
  backdrop-filter: none !important; /* Kh√¥ng l√†m m·ªù */
  z-index: 2147483648;
  display: none;
  pointer-events: none; /* QUAN TR·ªåNG: Cho ph√©p click v√†o trang web b√™n d∆∞·ªõi */
}

/* Modal: Hi·ªán r√µ & Nh·∫≠n s·ª± ki·ªán chu·ªôt */
#vocab-search-modal {
  pointer-events: auto;
  background: white;
  width: 600px;
  max-width: 90vw;
  border-radius: 12px;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 20px 50px -5px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.05);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 15%;
  left: 50%;
  transform: translateX(-50%);
  transition: opacity 0.2s ease-out;

  /* üëá QUAN TR·ªåNG: Cho ph√©p b√¥i ƒëen vƒÉn b·∫£n trong to√†n b·ªô Modal */
  user-select: text !important;
  -webkit-user-select: text !important;
}

/* Header: Tay n·∫Øm k√©o th·∫£ */
.vocab-header {
  padding: 24px 28px;
  border-bottom: 1px solid #f0f0f0;
  display: flex;
  align-items: center;

  /* üëá Ch·ªâ ch·∫∑n b√¥i ƒëen ·ªü v√πng Header (tr·ª´ √¥ input) ƒë·ªÉ k√©o th·∫£ m∆∞·ª£t */
  cursor: grab;
  user-select: none !important;
  -webkit-user-select: none !important;
  background: #fff;
}

.vocab-header:active {
  cursor: grabbing; /* B√†n tay n·∫Øm l·∫°i khi k√©o */
  background: #fafafa;
}

.vocab-input-affix {
  display: flex;
  align-items: center;
  width: 100%;
  gap: 10px;
  color: #999;
}

.vocab-search-input {
  flex: 1;
  border: none;
  outline: none;
  font-size: 20px;
  font-weight: 300;
  color: #333;
  background: transparent;

  /* üëá C·ª±c k·ª≥ quan tr·ªçng ƒë·ªÉ Paste/Copy ho·∫°t ƒë·ªông */
  cursor: text;
  user-select: text !important;
  -webkit-user-select: text !important;
}

.vocab-search-input::placeholder {
  color: #ccc;
}

/* --- BODY LIST STYLES --- */
.vocab-body {
  max-height: 450px;
  overflow-y: auto;
  background: #fff;
  padding: 8px 0;
}

/* Item Row */
.vocab-list-item {
  padding: 12px 24px; /* TƒÉng padding cho tho√°ng */
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  transition: background 0.1s ease;
  border-left: 4px solid transparent;
}

.vocab-list-item:hover {
  background: #f5f7fa;
  border-left-color: #1890ff;
}

/* Ri√™ng ph·∫ßn Create New th√¨ highlight nh·∫π */
.vocab-create-item {
  background: #f6ffed; /* Xanh l√° si√™u nh·∫°t */
}
.vocab-create-item:hover {
  background: #d9f7be;
  border-left-color: #52c41a;
}

/* Typography */
.vocab-word-text {
  font-size: 18px;
  font-weight: 700;
  color: #333;
}

.vocab-pronun {
  font-family: "Lucida Console", monospace;
  font-size: 13px;
  color: #888;
  margin-left: 8px;
}

.vocab-word-meta {
  font-size: 14px;
  color: #666;
  margin-top: 4px;
  line-height: 1.4;
}

/* Tags */
.vocab-tag {
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 4px;
  background: #eee;
  color: #666;
  font-weight: 700;
  text-transform: uppercase;
  margin-left: 8px;
  border: 1px solid #e0e0e0;
}
.tag-green {
  background: #f6ffed;
  color: #52c41a;
  border-color: #b7eb8f;
}
.tag-blue {
  background: #e6f7ff;
  color: #1890ff;
  border-color: #91d5ff;
}

/* --- ACTION BUTTONS (ROUND STYLE - GI·ªêNG SHIFT) --- */
.vocab-actions {
  display: flex;
  gap: 10px;
  opacity: 0; /* M·∫∑c ƒë·ªãnh ·∫©n */
  transform: translateX(10px);
  transition: all 0.2s ease;
}

/* Hover v√†o d√≤ng th√¨ hi·ªán n√∫t */
.vocab-list-item:hover .vocab-actions {
  opacity: 1;
  transform: translateX(0);
}

/* N√∫t b·∫•m tr√≤n xoe */
.action-btn-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid #eee;
  background: white;
  color: #999;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;

  /* Quan tr·ªçng ƒë·ªÉ click ƒë∆∞·ª£c */
  pointer-events: auto !important;
  user-select: none;
}

.action-btn-circle svg {
  width: 20px;
  height: 20px;
}

/* Hover effects */
.action-btn-circle:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.btn-listen:hover {
  color: #1890ff;
  border-color: #1890ff;
  background: #e6f7ff;
}
.btn-mic:hover {
  color: #52c41a;
  border-color: #52c41a;
  background: #f6ffed;
}
.btn-edit:hover {
  color: #faad14;
  border-color: #faad14;
  background: #fffbe6;
}
.btn-sound:hover {
  color: #1890ff;
  border-color: #1890ff;
  background: #e6f7ff;
}

/* Lu√¥n hi·ªán n√∫t ·ªü d√≤ng Create New ƒë·ªÉ user bi·∫øt m√† b·∫•m */
.vocab-create-item .vocab-actions {
  opacity: 1;
  transform: none;
}
/* --- ASSESSMENT MODAL STYLES (ELSA STYLE) --- */
.assess-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  z-index: 2147483660; /* Cao nh·∫•t */
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease-out;
}

.assess-modal-content {
  background: white;
  width: 100%;
  max-width: 450px;
  border-radius: 24px;
  padding: 30px;
  text-align: center;
  position: relative;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  animation: scaleIn 0.2s ease-out;
}

.assess-word {
  font-size: 32px;
  font-weight: 800;
  color: #1f2937;
  margin-bottom: 5px;
}

.assess-pronun {
  font-family: monospace;
  color: #6b7280;
  font-size: 18px;
  margin-bottom: 20px;
}

/* Score Circle Animation */
.score-circle-container {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 8px solid #f3f4f6;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto 25px auto;
  font-size: 40px;
  font-weight: 800;
  transition: all 0.5s ease;
}

/* Phonemes Styles */
.phoneme-list {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin-bottom: 25px;
  background: #f9fafb;
  padding: 15px;
  border-radius: 16px;
}

.phoneme-badge {
  font-family: monospace;
  font-size: 14px;
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 600;
}

.bg-green {
  background: #dcfce7;
  color: #166534;
}
.bg-yellow {
  background: #fef9c3;
  color: #854d0e;
}
.bg-red {
  background: #fee2e2;
  color: #991b1b;
}

/* Control Buttons */
.assess-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
}

.btn-control {
  border: none;
  cursor: pointer;
  transition: transform 0.1s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.btn-control:active {
  transform: scale(0.95);
}

.btn-speaker {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: #f3f4f6;
  color: #4f46e5;
}

.btn-record {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  background: #4f46e5;
  color: white;
  box-shadow: 0 10px 15px -3px rgba(79, 70, 229, 0.3);
}
.btn-record.recording {
  background: #ef4444;
  animation: pulse 1.5s infinite;
}

.btn-playback {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: #ecfdf5;
  color: #059669;
}
.btn-playback:disabled {
  background: #f3f4f6;
  color: #d1d5db;
  cursor: not-allowed;
}

.assess-status {
  margin-top: 15px;
  font-size: 14px;
  color: #6b7280;
  min-height: 20px;
}

/* Header Input (Word) - Chuy·ªÉn th√†nh Textarea style */
.vocab-input-large {
  background: transparent;
  font-size: 32px; /* Gi·∫£m nh·∫π font size ƒë·ªÉ ƒë·ª° b·ªã tr√†n */
  font-weight: 700;
  color: white;
  border: none;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  width: 100%;
  outline: none;
  padding-bottom: 4px;
  transition: border-color 0.2s;

  /* Fix cho textarea */
  resize: none; /* Kh√¥ng cho user k√©o th·ªß c√¥ng */
  overflow: hidden; /* ·∫®n thanh cu·ªôn x·∫•u */
  font-family: inherit;
  line-height: 1.3;
  min-height: 50px;
  display: block;
}

.vocab-input-large:focus {
  border-color: white;
}

.vocab-input-large::placeholder {
  color: rgba(255, 255, 255, 0.5);
}



================================================
FILE: apps/extension/popup.html
================================================
<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge TTS Reader - C√†i ƒë·∫∑t</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        width: 450px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .container {
        padding: 20px;
      }

      h2 {
        font-size: 20px;
        margin-bottom: 20px;
        font-weight: 600;
      }

      .guide-section {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-size: 13px;
        line-height: 1.6;
        backdrop-filter: blur(10px);
      }

      .guide-section h3 {
        font-size: 14px;
        margin-bottom: 10px;
        font-weight: 600;
      }

      .guide-section ol {
        padding-left: 20px;
      }

      .guide-section li {
        margin-bottom: 6px;
      }

      .guide-section a {
        color: #fff;
        text-decoration: underline;
      }

      .guide-section a:hover {
        opacity: 0.8;
      }

      .input-group {
        margin-bottom: 15px;
        position: relative;
      }

      .input-group label {
        display: block;
        margin-bottom: 8px;
        font-size: 14px;
        font-weight: 500;
      }

      .input-wrapper {
        position: relative;
        display: flex;
        align-items: center;
      }

      .input-group input {
        flex: 1;
        padding: 10px 40px 10px 12px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 6px;
        font-size: 14px;
        font-family: monospace;
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        transition: all 0.2s;
      }

      .input-group input:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.8);
        background: white;
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
      }

      .toggle-visibility {
        position: absolute;
        right: 8px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 18px;
        padding: 6px;
        z-index: 10;
        opacity: 0.6;
        transition: opacity 0.2s;
      }

      .toggle-visibility:hover {
        opacity: 1;
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .save-btn {
        background: white;
        color: #667eea;
      }

      .save-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .test-btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      .test-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }

      .status-message {
        margin-top: 15px;
        padding: 12px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        text-align: center;
        display: none;
      }

      .status-message.show {
        display: block;
      }

      .status-message.success {
        background: rgba(76, 175, 80, 0.9);
        color: white;
      }

      .status-message.error {
        background: rgba(244, 67, 54, 0.9);
        color: white;
      }

      .status-message.warning {
        background: rgba(255, 152, 0, 0.9);
        color: white;
      }

      .status-message.loading {
        background: rgba(33, 150, 243, 0.9);
        color: white;
      }

      .info-note {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 6px;
        font-size: 12px;
        margin-top: 15px;
        border-left: 3px solid rgba(255, 255, 255, 0.5);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h2>‚öôÔ∏è C√†i ƒë·∫∑t Google Search API</h2>

      <div class="guide-section">
        <h3>üìå H∆∞·ªõng d·∫´n l·∫•y API Key:</h3>
        <ol>
          <li>
            Truy c·∫≠p
            <a href="https://console.cloud.google.com/" target="_blank"
              >Google Cloud Console</a
            >
          </li>
          <li>T·∫°o d·ª± √°n m·ªõi ho·∫∑c ch·ªçn d·ª± √°n hi·ªán c√≥</li>
          <li>B·∫≠t Custom Search API</li>
          <li>T·∫°o API Key t·ª´ ph·∫ßn "Credentials"</li>
          <li>D√°n API Key v√†o √¥ d∆∞·ªõi</li>
        </ol>
      </div>

      <div class="guide-section">
        <h3>üìå H∆∞·ªõng d·∫´n l·∫•y Search Engine ID:</h3>
        <ol>
          <li>
            Truy c·∫≠p
            <a
              href="https://programmablesearchengine.google.com/"
              target="_blank"
              >Google Programmable Search Engine</a
            >
          </li>
          <li>T·∫°o search engine m·ªõi</li>
          <li>Sao ch√©p Search Engine ID (cx)</li>
          <li>D√°n v√†o √¥ d∆∞·ªõi</li>
        </ol>
      </div>

      <div class="input-group">
        <label>üîë Main Google API Key:</label>
        <div class="input-wrapper">
          <input
            type="password"
            id="api-key-0"
            class="api-key-input"
            placeholder="Key ch√≠nh (b·∫Øt bu·ªôc)"
          />
          <button type="button" class="toggle-visibility">üëÅÔ∏è</button>
        </div>
      </div>

      <div class="input-group">
        <label>üîç Main Search Engine ID (cx):</label>
        <div class="input-wrapper">
          <input
            type="text"
            id="cx-0"
            class="cx-input"
            placeholder="CX ch√≠nh (b·∫Øt bu·ªôc)"
          />
        </div>
      </div>

      <details
        style="
          margin-bottom: 15px;
          background: rgba(0, 0, 0, 0.1);
          border-radius: 6px;
          padding: 10px;
        "
      >
        <summary style="cursor: pointer; font-weight: 600; font-size: 13px">
          ‚ûï M·ªü r·ªông: 4 Backup Keys (D·ª± ph√≤ng)
        </summary>

        <div
          style="
            margin-top: 10px;
            padding-left: 10px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
          "
        >
          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #1:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-1"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 1"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-1"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 1"
            />
          </div>

          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #2:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-2"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 2"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-2"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 2"
            />
          </div>

          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #3:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-3"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 3"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-3"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 3"
            />
          </div>

          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #4:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-4"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 4"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-4"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 4"
            />
          </div>
        </div>
      </details>

      <div class="input-group">
        <label for="search-engine-input">Search Engine ID (cx):</label>
        <div class="input-wrapper">
          <input
            type="text"
            id="search-engine-input"
            placeholder="Nh·∫≠p Search Engine ID"
          />
        </div>
      </div>

      <div class="button-group">
        <button class="save-btn" id="save-btn">üíæ L∆∞u</button>
        <button class="test-btn" id="test-btn">üß™ Ki·ªÉm tra</button>
      </div>
      <div
        class="guide-section"
        style="
          margin-top: 20px;
          border-top: 1px solid rgba(255, 255, 255, 0.2);
          padding-top: 15px;
        "
      >
        <h3>üéôÔ∏è C√†i ƒë·∫∑t Azure Speech (Pronunciation):</h3>
        <ol>
          <li>
            T·∫°o resource <strong>Speech Services</strong> tr√™n Azure Portal
          </li>
          <li>L·∫•y Key v√† Region (v√≠ d·ª•: eastus, southeastasia)</li>
        </ol>
      </div>

      <div class="input-group">
        <label for="azure-key-input">Azure Speech Key:</label>
        <div class="input-wrapper">
          <input
            type="password"
            id="azure-key-input"
            placeholder="Nh·∫≠p Azure Subscription Key"
          />
        </div>
      </div>

      <div class="input-group">
        <label for="azure-region-input">Azure Region:</label>
        <div class="input-wrapper">
          <input
            type="text"
            id="azure-region-input"
            placeholder="V√≠ d·ª•: eastus"
          />
        </div>
      </div>
      <div class="status-message" id="status-message"></div>

      <div class="info-note">
        üí° <strong>L∆∞u √Ω:</strong> N·∫øu kh√¥ng c·∫•u h√¨nh Google API, extension s·∫Ω
        t·ª± ƒë·ªông s·ª≠ d·ª•ng Unsplash ƒë·ªÉ l·∫•y h√¨nh ·∫£nh.
      </div>
    </div>

    <script src="popup.js"></script>
  </body>
</html>



================================================
FILE: apps/extension/popup.js
================================================
document.addEventListener("DOMContentLoaded", async () => {
  // Elements cho Azure (Gi·ªØ nguy√™n)
  const azureKeyInput = document.getElementById("azure-key-input");
  const azureRegionInput = document.getElementById("azure-region-input");
  const saveBtn = document.getElementById("save-btn");
  const testBtn = document.getElementById("test-btn");

  // X·ª≠ l√Ω n√∫t m·∫Øt th·∫ßn (Toggle Visibility) cho t·∫•t c·∫£ input password
  document.querySelectorAll(".toggle-visibility").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      // T√¨m input c√πng c·∫•p v·ªõi n√∫t b·∫•m
      const input = e.target.parentElement.querySelector("input");
      if (input) {
        input.type = input.type === "password" ? "text" : "password";
      }
    });
  });

  // --- 1. LOAD DATA ---
  chrome.storage.sync.get(
    ["googleApiKeys", "azureKey", "azureRegion"], // L∆∞u √Ω: key m·ªõi l√† 'googleApiKeys' (d·∫°ng m·∫£ng)
    (result) => {
      // Load Azure
      if (result.azureKey) azureKeyInput.value = result.azureKey;
      if (result.azureRegion) azureRegionInput.value = result.azureRegion;

      // Load Google Keys (List)
      const keys = result.googleApiKeys || [];

      // Loop qua 5 slot ƒë·ªÉ ƒëi·ªÅn d·ªØ li·ªáu
      for (let i = 0; i < 5; i++) {
        const keyInput = document.getElementById(`api-key-${i}`);
        const cxInput = document.getElementById(`cx-${i}`);

        if (keys[i]) {
          if (keyInput) keyInput.value = keys[i].key || "";
          if (cxInput) cxInput.value = keys[i].cx || "";
        }
      }
    }
  );

  // --- 2. SAVE DATA ---
  saveBtn.addEventListener("click", () => {
    const azureKey = azureKeyInput.value.trim();
    const azureRegion = azureRegionInput.value.trim();

    // Gom d·ªØ li·ªáu t·ª´ 5 slot Google
    let googleKeysList = [];
    for (let i = 0; i < 5; i++) {
      const keyVal = document.getElementById(`api-key-${i}`).value.trim();
      const cxVal = document.getElementById(`cx-${i}`).value.trim();

      // Ch·ªâ l∆∞u n·∫øu c√≥ ƒëi·ªÅn Key (CX c√≥ th·ªÉ d√πng chung ho·∫∑c ri√™ng)
      if (keyVal) {
        googleKeysList.push({
          key: keyVal,
          cx: cxVal, // N·∫øu cx tr·ªëng, logic b√™n content.js s·∫Ω handle sau
        });
      }
    }

    // Validation
    if (googleKeysList.length === 0) {
      showStatusMessage("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 1 Google API Key ch√≠nh!", "warning");
      return;
    }

    // Save to Storage
    chrome.storage.sync.set(
      {
        googleApiKeys: googleKeysList, // L∆∞u d·∫°ng m·∫£ng object
        azureKey: azureKey,
        azureRegion: azureRegion,
      },
      () => {
        showStatusMessage(
          `‚úÖ ƒê√£ l∆∞u ${googleKeysList.length} b·ªô key!`,
          "success"
        );
        setTimeout(hideStatusMessage, 3000);
      }
    );
  });

  // --- 3. TEST API (Test key ƒë·∫ßu ti√™n) ---
  testBtn.addEventListener("click", async () => {
    const key0 = document.getElementById("api-key-0").value.trim();
    const cx0 = document.getElementById("cx-0").value.trim();

    if (!key0 || !cx0) {
      showStatusMessage("‚ö†Ô∏è C·∫ßn nh·∫≠p Key & CX ·ªü √¥ ƒë·∫ßu ti√™n ƒë·ªÉ test", "warning");
      return;
    }

    showStatusMessage("‚è≥ ƒêang test Key ch√≠nh...", "loading");

    try {
      const url = `https://www.googleapis.com/customsearch/v1?q=test&cx=${cx0}&searchType=image&key=${key0}&num=1`;
      const response = await fetch(url);

      if (response.ok) {
        showStatusMessage("‚úÖ Key ch√≠nh ho·∫°t ƒë·ªông ngon l√†nh!", "success");
        setTimeout(hideStatusMessage, 3000);
      } else {
        const errorData = await response.json();
        showStatusMessage(
          `‚ùå L·ªói: ${errorData.error?.message || "Check l·∫°i Key/CX"}`,
          "error"
        );
      }
    } catch (error) {
      showStatusMessage(`‚ùå L·ªói m·∫°ng: ${error.message}`, "error");
    }
  });
});

function showStatusMessage(message, type) {
  const statusDiv = document.getElementById("status-message");
  statusDiv.textContent = message;
  statusDiv.className = `status-message show ${type}`;
}

function hideStatusMessage() {
  const statusDiv = document.getElementById("status-message");
  statusDiv.className = "status-message";
}



================================================
FILE: apps/extension/content-scripts/lookup-main.js
================================================
// =======================================================================
// MODULE: MAIN CONTROLLER (Entry Point)
// =======================================================================

let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;
let lastRecordedBlob = null;

// 1. Handle Mark Click
async function onMarkClick(btnElement, statusElement, data) {
  if (!data) return;
  btnElement.disabled = true;
  btnElement.style.opacity = "0.7";
  btnElement.style.transform = "scale(0.9)";
  statusElement.innerHTML = '<span style="color:#2196F3">‚è≥ ƒêang l∆∞u...</span>';

  try {
    await apiSaveVocabulary(data);
    btnElement.style.background = "#4CAF50";
    btnElement.style.boxShadow = "0 4px 0 #388E3C";
    statusElement.innerHTML =
      '<span style="color:#4CAF50;">‚úÖ ƒê√£ l∆∞u v√†o s·ªï t·ª´!</span>';
    await saveToHistory(data.text, data);
  } catch (err) {
    btnElement.style.background = "#FF9800";
    if (err.message.includes("Ch∆∞a ƒëƒÉng nh·∫≠p")) {
      statusElement.innerHTML =
        '<span style="color:#F44336">‚ö†Ô∏è Vui l√≤ng ƒëƒÉng nh·∫≠p App!</span>';
    } else {
      statusElement.innerHTML = `<span style="color:#F44336">‚ùå L·ªói: ${err.message}</span>`;
    }
  } finally {
    btnElement.disabled = false;
    btnElement.style.opacity = "1";
    btnElement.style.transform = "scale(1)";
  }
}

// 2. Handle Mic Click
async function handleMicClick(referenceText, btnElement, existingVocab) {
  if (!isRecording) {
    try {
      if (!navigator.mediaDevices) {
        alert("Mic not supported");
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const resultDiv = document.getElementById("assessment-result");
        if (resultDiv)
          resultDiv.innerHTML =
            '<div style="font-size:12px; color:#ddd; text-align:center;">‚è≥ Processing...</div>';
        try {
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          lastRecordedBlob = audioBlob;
          if (audioBlob.size < 1000) throw new Error("No audio detected.");

          // 1. G·ªçi Azure l·∫•y ƒëi·ªÉm (Code c≈©)
          const result = await assessPronunciation(audioBlob, referenceText);

          // üëá [NEW CODE] T·ª± ƒë·ªông l∆∞u ƒëi·ªÉm v√† th·ªùi gian n·∫øu t·ª´ ƒë√£ t·ªìn t·∫°i
          if (
            existingVocab &&
            existingVocab.id &&
            result.NBest &&
            result.NBest[0]
          ) {
            const score = result.NBest[0].AccuracyScore;

            // G·ªçi API l∆∞u ƒëi·ªÉm ng·∫ßm (kh√¥ng c·∫ßn await ƒë·ªÉ UI ph·∫£n h·ªìi nhanh)
            apiAddScore(existingVocab.id, score).then((success) => {
              if (success) console.log("‚úÖ Score & Time synced to DB!");
            });

            // C·∫≠p nh·∫≠t l·∫°i UI Badge ƒëi·ªÉm ngay l·∫≠p t·ª©c (Optional - Visual feedback)
            // B·∫°n c√≥ th·ªÉ update l·∫°i bi·∫øn existingVocab.pronunciationScores local ·ªü ƒë√¢y n·∫øu mu·ªën
          }
          // üëÜ [END NEW CODE]

          renderAssessmentResult(result, resultDiv, referenceText, {
            playUserAudio: () => {
              const u = URL.createObjectURL(lastRecordedBlob);
              new Audio(u).play();
            },
            speakEdge: speakWithEdgeTTS,
          });
        } catch (err) {
          if (resultDiv)
            resultDiv.innerHTML = `<div style="color:#ff5252; text-align:center;">‚ùå ${err.message}</div>`;
        } finally {
          stream.getTracks().forEach((t) => t.stop());
        }
      };
      mediaRecorder.start();
      isRecording = true;
      btnElement.classList.add("recording");
    } catch (err) {
      alert("Mic Error: " + err.message);
    }
  } else {
    if (mediaRecorder) mediaRecorder.stop();
    isRecording = false;
    btnElement.classList.remove("recording");
  }
}

// 3. Main Event Listener
document.addEventListener("keydown", async (e) => {
  if (e.key === "Shift") {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();

    if (selectedText) {
      let contextText = "";
      try {
        if (selection.anchorNode && selection.anchorNode.parentElement) {
          const parentText = selection.anchorNode.parentElement.innerText;
          const idx = parentText.indexOf(selectedText);
          if (idx !== -1) {
            contextText = parentText
              .substring(
                Math.max(0, idx - 100),
                Math.min(parentText.length, idx + selectedText.length + 100)
              )
              .trim()
              .replace(/\s+/g, " ");
          }
        }
      } catch (err) {}
      if (contextText.length > 200)
        contextText = "..." + contextText.substring(0, 200) + "...";

      const rect = selection.getRangeAt(0).getBoundingClientRect();
      const popup = createPopup();
      isPopupOpen = true;

      const topPos =
        rect.top + window.scrollY - 450 < window.scrollY
          ? rect.bottom + window.scrollY + 10
          : rect.top + window.scrollY - 450;
      const leftPos =
        rect.left + window.scrollX + 350 > window.innerWidth
          ? window.innerWidth - 360
          : rect.left + window.scrollX;

      popup.style.top = `${topPos}px`;
      popup.style.left = `${leftPos}px`;
      popup.innerHTML =
        '<div class="tts-content"><div class="tts-loading">‚è≥ ƒêang ph√¢n t√≠ch...</div></div>';
      popup.style.display = "block";

      speakWithEdgeTTS(selectedText);

      let data = await getFromCache(selectedText);
      if (!data) {
        const isLong = selectedText.split(/\s+/).length > 5;
        const [translation, images] = await Promise.all([
          getTranslation(selectedText, contextText),
          isLong ? [] : getImages(selectedText),
        ]);
        data = {
          translation,
          phonetics: await getPhoneticForText(selectedText),
          images,
          text: selectedText,
          contextText,
        };
        if (translation) await saveToCache(selectedText, data);
      } else if (contextText && !data.contextMeaning) {
        const tr = await getTranslation(selectedText, contextText);
        if (tr) data.translation = tr;
      }

      // üëá [UPDATE] Logic ki·ªÉm tra DB
      let existingVocab = null;
      try {
        existingVocab = await apiCheckVocabulary(selectedText);
      } catch (e) {}

      // G·ªôp th√¥ng tin existing v√†o data
      data.existing = existingVocab; // üëà Th√™m c√°i n√†y ƒë·ªÉ UI bi·∫øt

      renderPopupContent(data, isSoundEnabled, {
        toggleSound: toggleSoundState,
        closePopup,
        speakEdge: speakWithEdgeTTS,
        handleMic: (referenceText, btnElement) =>
          handleMicClick(referenceText, btnElement, existingVocab),
        handleMark: (btn, status) => onMarkClick(btn, status, data),
      });
    } else if (isPopupOpen) {
      closePopup();
    }
  } else if (e.key === "Escape" && isPopupOpen) {
    closePopup();
  }
});

// 4. Flashcard Listener
// 4. Flashcard Listener
chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
  if (request.action === "SHOW_FLASHCARD") {
    console.log("üì© Received SHOW_FLASHCARD message");

    try {
      // Step 1: L·∫•y danh s√°ch t·ª´ Starred t·ª´ Backend
      const list = await apiGetStarredVocabulary();

      if (list && list.length > 0) {
        // Step 2: L·∫•y index hi·ªán t·∫°i t·ª´ Storage (Logic Xoay V√≤ng)
        const storageData = await chrome.storage.local.get([
          "flashcardCurrentIndex",
        ]);
        let currentIndex = storageData.flashcardCurrentIndex || 0;

        // Validate: N·∫øu index v∆∞·ª£t qu√° ƒë·ªô d√†i list (do x√≥a b·ªõt t·ª´), reset v·ªÅ 0
        if (currentIndex >= list.length) {
          currentIndex = 0;
        }

        // Pick t·ª´ theo th·ª© t·ª±
        const selectedItem = list[currentIndex];
        console.log(
          `üîÑ Rotational Pick [${currentIndex + 1}/${list.length}]:`,
          selectedItem.word
        );

        // Step 3: T√≠nh to√°n Index ti·∫øp theo v√† L∆∞u l·∫°i ngay
        const nextIndex = (currentIndex + 1) % list.length; // Quay v√≤ng v·ªÅ 0 n·∫øu h·∫øt list
        await chrome.storage.local.set({ flashcardCurrentIndex: nextIndex });

        // Step 4: Map Data
        const flashcardItem = {
          word: selectedItem.word,
          data: {
            translation: selectedItem.meaning || "No definition",
            pronunciation: selectedItem.pronunciation || "",
            partOfSpeech: selectedItem.partOfSpeech || "",
            images: [],
          },
        };

        // Step 5: Show UI (Gi·ªØ nguy√™n logic c≈©)
        showFlashcard(flashcardItem, {
          speakEdge: speakWithEdgeTTS,

          // Mic Logic
          onMic: () => {
            if (window.NativeUI) {
              window.NativeUI.renderAssessmentModal(
                {
                  ...selectedItem,
                  pronunciation: selectedItem.pronunciation || "",
                },
                {
                  onSpeak: (t) => speakWithEdgeTTS(t),
                  onRecord: async (onSuccess, onError) => {
                    try {
                      const stream = await navigator.mediaDevices.getUserMedia({
                        audio: true,
                      });
                      const mediaRecorder = new MediaRecorder(stream);
                      const chunks = [];
                      mediaRecorder.ondataavailable = (e) =>
                        chunks.push(e.data);
                      mediaRecorder.onstop = async () => {
                        const blob = new Blob(chunks, { type: "audio/webm" });
                        window.lastRecordedBlob = blob;
                        try {
                          const result = await assessPronunciation(
                            blob,
                            selectedItem.word
                          );
                          if (
                            selectedItem.id &&
                            result.NBest &&
                            result.NBest[0]
                          ) {
                            apiAddScore(
                              selectedItem.id,
                              result.NBest[0].AccuracyScore
                            );
                          }
                          if (result.NBest) onSuccess(result.NBest[0]);
                          else onError("No result");
                        } catch (err) {
                          onError(err.message);
                        }
                        stream.getTracks().forEach((t) => t.stop());
                      };
                      mediaRecorder.start();
                      window.currentRecorder = mediaRecorder;
                    } catch (e) {
                      onError("Mic Error: " + e.message);
                    }
                  },
                  onStop: () => {
                    if (window.currentRecorder) window.currentRecorder.stop();
                  },
                  onPlayback: () => {
                    if (window.lastRecordedBlob) {
                      const url = URL.createObjectURL(window.lastRecordedBlob);
                      new Audio(url).play();
                    }
                  },
                }
              );
            }
          },

          // Edit Logic
          onEdit: () => {
            if (window.NativeUI) {
              window.NativeUI.renderFormModal(
                { ...selectedItem, isEditMode: true },
                {
                  onAutoFill: () => null,
                  onSave: async (d) => {
                    await apiUpdateVocabulary(d.id, d);
                  },
                }
              );
            }
          },
        });
      } else {
        console.log(
          "‚ö†Ô∏è No starred words found. Please star some words in App."
        );
      }
    } catch (e) {
      console.error("üî• Flashcard Error:", e);
    }
  }
});



================================================
FILE: apps/extension/content-scripts/lookup-services.js
================================================
// =======================================================================
// MODULE: SERVICES (API, Audio, Caching)
// =======================================================================

const BACKEND_URL = APP_CONFIG.API_URL;
let isSoundEnabled = true;

// --- 1. SETTINGS & AUDIO ---
function toggleSoundState() {
  isSoundEnabled = !isSoundEnabled;
  if (!isSoundEnabled) window.speechSynthesis.cancel();
  return isSoundEnabled;
}

async function speakWithEdgeTTS(text) {
  if (!isSoundEnabled || !text) return;
  window.speechSynthesis.cancel();

  try {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "en-US";
    utterance.rate = 0.9;

    // Fix l·ªói Chrome load voice ch·∫≠m
    let voices = window.speechSynthesis.getVoices();
    if (voices.length === 0) {
      await new Promise((resolve) => {
        window.speechSynthesis.onvoiceschanged = () => {
          voices = window.speechSynthesis.getVoices();
          resolve();
        };
      });
    }

    // ∆Øu ti√™n Microsoft Aria Online
    const ariaVoice =
      voices.find((v) => v.name.includes("Microsoft Aria Online")) ||
      voices.find((v) => v.name.includes("Aria")) ||
      voices.find(
        (v) => v.name.includes("Natural") && v.lang.startsWith("en-US")
      ) ||
      voices.find((v) => v.lang === "en-US");

    if (ariaVoice) utterance.voice = ariaVoice;
    window.speechSynthesis.speak(utterance);
  } catch (error) {
    console.error("TTS Error:", error);
  }
}

// --- 2. BACKEND API (SAVE VOCAB) ---
// apps/extension/content-scripts/lookup-services.js

// --- 2. BACKEND API (SAVE VOCAB) ---
async function apiSaveVocabulary(data) {
  // üëá 1. LOG CHECK CONFIG
  console.log(
    `%c[EXT-DEBUG] üöÄ Starting Save...`,
    "color: cyan; font-weight: bold"
  );
  console.log(`[EXT-DEBUG] Backend URL:`, BACKEND_URL);

  try {
    const meaning =
      typeof data.translation === "string"
        ? data.translation
        : data.translation?.wordMeaning || "";

    const partOfSpeech =
      data.translation?.dict && data.translation.dict.length > 0
        ? data.translation.dict[0].pos
        : "";

    const pronunciation = data.phonetics?.us
      ? data.phonetics.us.replace(/\//g, "")
      : "";

    const payload = {
      word: data.text,
      meaning: meaning,
      example: data.contextText || "",
      pronunciation: pronunciation,
      partOfSpeech: partOfSpeech,
      topic: "Extension",
      isStarred: false,
    };

    // üëá 2. LOG REQUEST
    console.log(`[EXT-DEBUG] Payload:`, payload);
    console.log(`[EXT-DEBUG] Sending request to: ${BACKEND_URL}/vocabulary`);

    const response = await fetch(`${BACKEND_URL}/vocabulary`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      credentials: "include",
    });

    // üëá 3. LOG RESPONSE STATUS
    console.log(`[EXT-DEBUG] Response Status:`, response.status);

    if (!response.ok) {
      const errText = await response.text();
      console.error(`[EXT-DEBUG] Server Error Body:`, errText); // Xem server tr·∫£ v·ªÅ l·ªói g√¨

      if (response.status === 401) throw new Error("Ch∆∞a ƒëƒÉng nh·∫≠p (401)");
      if (response.status === 403) throw new Error("B·ªã ch·∫∑n quy·ªÅn (403)");
      throw new Error(`L·ªói Server: ${response.status}`);
    }

    const json = await response.json();
    console.log(`[EXT-DEBUG] Success Data:`, json);
    return json;
  } catch (error) {
    // üëá 4. LOG NETWORK ERROR (Quan tr·ªçng nh·∫•t)
    console.error(`[EXT-DEBUG] üî• FATAL ERROR:`, error);

    if (error.message.includes("Failed to fetch")) {
      console.warn(
        `[EXT-DEBUG] üëâ G·ª£i √Ω: C√≥ th·ªÉ do l·ªói SSL, CORS, ho·∫∑c ch∆∞a add host_permissions trong manifest.`
      );
    }
    throw error;
  }
}

// --- 3. CACHING SYSTEM ---
async function getFromCache(key) {
  const storageKey = `cache_${key.toLowerCase().trim()}`;
  const result = await chrome.storage.local.get([storageKey]);
  const cachedItem = result[storageKey];
  if (cachedItem && Date.now() - cachedItem.timestamp < 24 * 60 * 60 * 1000) {
    return cachedItem.data;
  }
  return null;
}

async function saveToCache(key, data) {
  const storageKey = `cache_${key.toLowerCase().trim()}`;
  await chrome.storage.local.set({
    [storageKey]: { data: data, timestamp: Date.now() },
  });
}

async function saveToHistory(word, data) {
  try {
    const result = await chrome.storage.local.get(["vocabHistory"]);
    let history = result.vocabHistory || [];
    history = history.filter(
      (item) =>
        item && item.word && item.word.toLowerCase() !== word.toLowerCase()
    );
    history.unshift({ word: word, data: data, timestamp: Date.now() });
    if (history.length > 50) history.pop();
    await chrome.storage.local.set({ vocabHistory: history });
  } catch (e) {
    console.warn("History Error:", e);
  }
}

// --- 4. GOOGLE TRANSLATE API ---
async function getTranslation(text, contextText = "") {
  try {
    let contextMeaning = null;
    if (contextText && contextText.length > 0 && contextText !== text) {
      try {
        const urlCtx = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&q=${encodeURIComponent(
          contextText
        )}`;
        const resCtx = await fetch(urlCtx);
        if (resCtx.ok) {
          const dataCtx = await resCtx.json();
          if (dataCtx && dataCtx[0])
            contextMeaning = dataCtx[0].map((item) => item[0]).join("");
        }
      } catch (e) {}
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&dt=bd&q=${encodeURIComponent(
      text
    )}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error("Google API Error");
    const data = await response.json();

    if (data) {
      const mainMeaning = data[0]
        ? data[0].map((item) => item[0]).join("")
        : "";
      let dict = [];
      if (data[1]) {
        data[1].forEach((group) => {
          dict.push({ pos: group[0], terms: group[1].slice(0, 5) });
        });
      }
      return {
        wordMeaning: mainMeaning,
        contextMeaning: contextMeaning,
        dict: dict,
      };
    }
  } catch (error) {
    return null;
  }
  return null;
}

// --- 5. IMAGE API ---
async function tryFetchGoogleImage(searchTerm, apiKey, cx) {
  try {
    const url = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(
      searchTerm
    )}&cx=${cx}&searchType=image&key=${apiKey}&num=3`;
    const response = await fetch(url);
    if (response.status === 403 || response.status === 429)
      throw new Error(`QUOTA_EXCEEDED`);
    if (!response.ok) return null;
    const data = await response.json();
    if (data.items && data.items.length > 0)
      return data.items.map((item) => item.link);
  } catch (e) {
    if (e.message === "QUOTA_EXCEEDED") throw e;
  }
  return null;
}

async function getImages(englishText) {
  const searchTerm = englishText.trim();
  let images = [];
  const result = await chrome.storage.sync.get([
    "googleApiKeys",
    "googleApiKey",
    "googleSearchEngineId",
  ]);
  let keyList = result.googleApiKeys || [];
  if (
    keyList.length === 0 &&
    result.googleApiKey &&
    result.googleSearchEngineId
  ) {
    keyList.push({ key: result.googleApiKey, cx: result.googleSearchEngineId });
  }

  if (keyList.length > 0) {
    for (const { key, cx } of keyList) {
      if (!key || !cx) continue;
      try {
        const res = await tryFetchGoogleImage(searchTerm, key, cx);
        if (res) {
          images = res;
          break;
        }
      } catch (err) {
        continue;
      }
    }
  }
  // Fallback Unsplash
  if (images.length === 0) {
    try {
      const res = await fetch(
        `https://api.unsplash.com/search/photos?query=${encodeURIComponent(
          searchTerm
        )}&per_page=3&client_id=E8nbwS_cEWGVX4rM0e_-Eq6IpI_QKlO4eFEKfOl3AUo`
      );
      if (res.ok) {
        const data = await res.json();
        if (data.results) images = data.results.map((i) => i.urls.regular);
      }
    } catch (e) {}
  }
  return images;
}

// --- 6. PHONETICS (UPDATED FROM OLD CODE) ---

// Helper: L·∫•y phi√™n √¢m t·ª´ng t·ª´ (Logic c≈©)
async function getPhoneticForWord(word) {
  try {
    const response = await fetch(
      `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
        word.trim()
      )}`
    );
    if (!response.ok) return null;

    const data = await response.json();
    if (data && data[0]) {
      const result = { uk: null, us: null };

      // ∆Øu ti√™n l·∫•y t·ª´ file audio ƒë·ªÉ bi·∫øt ch√≠nh x√°c gi·ªçng
      data[0].phonetics?.forEach((p) => {
        if (p.text) {
          if (p.audio && p.audio.includes("-uk")) {
            result.uk = p.text;
          } else if (p.audio && p.audio.includes("-us")) {
            result.us = p.text;
          } else if (!result.us && !result.uk) {
            result.us = p.text;
          }
        }
      });

      // Fallback n·∫øu kh√¥ng t√¨m th·∫•y trong phonetics array
      if (!result.uk && !result.us && data[0].phonetic) {
        result.us = data[0].phonetic;
      }
      return result;
    }
  } catch (error) {}
  return null;
}

// Main: L·∫•y phi√™n √¢m cho c·∫£ c√¢u/ƒëo·∫°n (Logic c≈©)
async function getPhoneticForText(text) {
  const words = text
    .trim()
    .split(/\s+/)
    .filter((w) => w.length > 0);
  const isLongText = words.length > 5;

  // Ch·∫°y song song request cho t·ª´ng t·ª´
  const phonetics = await Promise.all(
    words.map(async (word) => {
      const cleanWord = word.replace(/[.,!?;:'"()]/g, "");
      if (!cleanWord) return null;
      return await getPhoneticForWord(cleanWord);
    })
  );

  const ukParts = [];
  const usParts = [];

  phonetics.forEach((p, idx) => {
    if (p) {
      if (!isLongText && p.uk) ukParts.push(p.uk);

      if (p.us) usParts.push(p.us);
      else if (p.uk) usParts.push(p.uk); // Fallback UK sang US n·∫øu thi·∫øu
      else {
        // Fallback word g·ªëc n·∫øu kh√¥ng c√≥ phi√™n √¢m
        const cleanWord = words[idx].replace(/[.,!?;:'"()]/g, "");
        usParts.push(cleanWord);
      }
    } else {
      const cleanWord = words[idx].replace(/[.,!?;:'"()]/g, "");
      if (!isLongText) ukParts.push(cleanWord);
      usParts.push(cleanWord);
    }
  });

  const format = (parts) => {
    if (parts.length === 0) return null;
    const combined = parts
      .map((part) => (part ? part.replace(/^\/|\/$/g, "") : "")) // B·ªè d·∫•u / th·ª´a
      .filter(Boolean)
      .join(" ");
    return combined ? `/${combined}/` : null; // B·ªçc l·∫°i b·∫±ng //
  };

  return {
    uk: format(ukParts),
    us: format(usParts),
  };
}

// Helper: Convert Audio
async function convertAudioToWav(audioBlob) {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)({
    sampleRate: 16000,
  });
  const arrayBuffer = await audioBlob.arrayBuffer();
  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
  const pcmData = audioBuffer.getChannelData(0);

  const buffer = new ArrayBuffer(44 + pcmData.length * 2);
  const view = new DataView(buffer);
  const writeString = (view, offset, string) => {
    for (let i = 0; i < string.length; i++)
      view.setUint8(offset + i, string.charCodeAt(i));
  };
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + pcmData.length * 2, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, 16000, true);
  view.setUint32(28, 32000, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, "data");
  view.setUint32(40, pcmData.length * 2, true);
  let offset = 44;
  for (let i = 0; i < pcmData.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, pcmData[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
  }
  return new Blob([view], { type: "audio/wav" });
}

async function assessPronunciation(audioBlob, referenceText) {
  try {
    const result = await chrome.storage.sync.get(["azureKey", "azureRegion"]);
    const key = result.azureKey;
    const region = result.azureRegion;
    if (!key || !region) throw new Error("Ch∆∞a nh·∫≠p Azure Key/Region.");

    const wavBlob = await convertAudioToWav(audioBlob);
    const assessParams = {
      ReferenceText: referenceText,
      GradingSystem: "HundredMark",
      Granularity: "Phoneme",
      Dimension: "Comprehensive",
      PhonemeAlphabet: "IPA",
    };
    const paramsHeader = btoa(JSON.stringify(assessParams));

    const url = `https://${region}.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=en-US`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Ocp-Apim-Subscription-Key": key,
        "Content-Type": "audio/wav; codecs=audio/pcm; samplerate=16000",
        Accept: "application/json",
        "Pronunciation-Assessment": paramsHeader,
      },
      body: wavBlob,
    });

    if (!response.ok) throw new Error(`Azure Error ${response.status}`);
    return await response.json();
  } catch (e) {
    throw e;
  }
}
// --- [NEW] CHECK VOCAB EXISTENCE ---
async function apiCheckVocabulary(word) {
  try {
    const response = await fetch(
      `${BACKEND_URL}/vocabulary/check?word=${encodeURIComponent(word)}`,
      {
        method: "GET",
        headers: { "Content-Type": "application/json" },
        credentials: "include", // ƒê·ªÉ l·∫•y cookie auth
      }
    );
    if (response.ok) {
      const data = await response.json();
      return data; // Tr·∫£ v·ªÅ object t·ª´ v·ª±ng n·∫øu c√≥, ho·∫∑c null/r·ªóng
    }
  } catch (e) {
    console.warn("Check vocab failed:", e);
  }
  return null;
}
// --- [NEW] UPDATE SCORE TO BACKEND ---
async function apiAddScore(vocabId, score) {
  // N·∫øu vocabId l√† "temp" ho·∫∑c kh√¥ng c√≥ ID -> Kh√¥ng l∆∞u ƒë∆∞·ª£c (ch·ªâ luy·ªán t·∫≠p)
  if (!vocabId || vocabId === "temp") return false;

  try {
    const response = await fetch(`${BACKEND_URL}/vocabulary/${vocabId}/score`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ score: Math.round(score) }),
      credentials: "include",
    });
    return response.ok;
  } catch (e) {
    console.error("Save score failed:", e);
    return false;
  }
}

// T√¨m ki·∫øm danh s√°ch t·ª´ (cho Quick Search)
async function apiSearchVocabulary(keyword) {
  try {
    if (!keyword) return [];
    const res = await fetch(
      `${BACKEND_URL}/vocabulary?search=${encodeURIComponent(keyword)}&limit=5`,
      {
        headers: { "Content-Type": "application/json" },
        credentials: "include",
      }
    );
    if (res.ok) {
      const json = await res.json();
      return json.data; // Tr·∫£ v·ªÅ m·∫£ng items
    }
  } catch (e) {}
  return [];
}

// H√†m Save ƒë·∫ßy ƒë·ªß (thay th·∫ø ho·∫∑c b·ªï sung cho apiSaveVocabulary c≈©)
async function apiCreateFullVocabulary(payload) {
  // Payload: { word, meaning, example, topic, partOfSpeech, pronunciation, relatedWords }
  const response = await fetch(`${BACKEND_URL}/vocabulary`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
    credentials: "include",
  });
  if (!response.ok) throw new Error("Save failed");
  return await response.json();
}
async function apiUpdateVocabulary(id, data) {
  try {
    const payload = {
      word: data.word,
      meaning: data.meaning,
      example: data.example,
      topic: data.topic,
      partOfSpeech: data.partOfSpeech,
      pronunciation: data.pronunciation,
      relatedWords: data.relatedWords,
      // Backend kh√¥ng nh·∫≠n 'isEditMode' n√™n ƒë·ª´ng g·ª≠i
    };

    const response = await fetch(`${BACKEND_URL}/vocabulary/${id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      credentials: "include",
    });

    if (!response.ok) throw new Error("Update failed");
    return await response.json();
  } catch (error) {
    throw error;
  }
}
// --- [NEW] D·ªäCH VI·ªÜT -> ANH ---
async function translateViToEn(vietnameseText) {
  try {
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=vi&tl=en&dt=t&q=${encodeURIComponent(
      vietnameseText
    )}`;
    const response = await fetch(url);
    if (!response.ok) return null;
    const data = await response.json();
    if (data && data[0]) {
      return data[0].map((item) => item[0]).join("");
    }
  } catch (error) {
    console.error("Translate VI->EN error:", error);
  }
  return null;
}
// ... (c√°c code c≈© gi·ªØ nguy√™n)

// --- [NEW] FETCH STARRED VOCABULARY ---
async function apiGetStarredVocabulary() {
  try {
    // G·ªçi API l·∫•y danh s√°ch t·ª´ ƒë√£ Star (L·∫•y limit 50 t·ª´ m·ªõi nh·∫•t ƒë·ªÉ random)
    const res = await fetch(
      `${BACKEND_URL}/vocabulary?isStarred=true&limit=50`,
      {
        method: "GET",
        headers: { "Content-Type": "application/json" },
        credentials: "include", // Quan tr·ªçng ƒë·ªÉ g·ª≠i Cookie Auth
      }
    );

    if (res.ok) {
      const json = await res.json();
      return json.data; // Tr·∫£ v·ªÅ m·∫£ng VocabItem
    }
  } catch (e) {
    console.error("Fetch starred failed:", e);
  }
  return [];
}



================================================
FILE: apps/extension/content-scripts/lookup-ui.js
================================================
// =======================================================================
// MODULE: UI RENDERING
// =======================================================================

let popup = null;
let isPopupOpen = false;
let isDragging = false;
let dragOffset = { x: 0, y: 0 };

function createPopup() {
  if (popup) popup.remove();
  popup = document.createElement("div");
  popup.id = "tts-popup";
  popup.style.display = "none";
  document.body.appendChild(popup);
  return popup;
}

function closePopup() {
  if (popup) popup.style.display = "none";
  window.speechSynthesis.cancel();
  isPopupOpen = false;
}

function enableDragging(header) {
  header.style.cursor = "move";
  header.addEventListener("mousedown", (e) => {
    if (e.target.closest("button")) return;
    isDragging = true;
    const rect = popup.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    header.style.cursor = "grabbing";
  });
  document.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    e.preventDefault();
    popup.style.left = e.clientX - dragOffset.x + "px";
    popup.style.top = e.clientY - dragOffset.y + "px";
  });
  document.addEventListener("mouseup", () => {
    isDragging = false;
    header.style.cursor = "move";
  });
}

function renderPopupContent(data, isSoundEnabled, callbacks) {
  if (!popup) return;
  const { toggleSound, closePopup, speakEdge, handleMark, handleMic } =
    callbacks;

  const existing = data.existing;

  // Logic t√≠nh ƒëi·ªÉm trung b√¨nh 3 l·∫ßn g·∫ßn nh·∫•t (n·∫øu c√≥)
  let scoreBadge = "";
  if (
    existing &&
    existing.pronunciationScores &&
    existing.pronunciationScores.length > 0
  ) {
    const scores = existing.pronunciationScores.slice(-3); // L·∫•y 3 ƒëi·ªÉm cu·ªëi
    const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
    let color = avg >= 80 ? "#4CAF50" : avg >= 60 ? "#FFC107" : "#F44336";
    scoreBadge = `<span style="position:absolute; top:-5px; right:-5px; background:${color}; color:white; font-size:10px; padding:2px 5px; border-radius:10px; border:1px solid white;">${avg}</span>`;
  }

  // üëá [UPDATE] Render n√∫t Mark
  let markBtnHtml = "";
  if (existing) {
    // A. ƒê√É C√ì: Hi·ªán n√∫t "ƒê√£ l∆∞u" (M√†u x√°m ho·∫∑c Xanh ƒë·∫≠m, kh√¥ng cho click save n·ªØa)
    markBtnHtml = `
        <button id="mark-btn-disabled" class="mic-btn" style="width:55px; height:55px; background:#E0E0E0; box-shadow:none; cursor:default; position:relative;" title="ƒê√£ c√≥ trong b·ªô t·ª´ v·ª±ng">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="#4CAF50" stroke="#4CAF50" stroke-width="2">
              <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
            ${scoreBadge}
        </button>`;
  } else {
    // B. CH∆ØA C√ì: Hi·ªán n√∫t Save nh∆∞ c≈©
    markBtnHtml = `
        <button id="mark-btn" class="mic-btn" style="width:55px; height:55px; background:#FF9800; box-shadow: 0 4px 0 #F57C00;" title="L∆∞u t·ª´ n√†y">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
        </button>`;
  }

  let content = `
      <div class="tts-header" id="popup-header">
        <button id="sound-toggle" class="sound-btn">${
          isSoundEnabled ? "üîä" : "üîá"
        }</button>
        <div style="flex:1"></div>
        <button id="close-popup" class="close-btn">‚úï</button>
      </div>

      <div class="tts-actions">
        <div style="display:flex; gap:15px; align-items:center;">
            <button id="replay-tts-btn" class="mic-btn" style="width:45px; height:45px; background:#4CAF50;" title="Nghe l·∫°i">
               <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
            </button>
            
            ${markBtnHtml}

            <button id="mic-btn" class="mic-btn" style="width:45px; height:45px;" title="Check ph√°t √¢m">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            </button>
        </div>
        <div id="save-status" style="margin-top:8px; font-size:12px; font-weight:600; min-height:18px;"></div>
        <div id="assessment-result"></div>
      </div>
      
      <div class="tts-content">`;

  // Images
  if (data.images && data.images.length) {
    content += `<div class="tts-images-container">${data.images
      .map(
        (url) =>
          `<div class="tts-image"><img src="${url}" onerror="this.style.display='none'"/></div>`
      )
      .join("")}</div>`;
  }
  // 2. Hi·ªÉn th·ªã Phi√™n √¢m
  if (data.phonetics && (data.phonetics.us || data.phonetics.uk)) {
    content += `<div class="tts-phonetic">
            ${
              data.phonetics.uk
                ? `<div class="phonetic-item"><span class="flag">üá¨üáß</span><span class="phonetic-text">${data.phonetics.uk}</span></div>`
                : ""
            }
            ${
              data.phonetics.us
                ? `<div class="phonetic-item"><span class="flag">üá∫üá∏</span><span class="phonetic-text">${data.phonetics.us}</span></div>`
                : ""
            }
        </div>`;
  }
  // Meaning
  if (data.translation) {
    content += `<div class="word-text" style="font-size:24px; text-align:center; margin-bottom:5px;">${data.text}</div>`;
    const mainMeaning =
      typeof data.translation === "string"
        ? data.translation
        : data.translation.wordMeaning;
    if (mainMeaning)
      content += `<div class="primary-meaning">${mainMeaning}</div>`;

    if (data.translation.contextMeaning) {
      content += `<div class="context-box"><strong>Ng·ªØ c·∫£nh:</strong><br/><em style="color:#777">"...${
        data.contextText || ""
      }..."</em><br/>üëâ <span style="color:#2e7d32; font-weight:600;">${
        data.translation.contextMeaning
      }</span></div>`;
    }
  } else {
    content += `<div class="tts-info">Kh√¥ng t√¨m th·∫•y b·∫£n d·ªãch.</div>`;
  }

  content += `</div>`; // End .tts-content
  popup.innerHTML = content;

  // Events
  enableDragging(document.getElementById("popup-header"));
  document.getElementById("close-popup").onclick = closePopup;
  document.getElementById("sound-toggle").onclick = toggleSound;
  document.getElementById("replay-tts-btn").onclick = () =>
    speakEdge(data.text);

  // Ch·ªâ g√°n s·ª± ki·ªán click n·∫øu n√∫t mark-btn t·ªìn t·∫°i (t·ª©c l√† ch∆∞a l∆∞u)
  const markBtn = document.getElementById("mark-btn");
  if (markBtn) {
    markBtn.onclick = (e) => {
      e.stopPropagation();
      handleMark(markBtn, document.getElementById("save-status"));
    };
  }

  // Mic Event
  const micBtn = document.getElementById("mic-btn");
  micBtn.onclick = (e) => {
    e.stopPropagation();
    handleMic(data.text, micBtn, data.existing); // üëà Th√™m data.existing
  };
}

function renderAssessmentResult(data, container, referenceText, callbacks) {
  if (!container) return;
  if (!data || data.error) {
    container.innerHTML = `<div style="color:#ff5252; text-align:center;">‚ö†Ô∏è ${
      data?.error || "L·ªói API"
    }</div>`;
    return;
  }
  const result = data.NBest[0];
  const totalScore =
    result.AccuracyScore || result.PronunciationAssessment?.AccuracyScore || 0;
  const words = result.Words || [];
  let scoreColor =
    totalScore >= 80 ? "#4caf50" : totalScore >= 60 ? "#ffeb3b" : "#ff5252";

  let html = `<div class="assessment-box" style="background:rgba(0,0,0,0.3); padding:15px; border-radius:8px; margin-top:10px;">
    <div class="assessment-actions">
        <button id="btn-play-user" class="action-btn-small btn-user-audio">üó£Ô∏è My Voice</button>
        <button id="btn-play-standard" class="action-btn-small btn-ref-audio">üéß Standard</button>
    </div>
    <div class="total-score-circle" style="border-color: ${scoreColor}; color: ${scoreColor}">${Math.round(
    totalScore
  )}</div>
    <div class="analyzed-content">`;

  words.forEach((word) => {
    const wScore =
      word.AccuracyScore || word.PronunciationAssessment?.AccuracyScore || 0;
    const errorType =
      word.ErrorType || word.PronunciationAssessment?.ErrorType || "None";
    let wordColor =
      errorType === "Omission" ? "#777" : wScore < 60 ? "#ff5252" : "#fff";
    let phonemeHtml = "";
    if (errorType !== "Omission") {
      (word.Phonemes || []).forEach((p) => {
        let pClass =
          p.AccuracyScore >= 90
            ? "p-perfect"
            : p.AccuracyScore >= 80
            ? "p-good"
            : p.AccuracyScore >= 60
            ? "p-fair"
            : "p-bad";
        phonemeHtml += `<span class="phoneme-char ${pClass}" title="/${p.Phoneme}/: ${p.AccuracyScore}">${p.Phoneme}</span>`;
      });
    } else {
      phonemeHtml = `<span style="font-size:10px; color:#999;">(missed)</span>`;
    }
    html += `<div class="word-block"><span class="word-text" style="color:${wordColor}">${word.Word}</span><div class="phoneme-row">${phonemeHtml}</div></div>`;
  });
  html += `</div></div>`;
  container.innerHTML = html;

  setTimeout(() => {
    const btnUser = document.getElementById("btn-play-user");
    const btnStandard = document.getElementById("btn-play-standard");
    if (btnUser) btnUser.onclick = callbacks.playUserAudio;
    if (btnStandard)
      btnStandard.onclick = () => callbacks.speakEdge(referenceText);
  }, 0);
}

[cite_start]; // [cite: 704]
function showFlashcard(item, callbacks) {
  // 1. X√≥a th·∫ª c≈©
  const oldCard = document.getElementById("vocab-flashcard");
  if (oldCard) oldCard.remove();

  // 2. L·∫•y tr·∫°ng th√°i √¢m thanh ƒë√£ l∆∞u (M·∫∑c ƒë·ªãnh l√† B·∫≠t)
  chrome.storage.local.get(["flashcard_sound_on"], (result) => {
    // L∆∞u √Ω: !== false nghƒ©a l√† undefined (l·∫ßn ƒë·∫ßu) c≈©ng l√† True
    let isSoundOn = result.flashcard_sound_on !== false;

    // 3. T·∫°o th·∫ª
    const card = document.createElement("div");
    card.id = "vocab-flashcard";
    card.className = "flashcard-slide-in";

    // Style G·ªçn nh·∫π, Hi·ªán ƒë·∫°i
    Object.assign(card.style, {
      cursor: "pointer",
      borderLeft: "5px solid #58cc02", // M√†u xanh th∆∞∆°ng hi·ªáu
      fontFamily: "'Segoe UI', sans-serif",
      display: "flex",
      flexDirection: "column",
      maxWidth: "280px", // G·ªçn g√†ng
      background: "#fff",
      boxShadow: "0 5px 20px rgba(0,0,0,0.15)",
      borderRadius: "8px",
      overflow: "hidden",
    });

    // Icons SVG
    const ICON_CLOSE = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
    const ICON_SOUND_ON = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#555" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;
    const ICON_SOUND_OFF = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#ff4d4f" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
    const ICON_MIC = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>`;

    // 4. Chu·∫©n b·ªã HTML cho Phi√™n √¢m & T·ª´ lo·∫°i
    const pronunHtml = item.data.pronunciation
      ? `<span style="font-family:monospace; font-size:12px; color:#888; margin-left:8px;">/${item.data.pronunciation}/</span>`
      : "";

    const posHtml = item.data.partOfSpeech
      ? `<span style="font-size:10px; font-weight:700; color:#1890ff; background:#e6f7ff; border:1px solid #91d5ff; padding:1px 4px; border-radius:4px; margin-left:6px; text-transform:uppercase; vertical-align:middle;">${item.data.partOfSpeech}</span>`
      : "";

    // 5. N·ªôi dung HTML
    card.innerHTML = `
      <div style="padding:12px 12px 4px 12px; display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
              <div style="display:flex; align-items:center; flex-wrap:wrap;">
                  <span style="font-size:18px; color:#333; font-weight:800; line-height:1.2;">${
                    item.word
                  }</span>
                  ${posHtml}
              </div>
              <div style="margin-top:2px;">${pronunHtml}</div>
          </div>
          <button id="fc-close" style="background:none; border:none; cursor:pointer; padding:4px;">${ICON_CLOSE}</button>
      </div>

      <div style="padding:4px 12px 12px 12px;">
          <p style="margin:0; font-size:15px; color:#444; line-height:1.4;">${
            item.data.translation
          }</p>
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center; padding:8px 12px; background:#f9f9f9; border-top:1px solid #eee;">
          <div style="display:flex; gap:8px;">
              <button id="fc-sound-btn" title="B·∫≠t/T·∫Øt ƒë·ªçc t·ª± ƒë·ªông" style="background:#fff; border:1px solid #ddd; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s;">
                  ${isSoundOn ? ICON_SOUND_ON : ICON_SOUND_OFF}
              </button>
              <button id="fc-mic-btn" title="Luy·ªán ph√°t √¢m" style="background:#fff; border:1px solid #ddd; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; color:#f57c00;">
                  ${ICON_MIC}
              </button>
          </div>
          <div id="fc-timer" style="font-size:11px; font-weight:bold; color:#aaa;">12s</div>
      </div>
    `;

    document.body.appendChild(card);

    // --- LOGIC ---

    // A. Auto Speak (Ch·ªâ ƒë·ªçc n·∫øu Sound ƒëang ON)
    if (isSoundOn) {
      callbacks.speakEdge(item.word);
    }

    // B. Toggle Sound & Save Memory
    const btnSound = document.getElementById("fc-sound-btn");
    btnSound.onclick = (e) => {
      e.stopPropagation();
      isSoundOn = !isSoundOn; // ƒê·ªïi tr·∫°ng th√°i

      // Update UI Icon
      btnSound.innerHTML = isSoundOn ? ICON_SOUND_ON : ICON_SOUND_OFF;

      // Save v√†o Storage (Quan tr·ªçng!)
      chrome.storage.local.set({ flashcard_sound_on: isSoundOn });

      if (!isSoundOn) window.speechSynthesis.cancel();
      else callbacks.speakEdge(item.word);
    };

    // C. C√°c n√∫t kh√°c
    document.getElementById("fc-mic-btn").onclick = (e) => {
      e.stopPropagation();
      card.remove();
      if (callbacks.onMic) callbacks.onMic();
    };

    document.getElementById("fc-close").onclick = (e) => {
      e.stopPropagation();
      card.remove();
      window.speechSynthesis.cancel();
    };

    // Click v√†o card ƒë·ªÉ Edit
    card.onclick = (e) => {
      if (e.target.closest("button")) return;
      card.remove();
      if (callbacks.onEdit) callbacks.onEdit();
    };

    // Timer Auto Close
    let timeLeft = 12;
    const interval = setInterval(() => {
      timeLeft--;
      const t = document.getElementById("fc-timer");
      if (t) t.innerText = `${timeLeft}s`;
      if (timeLeft <= 0) {
        clearInterval(interval);
        card.classList.add("flashcard-slide-out");
        setTimeout(() => {
          if (card.parentNode) card.remove();
        }, 500);
      }
    }, 1000);
  });
}



================================================
FILE: apps/extension/content-scripts/main.js
================================================
[Empty file]


================================================
FILE: apps/extension/content-scripts/messager.js
================================================
[Empty file]


================================================
FILE: apps/extension/content-scripts/metrics.js
================================================
// apps/extension/content-scripts/metrics.js
// H√†m d√πng ƒë·ªÉ ƒëo l∆∞·ªùng hi·ªáu su·∫•t API call t·ª´ Extension

export const measureApiCall = async (apiName, apiCallFn) => {
  const t1_start = performance.now(); // üïí B·∫Øt ƒë·∫ßu T1

  try {
    const response = await apiCallFn();

    const t1_end = performance.now(); // üèÅ K·∫øt th√∫c T1
    const t1_total_ms = (t1_end - t1_start).toFixed(2);

    // L·∫•y T2 t·ª´ Header m√† Backend g·ª≠i v·ªÅ
    const t2_server_ms = parseFloat(
      response.headers?.get?.("x-server-time") || "0"
    );

    // T√≠nh ƒë·ªô tr·ªÖ m·∫°ng (Network Latency)
    const network_latency = (parseFloat(t1_total_ms) - t2_server_ms).toFixed(2);

    console.group(`üìä METRICS: ${apiName}`);
    console.log(`1Ô∏è‚É£ T·ªïng th·ªùi gian (T1): ${t1_total_ms} ms`);
    console.log(`2Ô∏è‚É£ Server x·ª≠ l√Ω (T2):   ${t2_server_ms} ms`);
    console.log(`3Ô∏è‚É£ ƒê·ªô tr·ªÖ m·∫°ng (Net):   ${network_latency} ms`);

    // K·∫æT LU·∫¨N T·ª∞ ƒê·ªòNG
    if (parseFloat(network_latency) > 1000) {
      console.warn("üëâ CH·∫¨M DO M·∫†NG (Internet/Wifi)");
    } else if (t2_server_ms > 500) {
      console.warn("üëâ CH·∫¨M DO BACKEND (Code/DB)");
    } else {
      console.log("‚úÖ T·ªëc ƒë·ªô ·ªïn ƒë·ªãnh");
    }
    console.groupEnd();

    return response;
  } catch (error) {
    console.error(`‚ùå API Error: ${apiName}`, error);
    throw error;
  }
};



================================================
FILE: apps/extension/content-scripts/native-core.js
================================================
console.log("‚úÖ Native Core Loaded - Smart Ranking Mode");

window.NativeCore = (function () {
  let debounceTimer = null;
  let latestQuery = "";
  let currentMode = "EN";

  let lastDbResults = [];

  const VIETNAMESE_REGEX =
    /[√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë]/i;

  // --- HELPER: T√çNH ƒêI·ªÇM ∆ØU TI√äN (Ranking) ---
  function sortResultsByRelevance(items, keyword, mode) {
    if (!keyword || items.length === 0) return items;
    const searchStr = keyword.toLowerCase().trim();

    return items.sort((a, b) => {
      const scoreA = calculateScore(a, searchStr, mode);
      const scoreB = calculateScore(b, searchStr, mode);
      return scoreB - scoreA; // ƒêi·ªÉm cao x·∫øp tr√™n
    });
  }

  function calculateScore(item, keyword, mode) {
    let score = 0;
    // 1. ∆Øu ti√™n kh·ªõp ch√≠nh x√°c t·ª´ g·ªëc (Word)
    if (item.word.toLowerCase() === keyword) return 1000;

    // 2. Logic so s√°nh Meaning (Cho Mode VI)
    if (mode === "VI" && item.meaning) {
      const meaningLower = item.meaning.toLowerCase();

      // T√°ch nghƒ©a b·∫±ng d·∫•u ph·∫©y, ch·∫•m ph·∫©y (Vd: "t√°o, qu·∫£ t√°o; t√°o t√¢y")
      const parts = meaningLower.split(/[,;]+/).map((p) => p.trim());

      // Case A: Kh·ªõp ch√≠nh x√°c 1 segment (Vd: search "t√°o" kh·ªõp segment "t√°o") -> ∆Øu ti√™n cao nh·∫•t
      if (parts.includes(keyword)) {
        score += 500;
      }
      // Case B: B·∫Øt ƒë·∫ßu b·∫±ng t·ª´ kh√≥a (Vd: "t√°o qu√¢n") -> ∆Øu ti√™n nh√¨
      else if (parts.some((p) => p.startsWith(keyword + " "))) {
        score += 100;
      }
      // Case C: Ch·ªâ ch·ª©a t·ª´ kh√≥a (Vd: "c·∫•u t·∫°o") -> ∆Øu ti√™n th·∫•p
      else if (meaningLower.includes(keyword)) {
        score += 10;
      }
    }
    // 3. Logic cho Mode EN (Word match)
    else if (mode === "EN") {
      if (item.word.toLowerCase().startsWith(keyword)) score += 100;
      else if (item.word.toLowerCase().includes(keyword)) score += 10;
    }

    // Bonus: ƒêi·ªÉm tr·ª´ nh·∫π n·∫øu t·ª´ qu√° d√†i (ƒë·ªÉ ∆∞u ti√™n t·ª´ ng·∫Øn g·ªçn h∆°n)
    score -= item.word.length * 0.1;

    return score;
  }

  // --- 1. LOGIC AUTO-FILL (Gi·ªØ nguy√™n) ---
  async function fetchAutoFillData(word) {
    if (!word) return null;
    try {
      const dictPromise = fetch(
        `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
          word
        )}`
      )
        .then((r) => (r.ok ? r.json() : null))
        .catch(() => null);
      const translatePromise = getTranslation(word);
      const [dictRes, transRes] = await Promise.all([
        dictPromise,
        translatePromise,
      ]);

      let newData = {};
      if (dictRes && dictRes[0]) {
        const entry = dictRes[0];
        if (entry.phonetic) newData.pronunciation = entry.phonetic;
        else if (entry.phonetics && entry.phonetics.length > 0) {
          const p = entry.phonetics.find((x) => x.text && x.audio);
          newData.pronunciation = p ? p.text : entry.phonetics[0]?.text || "";
        }
        if (entry.meanings && entry.meanings.length > 0) {
          const m = entry.meanings[0];
          newData.partOfSpeech = m.partOfSpeech;
          if (m.definitions) {
            const def = m.definitions.find((d) => d.example);
            if (def) newData.example = def.example;
          }
        }
      }
      if (transRes) {
        const mean =
          typeof transRes === "string" ? transRes : transRes.wordMeaning;
        if (mean) newData.meaning = mean;
      }
      return newData;
    } catch (e) {
      console.error("Autofill error:", e);
      return null;
    }
  }

  // --- 2. HANDLE SAVE ---
  async function handleSaveVocab(data) {
    try {
      if (data.id) {
        await apiUpdateVocabulary(data.id, data);
        console.log("‚úÖ Updated successfully");
      } else {
        await apiCreateFullVocabulary(data);
        console.log("‚úÖ Created successfully");
      }
      // Reload search, √©p ki·ªÉu EN ƒë·ªÉ t√¨m ch√≠nh x√°c t·ª´ v·ª´a t·∫°o
      runSearch(data.word, "EN");
    } catch (e) {
      alert("Save failed: " + e.message + "\n(Check Login or Network)");
    }
  }

  // --- 3. ASSESSMENT HANDLER ---
  function onOpenAssessment(vocab) {
    const vocabItem = vocab.id
      ? vocab
      : {
          id: "temp",
          word: vocab.word,
          pronunciation: vocab.pronunciation || "",
        };

    window.NativeUI.renderAssessmentModal(vocabItem, {
      onSpeak: (text) => speakWithEdgeTTS(text),
      onRecord: async (onSuccess, onError) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          const mediaRecorder = new MediaRecorder(stream);
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: "audio/webm" });
            window.lastRecordedBlob = blob;
            try {
              const result = await assessPronunciation(blob, vocabItem.word);
              if (vocabItem.id !== "temp" && result.NBest && result.NBest[0]) {
                const score = result.NBest[0].AccuracyScore;
                await apiAddScore(vocabItem.id, score);
              }
              if (result.NBest) onSuccess(result.NBest[0]);
              else onError("No result");
            } catch (err) {
              onError(err.message);
            }
            stream.getTracks().forEach((t) => t.stop());
          };
          mediaRecorder.start();
          window.currentRecorder = mediaRecorder;
        } catch (e) {
          onError("Mic Error: " + e.message);
        }
      },
      onStop: () => {
        if (window.currentRecorder) window.currentRecorder.stop();
      },
      onPlayback: () => {
        if (window.lastRecordedBlob) {
          const url = URL.createObjectURL(window.lastRecordedBlob);
          new Audio(url).play();
        }
      },
    });
  }

  // --- 4. FORM OPEN HANDLERS ---
  async function onOpenCreate(englishWord, meaningSuggestion = "") {
    let initialData = {
      word: englishWord || "",
      meaning: meaningSuggestion,
      isEditMode: false,
    };

    if (englishWord) {
      const autoData = await fetchAutoFillData(englishWord);
      if (autoData) {
        initialData = { ...initialData, ...autoData };
        if (meaningSuggestion) initialData.meaning = meaningSuggestion;
      }
    }
    window.NativeUI.renderFormModal(initialData, {
      onAutoFill: fetchAutoFillData,
      onSave: handleSaveVocab,
    });
  }

  async function onEdit(item) {
    window.NativeUI.renderFormModal(
      {
        ...item,
        isEditMode: true,
      },
      {
        onAutoFill: fetchAutoFillData,
        onSave: handleSaveVocab,
      }
    );
  }

  // --- 5. INPUT & HANDLERS ---
  function handleInput(text) {
    latestQuery = text;
    const detectedMode = VIETNAMESE_REGEX.test(text) ? "VI" : "EN";
    currentMode = detectedMode;

    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      runSearch(text.trim());
    }, 400);
  }

  async function handleEnter(text) {
    const rawInput = text.trim();
    if (!rawInput) return;
    if (debounceTimer) clearTimeout(debounceTimer);

    const exactMatch = lastDbResults.find(
      (i) => i.word.toLowerCase() === rawInput.toLowerCase()
    );
    if (exactMatch) {
      onEdit(exactMatch);
      return;
    }

    // Logic x·ª≠ l√Ω Enter nhanh (khi ch∆∞a render)
    // T·ª± ƒë·ªông detect v√† x·ª≠ l√Ω y nh∆∞ runSearch nh∆∞ng b·ªè qua b∆∞·ªõc render list
    const isVietnamese = VIETNAMESE_REGEX.test(rawInput);
    if (isVietnamese) {
      const englishWord = await translateViToEn(rawInput);
      if (englishWord) {
        const existing = await apiCheckVocabulary(englishWord);
        if (existing) onEdit(existing);
        else onOpenCreate(englishWord, rawInput);
      } else {
        onOpenCreate(rawInput, "");
      }
    } else {
      const existing = await apiCheckVocabulary(rawInput);
      if (existing) onEdit(existing);
      else onOpenCreate(rawInput, "");
    }
  }

  // üëá [UPDATED] RUN SEARCH V·ªöI LOGIC RANKING M·ªöI
  async function runSearch(rawInput, forceMode = null) {
    const runMode = forceMode || currentMode;
    const currentRunQuery = rawInput;

    try {
      let searchKeyword = rawInput; // T·ª´ d√πng ƒë·ªÉ Search DB
      let displayKeyword = rawInput; // T·ª´ d√πng ƒë·ªÉ hi·ªÉn th·ªã ƒë·ªÅ xu·∫•t Create
      let impliedMeaning = "";
      let translatedEnglish = "";

      // === B∆Ø·ªöC 1: X·ª¨ L√ù VIETNAMESE ===
      if (runMode === "VI" && rawInput.trim()) {
        // A. D·ªãch sang Anh ƒë·ªÉ l·∫•y t·ª´ chu·∫©n cho "Create New"
        translatedEnglish = await translateViToEn(rawInput);

        // B. NH∆ØNG Search DB th√¨ d√πng Ti·∫øng Vi·ªát (rawInput)
        // L√Ω do: ƒê·ªÉ t√¨m ra nh·ªØng t·ª´ c√≥ nghƒ©a ch·ª©a "t·∫°o" (create, make, generate...)
        searchKeyword = rawInput;

        if (translatedEnglish) {
          displayKeyword = translatedEnglish.toLowerCase().trim();
          impliedMeaning = rawInput;
        }
      }

      // === B∆Ø·ªöC 2: SEARCH DATABASE ===
      // L∆∞u √Ω: searchKeyword ·ªü ƒë√¢y l√† VI (n·∫øu mode VI) ho·∫∑c EN (n·∫øu mode EN)
      // Backend API search c·∫£ c·ªôt word v√† meaning n√™n t√¨m ki·ªÉu g√¨ c≈©ng ra.
      let dbResults = await apiSearchVocabulary(searchKeyword);

      if (latestQuery.trim() !== currentRunQuery) return;

      // === B∆Ø·ªöC 3: SMART FALLBACK (Cho ca kh√≥ kh√¥ng d·∫•u) ===
      // ... (Logic fallback c≈© n·∫øu c·∫ßn, ·ªü ƒë√¢y ta t·∫≠p trung v√†o Ranking) ...

      // === B∆Ø·ªöC 4: S·∫ÆP X·∫æP K·∫æT QU·∫¢ (RANKING) ===
      // S·∫Øp x·∫øp l·∫°i dbResults d·ª±a tr√™n ƒë·ªô kh·ªõp v·ªõi rawInput
      dbResults = sortResultsByRelevance(dbResults, rawInput, runMode);
      lastDbResults = dbResults; // L∆∞u l·∫°i cho handleEnter

      // === B∆Ø·ªöC 5: CHU·∫®N B·ªä DATA CHO CREATE NEW ===
      let apiData = null;

      // Ki·ªÉm tra xem t·ª´ Ti·∫øng Anh (sau khi d·ªãch) ƒë√£ c√≥ trong DB ch∆∞a?
      // (Ch·ªâ √°p d·ª•ng cho Mode VI ƒë·ªÉ tr√°nh t·∫°o tr√πng)
      let exactMatchInDb = null;
      if (runMode === "VI" && translatedEnglish) {
        // T√¨m trong list k·∫øt qu·∫£ xem c√≥ √¥ng n√†o word == translatedEnglish kh√¥ng
        exactMatchInDb = dbResults.find(
          (i) => i.word.toLowerCase() === translatedEnglish.toLowerCase()
        );
      } else {
        exactMatchInDb = dbResults.find(
          (i) => i.word.toLowerCase() === displayKeyword.toLowerCase()
        );
      }

      // N·∫øu ch∆∞a c√≥, chu·∫©n b·ªã data ƒë·ªÉ g·ª£i √Ω t·∫°o m·ªõi
      if (!exactMatchInDb && displayKeyword) {
        const phonetics = await getPhoneticForText(displayKeyword);
        let trans = null;

        if (runMode === "EN") {
          trans = await getTranslation(displayKeyword);
        } else {
          // Mode VI
          const googleData = await getTranslation(displayKeyword);
          trans = { wordMeaning: impliedMeaning, dict: googleData?.dict || [] };
        }

        if (latestQuery.trim() !== currentRunQuery) return;
        if (trans) apiData = { trans, phonetics };
      }

      // === B∆Ø·ªöC 6: RENDER ===
      // L∆∞u √Ω: displayKeyword l√† t·ª´ Ti·∫øng Anh (ƒë·ªÉ hi·ªán ·ªü d√≤ng Create New)
      window.NativeUI.renderSearchModal(displayKeyword, dbResults, apiData, {
        onInput: handleInput,
        onEnter: handleEnter,
        onSpeak: (t) => speakWithEdgeTTS(t),
        onOpenCreate: (word) =>
          onOpenCreate(word, runMode === "VI" ? impliedMeaning : ""),
        onEdit: onEdit,
        onMic: onOpenAssessment,
        onMicPractice: (keyword) =>
          onOpenAssessment({
            word: keyword,
            id: null,
            pronunciation: apiData?.phonetics?.us || "",
          }),

        // üëá TH√äM H√ÄM N√ÄY XU·ªêNG UI
        onInteract: handleInteraction,

        onMark: (item) => {
          /*...*/
        },
        mode: runMode,
        rawInput: rawInput,
      });
    } catch (e) {
      console.error("Search error:", e);
    }
  }

  // üëá [NEW] H√ÄM C·∫¨P NH·∫¨T COUNT & TIME (INTERACTION)
  async function handleInteraction(item) {
    if (!item || !item.id) return;

    // T√≠nh to√°n count m·ªõi (tƒÉng 1)
    const newCount = (item.occurrence || 0) + 1;

    // Update local cache ngay l·∫≠p t·ª©c ƒë·ªÉ UI ph·∫£n h·ªìi (n·∫øu c·∫ßn)
    item.occurrence = newCount;

    try {
      // G·ªçi API PATCH tr·ª±c ti·∫øp ƒë·ªÉ update count
      // (Backend Prisma s·∫Ω t·ª± ƒë·ªông update c·ªôt 'updatedAt' th√†nh gi·ªù hi·ªán t·∫°i)
      await fetch(`https://localhost:5001/vocabulary/${item.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ occurrence: newCount }),
        credentials: "include",
      });
      // console.log(`Interact: ${item.word} -> ${newCount}`);
    } catch (e) {
      console.error("Interaction update failed", e);
    }
  }

  // ... (Ph·∫ßn c√≤n l·∫°i: toggle, handleSelection, Event Listeners gi·ªØ nguy√™n) ...
  function toggle() {
    latestQuery = "";
    currentMode = "EN";
    lastDbResults = [];
    window.NativeUI.renderSearchModal("", [], null, {
      onInput: handleInput,
      onEnter: handleEnter,
      mode: "EN",
      rawInput: "",
    });
  }

  async function handleSelection() {
    const sel = window.getSelection().toString().trim();
    if (!sel) return;
    const rect = window.getSelection().getRangeAt(0).getBoundingClientRect();
    speakWithEdgeTTS(sel);
    const [trans, phonetics] = await Promise.all([
      getTranslation(sel),
      getPhoneticForText(sel),
    ]);
    if (trans) {
      window.NativeUI.renderPopup({ text: sel, trans, phonetics }, rect, {
        onSpeak: (t) => speakWithEdgeTTS(t),
        onOpenCreate: (w) => onOpenCreate(w),
      });
    }
  }

  return {
    toggle,
    handleSelection,
    handleEnter,
    handleInteraction,
    // üëá EXPOSE H√ÄM N√ÄY ƒê·ªÇ FLASHCARD G·ªåI
    openEdit: onEdit,
    // üëá EXPOSE H√ÄM N√ÄY ƒê·ªÇ FLASHCARD G·ªåI MIC
    openAssessment: onOpenAssessment,
  };
})();

// Global Listeners
window.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.code === "KeyQ") {
    e.preventDefault();
    window.NativeCore.toggle();
  }
});
window.addEventListener("keyup", (e) => {
  if (e.key === "Escape") {
    window.NativeUI.hideAll();
  }
});



================================================
FILE: apps/extension/content-scripts/native-ui.js
================================================
console.log("‚úÖ Native UI Loaded");

window.NativeUI = (function () {
  let root = null;
  let searchWrapper = null;
  let searchModal = null; // üëá Bi·∫øn tham chi·∫øu t·ªõi Modal
  let formWrapper = null;
  let miniPopup = null;
  let assessWrapper = null; // New wrapper for assessment modal

  // üëá [UPDATED] B·ªò ICON CHU·∫®N ƒê·∫∏P (L·∫•y t·ª´ Shift Popup)
  const ICONS = {
    search:
      '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>',
    mic: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>',
    sound:
      '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>',
    mark: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>',
    close:
      '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
  };

  // --- 1. H√ÄM X·ª¨ L√ù K√âO TH·∫¢ & L∆ØU V·ªä TR√ç ---
  function enableDragAndPersist(headerEl, modalEl) {
    let isDragging = false;
    let startX, startY, initialLeft, initialTop;

    // A. Kh√¥i ph·ª•c v·ªã tr√≠ c≈© (n·∫øu c√≥)
    const savedPos = localStorage.getItem("vocab_widget_pos");
    if (savedPos) {
      const { top, left } = JSON.parse(savedPos);
      // Ki·ªÉm tra xem v·ªã tr√≠ c√≥ b·ªã tr√¥i ra kh·ªèi m√†n h√¨nh kh√¥ng
      const safeTop = Math.min(Math.max(0, top), window.innerHeight - 50);
      const safeLeft = Math.min(Math.max(0, left), window.innerWidth - 50);

      modalEl.style.top = safeTop + "px";
      modalEl.style.left = safeLeft + "px";
      modalEl.style.transform = "none"; // B·ªè cƒÉn gi·ªØa m·∫∑c ƒë·ªãnh
    }

    // B. B·∫Øt ƒë·∫ßu k√©o
    headerEl.onmousedown = (e) => {
      // Ch·ªâ k√©o khi click v√†o v√πng tr·ªëng c·ªßa header (tr√°nh input)
      if (e.target.tagName === "INPUT" || e.target.tagName === "BUTTON") return;

      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;

      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i (t√≠nh c·∫£ khi ƒëang d√πng transform)
      const rect = modalEl.getBoundingClientRect();
      initialLeft = rect.left;
      initialTop = rect.top;

      // X√≥a transform ƒë·ªÉ chuy·ªÉn sang d√πng top/left tuy·ªát ƒë·ªëi m∆∞·ª£t m√†
      modalEl.style.transform = "none";
      modalEl.style.left = initialLeft + "px";
      modalEl.style.top = initialTop + "px";
      modalEl.style.width = rect.width + "px"; // C·ªë ƒë·ªãnh chi·ªÅu r·ªông ƒë·ªÉ kh√¥ng b·ªã co gi√£n
    };

    // C. ƒêang k√©o
    const onMouseMove = (e) => {
      if (!isDragging) return;
      e.preventDefault(); // Ch·∫∑n b√¥i ƒëen text

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      modalEl.style.left = `${initialLeft + dx}px`;
      modalEl.style.top = `${initialTop + dy}px`;
    };

    // D. Th·∫£ chu·ªôt (L∆∞u v·ªã tr√≠)
    const onMouseUp = () => {
      if (!isDragging) return;
      isDragging = false;

      // L∆∞u v√†o LocalStorage
      const pos = {
        top: parseInt(modalEl.style.top || 0),
        left: parseInt(modalEl.style.left || 0),
      };
      localStorage.setItem("vocab_widget_pos", JSON.stringify(pos));
    };

    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  }

  function init() {
    if (document.getElementById("vocab-root")) return;
    root = document.createElement("div");
    root.id = "vocab-root";
    document.body.appendChild(root);

    // 1. Search Wrapper
    searchWrapper = document.createElement("div");
    searchWrapper.id = "vocab-search-wrapper";
    searchWrapper.innerHTML = `
        <div id="vocab-search-modal">
            <div class="vocab-header" id="vocab-drag-handle">
                <div class="vocab-input-affix">
                    <span style="font-size:20px">${ICONS.search}</span>
                    <input class="vocab-search-input" id="native-search-input" placeholder="Type to search or create..." autocomplete="off">
                </div>
            </div>
            <div id="vocab-modal-body" class="vocab-body"></div>
            <div id="vocab-modal-assessment"></div>
        </div>
    `;
    root.appendChild(searchWrapper);

    // üëá KH·ªûI T·∫†O DRAG
    searchModal = document.getElementById("vocab-search-modal");
    const dragHandle = document.getElementById("vocab-drag-handle");
    enableDragAndPersist(dragHandle, searchModal);

    // 2. Full Form Modal Wrapper
    formWrapper = document.createElement("div");
    formWrapper.className = "vocab-modal-overlay";
    formWrapper.style.display = "none";
    root.appendChild(formWrapper);

    // 3. Mini Popup
    miniPopup = document.createElement("div");
    miniPopup.id = "vocab-mini-popup";
    root.appendChild(miniPopup);

    // 4. Assessment Modal Wrapper
    if (!document.getElementById("vocab-assess-wrapper")) {
      assessWrapper = document.createElement("div");
      assessWrapper.id = "vocab-assess-wrapper";
      assessWrapper.className = "assess-modal-overlay";
      assessWrapper.style.display = "none";
      root.appendChild(assessWrapper);

      assessWrapper.onclick = (e) => {
        if (e.target === assessWrapper) assessWrapper.style.display = "none";
      };
    } else {
      assessWrapper = document.getElementById("vocab-assess-wrapper");
    }

    // Close events
    searchWrapper.onclick = (e) => {
      if (e.target === searchWrapper) hideAll();
    };
    // üëá [FIX 1]: X√ìA ho·∫∑c COMMENT d√≤ng n√†y ƒë·ªÉ ch·∫∑n click ra ngo√†i b·ªã t·∫Øt
    // formWrapper.onclick = (e) => {
    //   if (e.target === formWrapper) formWrapper.style.display = "none";
    // };
    searchWrapper.addEventListener("keydown", (e) => e.stopPropagation());
  }

  function hideAll() {
    if (searchWrapper) searchWrapper.style.display = "none";
    if (formWrapper) formWrapper.style.display = "none";
    if (miniPopup) miniPopup.style.display = "none";
    if (assessWrapper) assessWrapper.style.display = "none";
    window.speechSynthesis.cancel();
  }

  function renderFormModal(data, handlers) {
    init();
    formWrapper.style.display = "flex";
    searchWrapper.style.display = "none";
    miniPopup.style.display = "none";

    const isEdit = data.isEditMode;

    formWrapper.innerHTML = `
        <div class="vocab-modal-content">
            <div class="vocab-modal-header">
                <div style="width:100%">
                    <div class="vocab-modal-title">${
                      isEdit ? "Editing Vocabulary" : "Create New Vocabulary"
                    }</div>
                    <div style="position:relative">
                        <textarea 
                            id="form-word" 
                            class="vocab-input-large" 
                            placeholder="Word..." 
                            rows="1"
                            ${isEdit ? "readonly" : ""}
                        >${data.word || ""}</textarea>
                        <div id="form-autofill-status" class="autofill-loading" style="display:none">‚ú® Auto-filling...</div>
                    </div>
                </div>
                <button id="form-close" style="background:none; border:none; color:white; cursor:pointer;">${
                  ICONS.close
                }</button>
            </div>
            <div class="vocab-modal-body">
                <div class="vocab-grid-2">
                    <div>
                        <label class="vocab-label">Pronunciation</label>
                        <input id="form-pronun" class="vocab-input-field" value="${
                          data.pronunciation || ""
                        }" placeholder="/.../">
                    </div>
                    <div>
                        <label class="vocab-label">Part Of Speech</label>
                        <select id="form-pos" class="vocab-select-field">
                            <option value="">-- Select --</option>
                            <option value="noun" ${
                              data.partOfSpeech === "noun" ? "selected" : ""
                            }>Noun</option>
                            <option value="verb" ${
                              data.partOfSpeech === "verb" ? "selected" : ""
                            }>Verb</option>
                            <option value="adjective" ${
                              data.partOfSpeech === "adjective"
                                ? "selected"
                                : ""
                            }>Adjective</option>
                            <option value="adverb" ${
                              data.partOfSpeech === "adverb" ? "selected" : ""
                            }>Adverb</option>
                            <option value="phrase" ${
                              data.partOfSpeech === "phrase" ? "selected" : ""
                            }>Phrase</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label class="vocab-label">Meaning</label>
                    <textarea id="form-meaning" class="vocab-textarea-field" placeholder="Nghƒ©a c·ªßa t·ª´...">${
                      data.meaning || ""
                    }</textarea>
                </div>
                <div>
                    <label class="vocab-label">Example</label>
                    <textarea id="form-example" class="vocab-textarea-field" style="background:#f9fafb; font-style:italic;" placeholder="V√≠ d·ª•...">${
                      data.example || ""
                    }</textarea>
                </div>
                <div class="vocab-grid-2">
                    <div>
                        <label class="vocab-label">Topic</label>
                        <input id="form-topic" class="vocab-input-field" value="${
                          data.topic || ""
                        }" placeholder="IT, Travel...">
                    </div>
                    <div>
                        <label class="vocab-label">Related Words</label>
                        <input id="form-related" class="vocab-input-field" value="${
                          data.relatedWords || ""
                        }" placeholder="Synonyms...">
                    </div>
                </div>
            </div>
            <div class="vocab-modal-footer">
                <button id="form-cancel" class="btn-cancel">Cancel</button>
                <button id="form-save" class="btn-save">${
                  isEdit ? "Save Changes" : "Create Word"
                }</button>
            </div>
        </div>
    `;

    const wordInput = document.getElementById("form-word");
    const statusDiv = document.getElementById("form-autofill-status");

    // üëá [FIX 3]: Logic t·ª± ƒë·ªông gi√£n chi·ªÅu cao (Auto-resize) cho Word Input
    const adjustHeight = () => {
      wordInput.style.height = "auto";
      wordInput.style.height = wordInput.scrollHeight + "px";
    };
    wordInput.addEventListener("input", adjustHeight);
    // G·ªçi 1 l·∫ßn l√∫c init ƒë·ªÉ n√≥ kh·ªõp v·ªõi n·ªôi dung ban ƒë·∫ßu
    setTimeout(adjustHeight, 0);

    if (!isEdit) {
      wordInput.onblur = async () => {
        const val = wordInput.value.trim();
        if (val && handlers.onAutoFill) {
          statusDiv.style.display = "inline-block";
          const autoData = await handlers.onAutoFill(val);
          statusDiv.style.display = "none";
          if (autoData) {
            if (autoData.pronunciation)
              document.getElementById("form-pronun").value =
                autoData.pronunciation;
            if (autoData.partOfSpeech)
              document.getElementById("form-pos").value = autoData.partOfSpeech;
            if (autoData.meaning)
              document.getElementById("form-meaning").value = autoData.meaning;
            if (autoData.example)
              document.getElementById("form-example").value = autoData.example;
          }
        }
      };
      if (data.word) wordInput.onblur();
    }

    document.getElementById("form-close").onclick = () => {
      formWrapper.style.display = "none";
    };
    document.getElementById("form-cancel").onclick = () => {
      formWrapper.style.display = "none";
    };

    document.getElementById("form-save").onclick = () => {
      const newData = {
        id: data.id,
        word: document.getElementById("form-word").value.trim(),
        pronunciation: document.getElementById("form-pronun").value.trim(),
        partOfSpeech: document.getElementById("form-pos").value,
        meaning: document.getElementById("form-meaning").value.trim(),
        example: document.getElementById("form-example").value.trim(),
        topic: document.getElementById("form-topic").value.trim(),
        relatedWords: document.getElementById("form-related").value.trim(),
      };
      handlers.onSave(newData);
      formWrapper.style.display = "none";
    };

    if (!isEdit) setTimeout(() => wordInput.focus(), 100);
  }

  // ... (C√°c ph·∫ßn tr√™n gi·ªØ nguy√™n) ...

  // --- [UPDATED] RENDER SEARCH MODAL ---
  function renderSearchModal(keyword, dbResults, apiData, handlers) {
    init();
    searchWrapper.style.display = "block";

    const input = document.getElementById("native-search-input");
    const body = document.getElementById("vocab-modal-body");
    const mode = handlers.mode || "EN";
    const userTyped = handlers.rawInput || "";

    // 1. C·∫¨P NH·∫¨T UI THEO MODE (Placeholder & Icon)
    const placeholder =
      mode === "VI"
        ? "Nh·∫≠p ti·∫øng Vi·ªát ƒë·ªÉ d·ªãch & tra c·ª©u..."
        : "Type English to search or create...";
    input.setAttribute("placeholder", placeholder);

    // Th√™m visual indicator cho mode (N·∫øu mu·ªën)
    // V√≠ d·ª• ƒë·ªïi m√†u icon k√≠nh l√∫p: Xanh (EN) - ƒê·ªè (VI)
    const iconSpan = document.querySelector(".vocab-input-affix span");
    if (iconSpan) {
      iconSpan.innerHTML =
        mode === "VI"
          ? '<span style="font-size:14px; font-weight:800; color:#e53935;">VI</span>'
          : ICONS.search;
    }

    // 2. LOGIC INPUT VALUE
    // N·∫øu l√† active element (ƒëang g√µ) -> Kh√¥ng ƒë·ª•ng v√†o value
    // N·∫øu m·ªõi m·ªü (userTyped r·ªóng) -> Reset
    if (document.activeElement !== input) {
      input.value = userTyped;
      input.focus();
    }

    // Logic bind event input (nh∆∞ c≈©)
    if (!input.dataset.hasEvent) {
      input.oninput = (e) => handlers.onInput(e.target.value);
      input.addEventListener("keydown", (e) => {
        e.stopPropagation(); // Ch·∫∑n Notion c∆∞·ªõp ph√≠m
        if (e.key === "Enter") {
          handlers.onEnter(input.value);
        }
      });
      // Ch·∫∑n s·ª± ki·ªán lan ra ngo√†i ƒë·ªÉ copy/paste ngon l√†nh
      ["paste", "copy", "cut", "selectstart"].forEach((evt) => {
        input.addEventListener(evt, (e) => e.stopPropagation());
      });
      input.dataset.hasEvent = "true";
    }

    let html = "";

    // üëá CREATE NEW ITEM
    // L∆∞u √Ω: 'keyword' ·ªü ƒë√¢y l√† t·ª´ Ti·∫øng Anh (ƒë√£ d·ªãch t·ª´ VI ho·∫∑c nguy√™n g·ªëc EN)
    const exactMatch = dbResults.find(
      (w) => w.word.toLowerCase() === (keyword || "").toLowerCase()
    );

    if (keyword && !exactMatch) {
      const trans = apiData?.trans || {};

      // X√°c ƒë·ªãnh nghƒ©a hi·ªÉn th·ªã:
      // - N·∫øu Mode VI: Hi·ªÉn th·ªã input g·ªëc ("xin ch√†o")
      // - N·∫øu Mode EN: Hi·ªÉn th·ªã k·∫øt qu·∫£ d·ªãch ("Translating...")
      const displayMeaning =
        handlers.mode === "VI"
          ? handlers.rawInput
          : trans.wordMeaning || "Translating...";

      const pronun = apiData?.phonetics?.us || "";

      // T·∫°o ti√™u ƒë·ªÅ ph·ª• d·ª±a tr√™n mode
      const subTitle =
        handlers.mode === "VI"
          ? `English match: "${keyword}"` // Cho ng∆∞·ªùi d√πng bi·∫øt t·ª´ ti·∫øng Anh t∆∞∆°ng ·ª©ng
          : "New Word";

      html += `
        <div class="vocab-list-item vocab-create-item" id="open-create-form">
            <div class="vocab-list-left">
                <div class="vocab-word-row">
                    <span class="vocab-word-text">${keyword}</span> <span class="vocab-tag tag-green">${subTitle}</span>
                    <span class="vocab-pronun">${pronun}</span>
                </div>
                <div class="vocab-word-meta">${displayMeaning}</div>
                <div style="font-size:11px; color:#1890ff; margin-top:2px;">
                    Press Enter to save to database
                </div>
            </div>
            
            <div class="vocab-actions" style="opacity: 1; transform: none;">
                <button id="add-listen" class="action-btn-circle btn-sound" title="Listen">
                    ${ICONS.sound}
                </button>
                <button id="add-mic" class="action-btn-circle btn-mic" title="Practice">
                    ${ICONS.mic}
                </button>
            </div>
        </div>
        <div style="height:1px; background:#f0f0f0; margin: 0 20px;"></div>
      `;
    }

    // üëá 2. RESULTS LIST
    if (dbResults.length > 0) {
      dbResults.forEach((item, idx) => {
        html += `
            <div class="vocab-list-item" id="vocab-item-${idx}">
                <div class="vocab-list-left">
                    <div class="vocab-word-row">
                        <span class="vocab-word-text">${item.word}</span>
                        ${
                          item.partOfSpeech
                            ? `<span class="vocab-tag">${item.partOfSpeech}</span>`
                            : ""
                        }
                        ${
                          item.topic
                            ? `<span class="vocab-tag tag-blue">${item.topic}</span>`
                            : ""
                        }
                        <span style="font-size:10px; color:#ccc; margin-left:5px;">(${
                          item.occurrence || 0
                        })</span>
                    </div>
                    <div class="vocab-word-meta">${item.meaning || ""}</div>
                </div>
                <div class="vocab-actions">
                    <button class="action-btn-circle btn-listen" title="Listen">
                        ${ICONS.sound}
                    </button>
                    <button class="action-btn-circle btn-mic" title="Practice">
                        ${ICONS.mic}
                    </button>
                </div>
            </div>`;
      });
    } else if (!keyword) {
      html += `<div style="text-align:center; padding:40px; color:#999; font-size:14px;">Type any word to search or create...</div>`;
    }

    body.innerHTML = html;

    // --- RE-BIND EVENTS (FIX L·ªñI CLICK) ---
    // S·ª≠ d·ª•ng stopPropagation ƒë·ªÉ kh√¥ng b·ªã k√≠ch ho·∫°t click v√†o row cha

    // 1. Bind cho Create New Box
    if (keyword && !exactMatch) {
      const btnListen = document.getElementById("add-listen");
      if (btnListen) {
        btnListen.onclick = (e) => {
          e.stopPropagation(); // Ch·∫∑n lan ra ngo√†i
          handlers.onSpeak(keyword);
        };
      }

      const btnMic = document.getElementById("add-mic");
      if (btnMic) {
        btnMic.onclick = (e) => {
          e.stopPropagation(); // Ch·∫∑n lan ra ngo√†i
          if (handlers.onMicPractice) handlers.onMicPractice(keyword);
        };
      }

      const createBox = document.getElementById("open-create-form");
      if (createBox) {
        createBox.onclick = () => handlers.onOpenCreate(keyword);
      }
    }

    // 2. Bind cho List Results
    dbResults.forEach((item, idx) => {
      const itemEl = document.getElementById(`vocab-item-${idx}`);
      if (!itemEl) return;

      // üëá S·ª∞ KI·ªÜN CLICK V√ÄO D√íNG (ROW CLICK)
      itemEl.onclick = (e) => {
        // N·∫øu click v√†o n√∫t con (loa/mic) th√¨ b·ªè qua, ƒë·ªÉ s·ª± ki·ªán n√∫t con x·ª≠ l√Ω
        if (e.target.closest("button")) return;

        // 1. TƒÉng count & Update time
        if (handlers.onInteract) handlers.onInteract(item);

        // 2. M·ªü Popup ch·ªânh s·ª≠a (Edit Mode)
        handlers.onEdit(item);
      };

      // üëá N√öT LOA
      const btnListen = itemEl.querySelector(".btn-listen");
      if (btnListen)
        btnListen.onclick = (e) => {
          e.stopPropagation();
          if (handlers.onInteract) handlers.onInteract(item); // TƒÉng count
          handlers.onSpeak(item.word);
        };

      // üëá N√öT MIC
      const btnMic = itemEl.querySelector(".btn-mic");
      if (btnMic)
        btnMic.onclick = (e) => {
          e.stopPropagation();
          if (handlers.onInteract) handlers.onInteract(item); // TƒÉng count
          if (handlers.onMic) handlers.onMic(item);
        };
    });
  }

  // ... (C√°c h√†m kh√°c gi·ªØ nguy√™n) ...

  function renderPopup(data, rect, handlers) {
    init();
    miniPopup.style.display = "block";
    searchWrapper.style.display = "none";
    let top = rect.bottom + 10;
    let left = rect.left;
    if (top + 200 > window.innerHeight) top = rect.top - 200;
    miniPopup.style.top = top + "px";
    miniPopup.style.left = left + "px";
    const trans = data.trans;
    const meaning = typeof trans === "string" ? trans : trans.wordMeaning;
    miniPopup.innerHTML = `
        <div style="padding:16px;">
            <div style="font-weight:700; font-size:18px; color:#1890ff; margin-bottom:4px;">${
              data.text
            }</div>
            <div style="color:#888; font-family:monospace; margin-bottom:8px;">${
              data.phonetics?.us || ""
            }</div>
            <div style="margin-bottom:12px; color:#333;">${meaning}</div>
            <div style="display:flex; gap:8px;">
                <button id="pp-listen" class="ant-btn ant-btn-icon">${
                  ICONS.sound
                }</button>
                <button id="pp-mic" class="ant-btn ant-btn-icon">${
                  ICONS.mic
                }</button>
                <div style="flex:1"></div>
                <button id="pp-add" class="ant-btn ant-btn-primary">Add to DB</button>
            </div>
            <div id="pp-assessment"></div>
        </div>
      `;
    document.getElementById("pp-listen").onclick = () =>
      handlers.onSpeak(data.text);
    document.getElementById("pp-mic").onclick = () =>
      handleMicClick(data.text, document.getElementById("pp-assessment"));
    document.getElementById("pp-add").onclick = () => {
      hideAll();
      handlers.onOpenCreate(data.text);
    };
  }

  // --- [NEW] RENDER ASSESSMENT MODAL ---
  function renderAssessmentModal(vocab, handlers) {
    init();
    assessWrapper.style.display = "flex";

    const renderContent = (result = null, isRecording = false, error = "") => {
      let scoreHtml = `<div style="color:#e5e7eb; font-size:48px;">?</div>`;
      let borderColor = "#f3f4f6";
      let phonemeHtml = "";

      if (result) {
        const score = Math.round(result.AccuracyScore);
        borderColor =
          score >= 80 ? "#4caf50" : score >= 60 ? "#fbc02d" : "#ef4444";
        scoreHtml = `<div style="color:${borderColor}">${score}</div>`;

        if (result.Words && result.Words[0] && result.Words[0].Phonemes) {
          phonemeHtml = result.Words[0].Phonemes.map((p) => {
            const bgClass =
              p.AccuracyScore >= 80
                ? "bg-green"
                : p.AccuracyScore >= 60
                ? "bg-yellow"
                : "bg-red";
            return `<span class="phoneme-badge ${bgClass}" title="${p.AccuracyScore}">${p.Phoneme}</span>`;
          }).join("");
        }
      }

      assessWrapper.innerHTML = `
            <div class="assess-modal-content">
                <button id="assess-close" style="position:absolute; top:15px; right:15px; background:none; border:none; font-size:20px; cursor:pointer; color:#9ca3af;">‚úï</button>
                <div class="assess-word">${vocab.word}</div>
                <div class="assess-pronun">/${vocab.pronunciation || ""}/</div>
                <div class="score-circle-container" style="border-color: ${borderColor}">
                    ${scoreHtml}
                </div>
                ${
                  phonemeHtml
                    ? `<div class="phoneme-list">${phonemeHtml}</div>`
                    : ""
                }
                <div class="assess-controls">
                    <button id="btn-listen-sample" class="btn-control btn-speaker" title="Nghe m·∫´u">
                       ${ICONS.sound}
                    </button>
                    <button id="btn-record-toggle" class="btn-control btn-record ${
                      isRecording ? "recording" : ""
                    }">
                       ${
                         isRecording
                           ? '<div style="width:20px; height:20px; background:white; border-radius:4px;"></div>'
                           : ICONS.mic
                       }
                    </button>
                    <button id="btn-playback-user" class="btn-control btn-playback" title="Nghe l·∫°i" ${
                      !result ? "disabled" : ""
                    }>
                       <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                    </button>
                </div>
                <div class="assess-status">
                    ${
                      isRecording
                        ? '<span style="color:#ef4444">Listening...</span>'
                        : error
                        ? `<span style="color:#ef4444">${error}</span>`
                        : result
                        ? vocab.id !== "temp"
                          ? '<span style="color:#10b981">‚úÖ Score Saved!</span>'
                          : '<span style="color:#f59e0b">‚ö†Ô∏è Practice Mode (Not Saved)</span>'
                        : "Click mic to start"
                    }
                </div>
            </div>
          `;

      document.getElementById("assess-close").onclick = () =>
        (assessWrapper.style.display = "none");
      document.getElementById("btn-listen-sample").onclick = () =>
        handlers.onSpeak(vocab.word);

      document.getElementById("btn-record-toggle").onclick = () => {
        if (isRecording) handlers.onStop();
        else
          handlers.onRecord(
            (res) => renderContent(res, false),
            (err) => renderContent(null, false, err)
          );
        if (!isRecording) renderContent(null, true);
      };

      document.getElementById("btn-playback-user").onclick = () =>
        handlers.onPlayback();
    };

    renderContent();
  }

  function renderAssessmentResult(data, container) {
    if (!data || !data.NBest) {
      container.innerHTML = `<div style="color:red; text-align:center; padding:10px;">Error</div>`;
      return;
    }
    const result = data.NBest[0];
    const score = Math.round(result.AccuracyScore);
    const color = score >= 80 ? "#52c41a" : score >= 60 ? "#faad14" : "#ff4d4f";
    let html = `...`; // Old assessment result renderer can be deprecated or kept for mini-popups
    container.innerHTML = html;
    container.style.display = "block";
  }

  async function handleMicClick(text, container) {
    // This logic should now be in native-core.js
    // It will call renderAssessmentModal instead
  }

  return {
    renderSearchModal,
    renderPopup,
    renderFormModal,
    renderAssessmentModal,
    hideAll,
  };
})();



================================================
FILE: apps/extension/content-scripts/shortcuts.js
================================================
// This file is intentionally left blank to avoid redundant hotkey listeners.
// The logic has been consolidated into main.js.


================================================
FILE: apps/extension/content-scripts/ui.js
================================================
// ui.js
let iframeElement = null;

export const createOverlay = () => {
  if (iframeElement) return; // ƒê√£ t·ªìn t·∫°i th√¨ th√¥i

  // 1. T·∫°o Iframe
  iframeElement = document.createElement("iframe");

  // 2. Style cho Iframe (Full m√†n h√¨nh, ƒë√® l√™n t·∫•t c·∫£)
  Object.assign(iframeElement.style, {
    position: "fixed",
    top: "0",
    left: "0",
    width: "100vw",
    height: "100vh",
    border: "none",
    zIndex: "2147483647", // Max z-index
    backgroundColor: "rgba(0,0,0,0.5)", // M√†u n·ªÅn t·ªëi m·ªù
    display: "block",
  });

  // 3. Load trang Vocabulary c·ªßa Frontend v√†o
  // Th√™m param ?openSearch=true ƒë·ªÉ React bi·∫øt ƒë∆∞·ªùng m·ªü Popup ngay l·∫≠p t·ª©c
  iframeElement.src = `${APP_CONFIG.FRONTEND_URL}/vocabulary?openSearch=true&iframeMode=true`;
  iframeElement.allow = "microphone; camera"; // Quan tr·ªçng: Cho ph√©p d√πng Mic trong Iframe

  document.body.appendChild(iframeElement);

  // 4. Focus v√†o iframe ƒë·ªÉ g√µ ph√≠m ƒë∆∞·ª£c ngay
  iframeElement.onload = () => {
    iframeElement.contentWindow.focus();
  };
};

export const removeOverlay = () => {
  if (iframeElement) {
    iframeElement.remove();
    iframeElement = null;
  }
};

export const toggleOverlay = () => {
  if (iframeElement) {
    removeOverlay();
  } else {
    createOverlay();
  }
};



================================================
FILE: apps/frontend/README.md
================================================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.



================================================
FILE: apps/frontend/eslint.config.mjs
================================================
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;



================================================
FILE: apps/frontend/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  reactCompiler: true,
  async rewrites() {
    return [
      {
        source: '/vocabulary/search',
        destination: '/vocabulary?openSearch=true',
      },
    ];
  },
};

export default nextConfig;


================================================
FILE: apps/frontend/package.json
================================================
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "next": "16.0.8",
    "react": "19.2.1",
    "react-dom": "19.2.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.17",
    "@tailwindcss/vite": "^4.0.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.22",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.8",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.0.0",
    "typescript": "^5"
  }
}



================================================
FILE: apps/frontend/postcss.config.js
================================================
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
}


================================================
FILE: apps/frontend/postcss.config.mjs
================================================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    "@tailwindcss/postcss": {}, // üëà ƒê·ªïi d√≤ng n√†y
    autoprefixer: {},
  },
};

export default config;



================================================
FILE: apps/frontend/tailwind.config.ts
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}


================================================
FILE: apps/frontend/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}



================================================
FILE: apps/frontend/app/globals.css
================================================
@import "tailwindcss";



================================================
FILE: apps/frontend/app/layout.tsx
================================================
import type { Metadata } from "next";
import './globals.css'
import { AuthProvider } from "../contexts/AuthContext";

export const metadata: Metadata = {
  title: "Vocabulary App",
  description: "Learn English vocabulary",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          {children}
        </AuthProvider>
      </body>
    </html>
  );
}


================================================
FILE: apps/frontend/app/page.module.css
================================================
.page {
  --background: #fafafa;
  --foreground: #fff;

  --text-primary: #000;
  --text-secondary: #666;

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;
  --button-secondary-border: #ebebeb;

  display: flex;
  min-height: 100vh;
  align-items: center;
  justify-content: center;
  font-family: var(--font-geist-sans);
  background-color: var(--background);
}

.main {
  display: flex;
  min-height: 100vh;
  width: 100%;
  max-width: 800px;
  flex-direction: column;
  align-items: flex-start;
  justify-content: space-between;
  background-color: var(--foreground);
  padding: 120px 60px;
}

.intro {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  text-align: left;
  gap: 24px;
}

.intro h1 {
  max-width: 320px;
  font-size: 40px;
  font-weight: 600;
  line-height: 48px;
  letter-spacing: -2.4px;
  text-wrap: balance;
  color: var(--text-primary);
}

.intro p {
  max-width: 440px;
  font-size: 18px;
  line-height: 32px;
  text-wrap: balance;
  color: var(--text-secondary);
}

.intro a {
  font-weight: 500;
  color: var(--text-primary);
}

.ctas {
  display: flex;
  flex-direction: row;
  width: 100%;
  max-width: 440px;
  gap: 16px;
  font-size: 14px;
}

.ctas a {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 40px;
  padding: 0 16px;
  border-radius: 128px;
  border: 1px solid transparent;
  transition: 0.2s;
  cursor: pointer;
  width: fit-content;
  font-weight: 500;
}

a.primary {
  background: var(--text-primary);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--button-secondary-border);
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }
}

@media (max-width: 600px) {
  .main {
    padding: 48px 24px;
  }

  .intro {
    gap: 16px;
  }

  .intro h1 {
    font-size: 32px;
    line-height: 40px;
    letter-spacing: -1.92px;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }

  .page {
    --background: #000;
    --foreground: #000;

    --text-primary: #ededed;
    --text-secondary: #999;

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
    --button-secondary-border: #1a1a1a;
  }
}



================================================
FILE: apps/frontend/app/page.tsx
================================================
import Image from "next/image";
import styles from "./page.module.css";

export default function Home() {
  return (
    <div className={styles.page}>
      <main className={styles.main}>
        <Image
          className={styles.logo}
          src="/next.svg"
          alt="Next.js logo"
          width={100}
          height={20}
          priority
        />
        <div className={styles.intro}>
          <h1>To get started, edit the page.tsx file.</h1>
          <p>
            Looking for a starting point or more instructions? Head over to{" "}
            <a
              href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
              target="_blank"
              rel="noopener noreferrer"
            >
              Templates
            </a>{" "}
            or the{" "}
            <a
              href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
              target="_blank"
              rel="noopener noreferrer"
            >
              Learning
            </a>{" "}
            center.
          </p>
        </div>
        <div className={styles.ctas}>
          <a
            className={styles.primary}
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className={styles.logo}
              src="/vercel.svg"
              alt="Vercel logomark"
              width={16}
              height={16}
            />
            Deploy Now
          </a>
          <a
            className={styles.secondary}
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Documentation
          </a>
        </div>
      </main>
    </div>
  );
}



================================================
FILE: apps/frontend/app/admin/users/page.tsx
================================================
import React from 'react';

const AdminUsersPage = () => {
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold">Qu·∫£n l√Ω ng∆∞·ªùi d√πng</h1>
      <p>Ch·ª©c nƒÉng ƒëang ph√°t tri·ªÉn...</p>
    </div>
  );
};

export default AdminUsersPage;


================================================
FILE: apps/frontend/app/app/auth/callback/page.tsx
================================================
// apps/frontend/app/auth/callback/page.tsx
'use client';

import { useEffect, Suspense } from 'react'; // üëà Import Suspense
import { useRouter, useSearchParams } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';

// 1. T·∫°o component con ƒë·ªÉ x·ª≠ l√Ω logic searchParams
function AuthCallbackContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { login } = useAuth();

  useEffect(() => {
    const token = searchParams.get('token');
    if (token) {
      // L∆∞u token v√† ƒëi·ªÅu h∆∞·ªõng v·ªÅ trang ch·ªß ho·∫∑c dashboard
      localStorage.setItem('token', token);
      
      // G·ªçi h√†m login t·ª´ context n·∫øu c·∫ßn ƒë·ªÉ c·∫≠p nh·∫≠t state user
      // login(token); 
      
      // Redirect v·ªÅ trang ch·ªß
      router.push('/');
    } else {
      // N·∫øu kh√¥ng c√≥ token, quay v·ªÅ login
      router.push('/login');
    }
  }, [searchParams, router, login]);

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-bold mb-2">ƒêang x·ª≠ l√Ω ƒëƒÉng nh·∫≠p...</h2>
        <p>Vui l√≤ng ch·ªù trong gi√¢y l√°t.</p>
      </div>
    </div>
  );
}

// 2. Component ch√≠nh b·ªçc Suspense
export default function AuthCallbackPage() {
  return (
    <Suspense fallback={<div className="flex min-h-screen items-center justify-center">Loading...</div>}>
      <AuthCallbackContent />
    </Suspense>
  );
}


================================================
FILE: apps/frontend/app/login/page.tsx
================================================
'use client';

import { useState } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { API_URL } from '@/lib/api'; // Import API_URL

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const { login } = useAuth();
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await login(email, password);
      router.push('/vocabulary');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Login failed');
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleLogin = () => {
    // ‚úÖ Redirect to backend Google OAuth using dynamic API_URL
    window.location.href = `${API_URL}/auth/google`;
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white p-8 rounded-lg shadow-md">
        <h1 className="text-3xl font-bold text-center mb-8">üîê Login</h1>

        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="your@email.com"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
            />
          </div>

          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600 disabled:bg-gray-400"
          >
            {isLoading ? 'Loading...' : 'Login'}
          </button>
        </form>

        <div className="mt-6">
          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">Or continue with</span>
            </div>
          </div>

          <button
            onClick={handleGoogleLogin}
            className="mt-4 w-full flex items-center justify-center gap-2 border border-gray-300 bg-white py-2 rounded hover:bg-gray-50"
          >
            <svg className="w-5 h-5" viewBox="0 0 24 24">
              <path
                fill="#4285F4"
                d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
              />
              <path
                fill="#34A853"
                d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
              />
              <path
                fill="#FBBC05"
                d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
              />
              <path
                fill="#EA4335"
                d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
              />
            </svg>
            Continue with Google
          </button>
        </div>

        <p className="mt-6 text-center text-sm text-gray-600">
          Don't have an account?{' '}
          <Link href="/register" className="text-blue-500 hover:underline">
            Register
          </Link>
        </p>
      </div>
    </div>
  );
}


================================================
FILE: apps/frontend/app/register/page.tsx
================================================
'use client';

import { useState } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { useRouter } from 'next/navigation';
import Link from 'next/link';

export default function RegisterPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const { register } = useAuth();
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await register(email, password, name);
      router.push('/vocabulary');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Registration failed');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white p-8 rounded-lg shadow-md">
        <h1 className="text-3xl font-bold text-center mb-8">üìù Register</h1>

        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-1">Name</label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Your name"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">Email</label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="your@email.com"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
            />
          </div>

          <button
            type="submit"
            disabled={isLoading}
            className="w-full bg-blue-500 text-white py-2 rounded hover:bg-blue-600 disabled:bg-gray-400"
          >
            {isLoading ? 'Loading...' : 'Register'}
          </button>
        </form>

        <p className="mt-6 text-center text-sm text-gray-600">
          Already have an account?{' '}
          <Link href="/login" className="text-blue-500 hover:underline">
            Login
          </Link>
        </p>
      </div>
    </div>
  );
}


================================================
FILE: apps/frontend/app/vocabulary/page.tsx
================================================
"use client";

import React, { useState, useRef, useEffect, Suspense } from 'react';
import { useAuth } from "@/contexts/AuthContext";
import { useRouter, useSearchParams } from "next/navigation";

import useVocabData from "@/hooks/vocabulary/useVocabData";
import useVocabModals from "@/hooks/vocabulary/useVocabModals";

import usePronunciationAssessment from "@/hooks/vocabulary/usePronunciationAssessment";
import useQuickSearch from "@/hooks/vocabulary/useQuickSearch";

import VocabTable from "@/components/vocabulary/VocabTable";
import VocabFormModal from "@/components/vocabulary/VocabFormModal";
import AssessmentModal from "@/components/vocabulary/AssessmentModal";
import QuickSearchModal from "@/components/vocabulary/QuickSearchModal";
import { StarIcon } from "@/components/Icons";

function VocabularyContent() {
  const { token, isLoading } = useAuth();
  const router = useRouter();
  const searchParams = useSearchParams();
  
  // Check if in iframe mode
  const isIframeMode = searchParams.get("iframeMode") === "true";

  // QUAN TR·ªåNG: G·ªçi T·∫§T C·∫¢ hooks TR∆Ø·ªöC khi c√≥ b·∫•t k·ª≥ return n√†o
  const {
    vocabs,
    loading,
    page,
    setPage,
    totalPages,
    showStarredOnly,
    setShowStarredOnly,
    filters,
    sortConfig,
    columnOrder,
    draggedCol,
    fetchVocabs,
    handleFilterChange,
    handleSort,
    handleToggleStar,
    triggerInteraction,
    handleDragStart,
    handleDragOver,
    handleDragEnd,
  } = useVocabData(token);

  const {
    selectedVocab,
    isModalOpen,
    setIsModalOpen,
    isAutoFilling,
    formData,
    setFormData,
    fileInputRef,
    isUploading,
    handleRowClick,
    handleOpenCreateModal,
    handleSave,
    handleDelete,
    handleFileChange,
    fetchAutoFillData,
  } = useVocabModals(token, () => fetchVocabs(page));

  const {
    isAssessmentModalOpen,
    setIsAssessmentModalOpen,
    recordingVocabItem,
    isRecording,
    assessmentResult,
    assessmentError,
    isProcessingAudio,
    userAudioUrl,
    startRecording,
    stopRecording,
    handleOpenAssessment,
    handleSpeak,
  } = usePronunciationAssessment(token, () => fetchVocabs(page), page);

  const {
    showSearch,
    setShowSearch,
    quickSearchText,
    quickSearchResults,
    isSearching,
    searchInputRef,
    hasExactMatch,
    handleQuickSearchChange,
  } = useQuickSearch(token, handleOpenCreateModal);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.code === "Escape") {
        // N·∫øu ƒëang trong iframe mode, g·ª≠i message ƒë·ªÉ ƒë√≥ng
        if (isIframeMode) {
          window.parent.postMessage("CLOSE_EXTENSION_IFRAME", "*");
        }
        setShowSearch(false);
        setIsModalOpen(false);
        setIsAssessmentModalOpen(false);
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [setIsAssessmentModalOpen, setIsModalOpen, setShowSearch, isIframeMode]);

  // Redirect to login if not authenticated (AFTER all hooks)
  useEffect(() => {
    if (!isLoading && !token) {
      router.push("/login");
    }
  }, [token, isLoading, router]);

  // Hi·ªÉn th·ªã loading khi ƒëang check auth
  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  // N·∫øu kh√¥ng c√≥ token sau khi load xong, ƒë·ª´ng render g√¨ (ƒëang redirect)
  if (!token) {
    return null;
  }

  return (
    <div className={`min-h-screen ${isIframeMode ? 'bg-transparent' : 'bg-gray-50'} p-6 text-black relative`}>
      <AssessmentModal
        isOpen={isAssessmentModalOpen}
        onClose={() => setIsAssessmentModalOpen(false)}
        vocabItem={recordingVocabItem}
        isRecording={isRecording}
        assessmentResult={assessmentResult}
        assessmentError={assessmentError}
        isProcessingAudio={isProcessingAudio}
        userAudioUrl={userAudioUrl}
        startRecording={startRecording}
        stopRecording={stopRecording}
        handleSpeak={handleSpeak}
      />

      <QuickSearchModal
        isOpen={showSearch}
        onClose={() => {
          setShowSearch(false);
          // N·∫øu ƒëang trong iframe mode v√† ƒë√≥ng search, th√¨ ƒë√≥ng c·∫£ iframe
          if (isIframeMode) {
            window.parent.postMessage("CLOSE_EXTENSION_IFRAME", "*");
          }
        }}
        searchText={quickSearchText}
        onSearchChange={handleQuickSearchChange}
        results={quickSearchResults}
        isSearching={isSearching}
        onSelect={(vocab) => {
          setShowSearch(false);
          handleRowClick(vocab);
        }}
        onCreate={() => handleOpenCreateModal(quickSearchText)}
        hasExactMatch={hasExactMatch}
        searchInputRef={searchInputRef as React.RefObject<HTMLInputElement>}
        handleSpeak={handleSpeak}
        handleOpenAssessment={handleOpenAssessment}
        triggerInteraction={triggerInteraction}
      />

      <VocabFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        initialData={formData}
        setInitialData={setFormData}
        isEditMode={!!selectedVocab}
        onSave={handleSave}
        onDelete={() => selectedVocab && handleDelete(selectedVocab.id)}
        isAutoFilling={isAutoFilling}
        fetchAutoFillData={fetchAutoFillData}
        handleOpenAssessment={handleOpenAssessment}
        handleSpeak={handleSpeak}
        selectedVocab={selectedVocab}
      />

      {/* CH·∫†Y TRONG IFRAME MODE: Ch·ªâ hi·ªán QuickSearchModal, ·∫©n h·∫øt ph·∫ßn c√≤n l·∫°i */}
      {isIframeMode ? (
        <div className="flex items-center justify-center h-screen">
          <div className="text-gray-400 text-sm">
            {/* Placeholder - QuickSearchModal s·∫Ω t·ª± ƒë·ªông m·ªü */}
          </div>
        </div>
      ) : (
        <>
          {/* PAGE HEADER - CH·ªà HI·ªÜN KHI KH√îNG PH·∫¢I IFRAME MODE */}
          <div className="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
            <div>
              <h1 className="text-3xl font-bold text-gray-800">My Vocabulary</h1>
              <p className="text-gray-500 text-sm mt-1">
                Double-tap{" "}
                <kbd className="bg-gray-200 px-1.5 py-0.5 rounded text-xs border border-gray-300 font-mono">
                  Space
                </kbd>{" "}
                to Quick Search / Create
              </p>
            </div>
            <div className="flex gap-2 items-center">
              <button
                onClick={() => handleOpenCreateModal("")}
                className="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg shadow flex items-center gap-2 font-medium"
              >
                <span>+</span> New Word
              </button>
              <button
                onClick={() => {
                  const newValue = !showStarredOnly;
                  setShowStarredOnly(newValue);
                  fetchVocabs(1, filters, sortConfig, newValue);
                }}
                className={`px-4 py-2 rounded-lg border flex items-center gap-2 transition-colors ${
                  showStarredOnly
                    ? "bg-yellow-50 border-yellow-400 text-yellow-700"
                    : "bg-white border-gray-300 text-gray-600"
                }`}
              >
                <StarIcon
                  filled={showStarredOnly}
                  className={showStarredOnly ? "text-yellow-500" : "text-gray-400"}
                />
                <span className="text-sm font-medium">
                  {showStarredOnly ? "Starred" : "All"}
                </span>
              </button>
              <input
                type="file"
                ref={fileInputRef}
                onChange={handleFileChange}
                accept=".csv"
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg shadow flex items-center gap-2 text-sm font-medium"
              >
                {isUploading ? "..." : "üìÇ CSV"}
              </button>
            </div>
          </div>

          <VocabTable
            vocabs={vocabs}
            loading={loading}
            columnOrder={columnOrder}
            draggedCol={draggedCol}
            sortConfig={sortConfig}
            filters={filters}
            page={page}
            totalPages={totalPages}
            handleDragStart={handleDragStart}
            handleDragOver={handleDragOver}
            handleDragEnd={handleDragEnd}
            handleSort={handleSort}
            handleFilterChange={handleFilterChange}
            handleRowClick={handleRowClick}
            handleToggleStar={handleToggleStar}
            handleOpenAssessment={handleOpenAssessment}
            handleSpeak={handleSpeak}
            triggerInteraction={triggerInteraction}
            fetchVocabs={fetchVocabs}
            setPage={setPage}
          />
        </>
      )}
    </div>
  );
}
// ... (Cu·ªëi file)

export default function VocabularyPage() {
  return (
    // Fallback l√† giao di·ªán hi·ªÉn th·ªã trong l√∫c ch·ªù ƒë·ªçc URL (th∆∞·ªùng r·∫•t nhanh)
    <Suspense fallback={<div className="p-4 text-center">Loading vocabulary...</div>}>
      <VocabularyContent />
    </Suspense>
  );
}


================================================
FILE: apps/frontend/certificates/localhost-key.pem
================================================
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDNADwYED/YiApX
mHjclA2Z/ruibwSxMzPO0zzlF3llfz7gf6PkMMaOb4iADHBRfxvAdgMhb4uZU8JC
c4s4e6Y8ma/C7FRLAT/uohP4H3jL5EELpEThzFECoN6j5WYvjxTMxFEsU2Y0OwwM
XhURMpjx85pLt9BDNx4isun0kBydGKnGzK4qoStmQB4Lh9dOjJBXIyQxZ0bYKDcC
9QiRpeppaQX64VtAygQbRbZDnrPEElOXHeYSYWsENctEUsd83pXeb37LS65iOI53
OHQrIuz8qFDIEzErcQvKkWkx9aDmMr99C+CAwZi/fMq5FJGPrf5M6hEMPiTi31r0
dHqG9gfFAgMBAAECggEAPKyWHLUqgGb7UKPDGd4EDJEVbeUX6W5zJgLlYhTJjF3V
+VIt6sr46Y1fRC7qS2SojRUgphPCqJXeyBY0nXoTYJpIKBQUesKa7oEwEd8WvJoJ
Gm37KS10yKdeXfn2fZsGl/h+4fSpKkpTrZFnANkN5YapI0H7NPmqRLDZh9Xjcicj
eTi1SsOFqKzPHK/80ujVD4NzvBj27TT4IWWnFpZmVWDPqX7BEX+vNJ5XykWWZyGI
/y5BUR5tgQmWOk9EStjEAX8lfpLPi6L2SPxXJ6bDytiwS/tMb/9x2Hhx9jlSKui3
MMKpjeVKiSvP+fQ/+euNBXHUbtZ888kM+LtOCiDMHQKBgQDShDnjAdwk2zgo8l1C
BuWYfZFGjki8aySlGlYBqrEVotxKXXEhm7+CBRgQbciipfW9VL520NPNjYPQIWWY
M/o/9YPVYDOqrDALPRAvokyjjZ0L9RqgfoyxuMI0/KolCyQ7UQrfSXzQdKL9bqVq
P3XmY/Rf7xwMhYEoJG545Za1swKBgQD5SvBBJHTUVeqfCpTR0fHM/d7Yj9qz/zwr
3ukPlU6/5j/NOuxzIai3KicYosgbllhzdcnehdRSQXrjr2KqJISIqmMGHGrAK+JK
320y1hKEK2y7y2My4xWORLkePO7GxviUfc56nb1GD/vFew1lw373jHvgbsbLdPPd
tx2HMASApwKBgBHu/7tt+iINptAeLYGlcsO11r1q+5lJi1qhTrhfoSxVrmyLX0rc
qMjbxDwKDjCE8NVLNdqLWa/GIXeGkNARhX0TXkK8Kkqc1o7uicV1DxBTzRAqtjT7
8uJk+e5no9r6AwEmm0WATii39vaeCWtuso2I8FWH2hza9rDDwcF81YTvAoGBAPVw
fpLkXdIgtNrZBCSAW1zEJn95Qo4tIQTgdv3Mtrfg7bgV526DGSUc71kmC3Z905/5
vELF6IEDzwYUS0PQqFwVxWDi4YdKrYWh7FU8xwYx6uAKIySax0JHDytiOoSiqWMp
afz3CL7ORcfsmwgyLfNz8RLKfhcakm8cNoo/EG/JAoGBAK1nBVp+sC+2n/ge1Fo3
wKIdldV5kIGJHaFqPNuTndgEgzMbuAr0vqclzQGaDuS1iqovHgXuXNHr8yWQIFHg
2yb2d93pYDjPrh5o4dJsrrpLJzufUv1P93B5BNsILsCcO/F43zyvF8kMMocrrUDx
M4EZhN1756tA2eNGmccjdYT9
-----END PRIVATE KEY-----



================================================
FILE: apps/frontend/certificates/localhost.pem
================================================
-----BEGIN CERTIFICATE-----
MIIElDCCAvygAwIBAgIQLnE8pEEiFfjiYZShYz9NUjANBgkqhkiG9w0BAQsFADCB
qTEeMBwGA1UEChMVbWtjZXJ0IGRldmVsb3BtZW50IENBMT8wPQYDVQQLDDZERVNL
VE9QLUxKVlM3UktcOTk5OUBERVNLVE9QLUxKVlM3UksgKEhvYWkgTmFtIE5ndXll
bikxRjBEBgNVBAMMPW1rY2VydCBERVNLVE9QLUxKVlM3UktcOTk5OUBERVNLVE9Q
LUxKVlM3UksgKEhvYWkgTmFtIE5ndXllbikwHhcNMjUxMjEyMTQ1NzE0WhcNMjgw
MzEyMTQ1NzE0WjBqMScwJQYDVQQKEx5ta2NlcnQgZGV2ZWxvcG1lbnQgY2VydGlm
aWNhdGUxPzA9BgNVBAsMNkRFU0tUT1AtTEpWUzdSS1w5OTk5QERFU0tUT1AtTEpW
UzdSSyAoSG9haSBOYW0gTmd1eWVuKTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBAM0APBgQP9iICleYeNyUDZn+u6JvBLEzM87TPOUXeWV/PuB/o+Qwxo5v
iIAMcFF/G8B2AyFvi5lTwkJzizh7pjyZr8LsVEsBP+6iE/gfeMvkQQukROHMUQKg
3qPlZi+PFMzEUSxTZjQ7DAxeFREymPHzmku30EM3HiKy6fSQHJ0YqcbMriqhK2ZA
HguH106MkFcjJDFnRtgoNwL1CJGl6mlpBfrhW0DKBBtFtkOes8QSU5cd5hJhawQ1
y0RSx3zeld5vfstLrmI4jnc4dCsi7PyoUMgTMStxC8qRaTH1oOYyv30L4IDBmL98
yrkUkY+t/kzqEQw+JOLfWvR0eob2B8UCAwEAAaN2MHQwDgYDVR0PAQH/BAQDAgWg
MBMGA1UdJQQMMAoGCCsGAQUFBwMBMB8GA1UdIwQYMBaAFA2aGeHX2DmBZI6zbeRs
WntSBbbFMCwGA1UdEQQlMCOCCWxvY2FsaG9zdIcEfwAAAYcQAAAAAAAAAAAAAAAA
AAAAATANBgkqhkiG9w0BAQsFAAOCAYEAAzPIuSx9l6ITKMyoj91SBskwaa/gVzLJ
JiiqBHDzvLpt8RTA8eTS7U45iCOLGI3r65ZY17uK0MeF4mprrDi69kV3+rjgGnXP
BxFXGBuz/T2YfrsNA3rebLrCQUaBdee9ZLoryK9Mo/J1EdgDRXhipvAY8xv66/wY
/UuUiotnvBFeTks82+q5Iy30hdAGwvLW6SmWAbfT9tamTb0vlQQGKJZblo+G+A+g
VJSOb3Zq8DMbG8QU8AMN37wmQJw+U/iBj3KIIh39jOWmJ+oHcJW8OJ6eYwE33cjG
2PTxsBHkbS8lmw/Cr4n1hGdR0knbQbAFkSMG6dYkyqsL6jgY3XjcBq/osgKofxzN
cTT2FQmK4uEKBWmu3PBG2MEJP/jWQPRGTJxEjGot1IMmrCZ1FtmQsNdRDDfbjPxl
wmKqMeV5AC301uBEDRyOXqw2M+u4wX5Yvh7MqJ46y2FgHS+XnsP+yeba7eh3SzYs
tHyO6uYQqD6J3x9LDzxMopjW5UWbqgRx
-----END CERTIFICATE-----



================================================
FILE: apps/frontend/components/Icons.tsx
================================================
import React from "react";

export const StarIcon = ({ filled, className }: { filled: boolean; className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill={filled ? "currentColor" : "none"} stroke="currentColor" strokeWidth={filled ? "0" : "2"} strokeLinecap="round" strokeLinejoin="round" className={className} width="24" height="24">
    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
  </svg>
);

export const SpeakerIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
  </svg>
);

export const MicrophoneIcon = ({ className }: { className?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
    <line x1="12" y1="19" x2="12" y2="23"></line>
    <line x1="8" y1="23" x2="16" y2="23"></line>
  </svg>
);


================================================
FILE: apps/frontend/components/vocabulary/AssessmentModal.tsx
================================================
import React from "react";
import { MicrophoneIcon, SpeakerIcon } from "@/components/Icons";
import { AssessmentResult } from "@/hooks/vocabulary/usePronunciationAssessment";
import { VocabItem } from "@/hooks/vocabulary/useVocabData";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  vocabItem: VocabItem | null;
  isRecording: boolean;
  assessmentResult: AssessmentResult | null;
  assessmentError: string;
  isProcessingAudio: boolean;
  userAudioUrl: string | null;
  startRecording: () => void;
  stopRecording: () => void;
  handleSpeak: (text: string, e?: React.MouseEvent) => void;
}

export default function AssessmentModal({
  isOpen,
  onClose,
  vocabItem,
  isRecording,
  assessmentResult,
  assessmentError,
  isProcessingAudio,
  userAudioUrl,
  startRecording,
  stopRecording,
  handleSpeak,
}: Props) {
  if (!isOpen || !vocabItem) return null;

  return (
    <div
      className="fixed inset-0 bg-black/80 z-[2147483649] flex items-center justify-center p-4 backdrop-blur-sm"
      onClick={onClose}
    >
      <div
        className="bg-white w-full max-w-md rounded-2xl shadow-2xl overflow-hidden flex flex-col items-center p-8 relative animate-in fade-in zoom-in duration-200"
        onClick={(e) => e.stopPropagation()}
      >
        <button
          onClick={onClose}
          className="absolute top-4 right-4 text-gray-400 hover:text-gray-600"
        >
          ‚úï
        </button>
        <h3 className="text-3xl font-bold text-gray-800 mb-1">
          {vocabItem.word}
        </h3>
        <div className="flex flex-col items-center gap-1 mb-6">
          {vocabItem.pronunciation && (
            <span className="font-mono text-gray-500 text-lg">
              /{vocabItem.pronunciation}/
            </span>
          )}
          {vocabItem.meaning && (
            <span className="text-gray-600 text-center font-medium px-4 line-clamp-2">
              {vocabItem.meaning}
            </span>
          )}
        </div>
        {assessmentResult ? (
          <div
            className="relative w-32 h-32 mb-6 flex items-center justify-center rounded-full border-8 transition-all duration-500 ease-out"
            style={{
              borderColor:
                assessmentResult.AccuracyScore >= 80
                  ? "#4caf50"
                  : assessmentResult.AccuracyScore >= 60
                  ? "#ffeb3b"
                  : "#ff5252",
            }}
          >
            <span
              className="text-4xl font-bold"
              style={{
                color:
                  assessmentResult.AccuracyScore >= 80
                    ? "#4caf50"
                    : assessmentResult.AccuracyScore >= 60
                    ? "#fbc02d"
                    : "#ff5252",
              }}
            >
              {Math.round(assessmentResult.AccuracyScore)}
            </span>
          </div>
        ) : (
          <div className="w-32 h-32 mb-6 rounded-full border-4 border-gray-100 flex items-center justify-center bg-gray-50">
            <span className="text-4xl text-gray-300">?</span>
          </div>
        )}
        <div className="mb-6 flex gap-6 items-center">
          <button
            onClick={(e) => handleSpeak(vocabItem.word, e)}
            className="w-12 h-12 rounded-full bg-gray-100 hover:bg-gray-200 text-indigo-600 flex items-center justify-center transition-transform hover:scale-105 shadow-sm"
            title="Nghe gi·ªçng chu·∫©n"
          >
            <SpeakerIcon className="w-6 h-6" />
          </button>
          <button
            onClick={isRecording ? stopRecording : startRecording}
            className={`w-16 h-16 rounded-full flex items-center justify-center shadow-lg transition-all transform hover:scale-105 ${
              isRecording
                ? "bg-red-500 animate-pulse ring-4 ring-red-200"
                : "bg-indigo-600 hover:bg-indigo-700 ring-4 ring-indigo-100"
            }`}
          >
            {isRecording ? (
              <div className="w-6 h-6 bg-white rounded-sm" />
            ) : (
              <MicrophoneIcon className="w-8 h-8 text-white" />
            )}
          </button>
          <button
            disabled={!userAudioUrl}
            onClick={() => {
              const audio = new Audio(userAudioUrl!);
              audio.play();
            }}
            className={`w-12 h-12 rounded-full flex items-center justify-center transition-transform hover:scale-105 shadow-sm ${
              userAudioUrl
                ? "bg-green-100 hover:bg-green-200 text-green-700 cursor-pointer"
                : "bg-gray-100 text-gray-300 cursor-not-allowed"
            }`}
            title="Nghe l·∫°i gi·ªçng b·∫°n"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              className="w-5 h-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
              />
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
          </button>
        </div>
        {isProcessingAudio && (
          <p className="text-indigo-500 font-medium animate-pulse">
            Analyzing...
          </p>
        )}
        {assessmentError && (
          <p className="text-red-500 text-sm text-center bg-red-50 p-2 rounded">
            {assessmentError}
          </p>
        )}
        {assessmentResult && (
          <div className="w-full bg-gray-50 rounded-xl p-4 mt-2 border border-gray-100">
            <div className="flex flex-wrap justify-center gap-x-4 gap-y-2">
              {assessmentResult.Words.map((word, idx) => (
                <div key={idx} className="flex flex-col items-center">
                  <span
                    className={`text-lg font-bold ${
                      word.AccuracyScore >= 80
                        ? "text-green-700"
                        : word.AccuracyScore >= 60
                        ? "text-yellow-600"
                        : "text-red-600"
                    }`}
                  >
                    {word.Word}
                  </span>
                  <div className="flex gap-0.5 mt-1">
                    {word.Phonemes?.map((p, pIdx) => (
                      <span
                        key={pIdx}
                        className={`text-xs px-1 rounded min-w-[20px] text-center ${
                          p.AccuracyScore >= 80
                            ? "bg-green-100 text-green-800"
                            : p.AccuracyScore >= 60
                            ? "bg-yellow-100 text-yellow-800"
                            : "bg-red-100 text-red-800"
                        }`}
                        title={`/${p.Phoneme}/: ${p.AccuracyScore}`}
                      >
                        {p.Phoneme}
                      </span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


================================================
FILE: apps/frontend/components/vocabulary/QuickSearchModal.tsx
================================================
import { useEffect, useState } from "react";
import axios from "axios";
import { VocabItem } from "@/hooks/vocabulary/useVocabData";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  searchText: string;
  onSearchChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  results: VocabItem[];
  isSearching: boolean;
  
  // C√°c Actions
  onSelect: (item: VocabItem) => void;
  onCreate: () => void;
  hasExactMatch: boolean;
  searchInputRef: React.RefObject<HTMLInputElement>;
  handleSpeak: (text: string, e?: React.MouseEvent) => void;
  handleOpenAssessment: (item: VocabItem, e?: React.MouseEvent) => void;
  triggerInteraction: (item: VocabItem) => void;
}

export default function QuickSearchModal({
  isOpen,
  onClose,
  searchText,
  onSearchChange,
  results,
  isSearching,
  onSelect,
  onCreate,
  hasExactMatch,
  searchInputRef,
  handleSpeak,
  handleOpenAssessment,
  triggerInteraction
}: Props) {
  const [translation, setTranslation] = useState<string>("");
  const [pronunciation, setPronunciation] = useState<string>("");
  const [partOfSpeech, setPartOfSpeech] = useState<string>("");
  const [isTranslating, setIsTranslating] = useState(false);

  // Auto translate when search text changes and no exact match
  useEffect(() => {
    if (isOpen && searchInputRef.current) {
      setTimeout(() => searchInputRef.current?.focus(), 100);
    }
  }, [isOpen, searchInputRef]);

  useEffect(() => {
    const fetchTranslation = async () => {
      // Ch·ªâ reset khi c√≥ exact match, kh√¥ng ph·ª• thu·ªôc v√†o results.length
      if (!searchText || hasExactMatch) {
        setTranslation("");
        setPronunciation("");
        setPartOfSpeech("");
        return;
      }

      setIsTranslating(true);
      try {
        // Fetch c·∫£ dictionary v√† translation nh∆∞ code autofill hi·ªán t·∫°i
        const dictPromise = axios
          .get(`https://api.dictionaryapi.dev/api/v2/entries/en/${searchText}`)
          .catch(() => null);

        const translatePromise = axios
          .get(
            `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&q=${encodeURIComponent(
              searchText
            )}`
          )
          .catch(() => null);

        const [dictRes, transRes] = await Promise.all([
          dictPromise,
          translatePromise,
        ]);

        // X·ª≠ l√Ω dictionary data
        if (dictRes && dictRes.data && dictRes.data[0]) {
          const entry = dictRes.data[0];
          
          // Pronunciation
          if (entry.phonetic) {
            setPronunciation(entry.phonetic);
          } else if (entry.phonetics && entry.phonetics.length > 0) {
            const p = entry.phonetics.find((x: any) => x.text && x.audio);
            setPronunciation(p ? p.text : entry.phonetics[0].text || "");
          }
          
          // Part of Speech
          if (entry.meanings && entry.meanings.length > 0) {
            setPartOfSpeech(entry.meanings[0].partOfSpeech || "");
          }
        }

        // X·ª≠ l√Ω translation
        if (transRes && transRes.data && transRes.data[0]) {
          const translatedText = transRes.data[0]
            .map((item: any) => item[0])
            .join("");
          setTranslation(translatedText);
        }
      } catch (error) {
        console.error("Translation error:", error);
        setTranslation("");
        setPronunciation("");
        setPartOfSpeech("");
      } finally {
        setIsTranslating(false);
      }
    };

    const debounceTimer = setTimeout(() => {
      fetchTranslation();
    }, 500);

    return () => clearTimeout(debounceTimer);
  }, [searchText, hasExactMatch]);

  if (!isOpen) return null;

  return (
    <div 
      className="fixed inset-0 z-[100] flex items-start justify-center pt-20"
      onClick={onClose}
      style={{ backgroundColor: 'transparent' }}
    >
      <div
        className="bg-white w-full max-w-2xl rounded-2xl shadow-2xl overflow-hidden flex flex-col mx-4 border border-gray-100"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="p-4 border-b border-gray-100 flex items-center gap-3">
          <span className="text-xl">üîç</span>
          <input
            ref={searchInputRef}
            type="text"
            value={searchText}
            onChange={onSearchChange}
            onKeyDown={(e) => {
              if (e.key === "Enter" && results.length === 0 && !hasExactMatch) {
                onCreate();
              }
            }}
            placeholder="Type to search or create..."
            className="flex-1 text-xl font-light outline-none bg-transparent h-10"
          />
          <div className="text-xs text-gray-400 border border-gray-200 px-2 py-1 rounded">
            ESC to close
          </div>
        </div>
        
        <div className="bg-gray-50 max-h-[60vh] overflow-y-auto">
          {isSearching ? (
            <div className="p-8 text-center text-gray-400">Searching...</div>
          ) : (
            <>
              {/* Google Translate Preview Section - Show when no exact match */}
              {searchText && !hasExactMatch && (
                <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border-b border-blue-100">
                  <div className="p-4 space-y-3">
                    {/* Word with pronunciation buttons */}
                    <div className="flex items-center gap-2 flex-wrap">
                      <span className="text-2xl font-bold text-gray-800">
                        {searchText}
                      </span>
                      
                      {/* Pronunciation */}
                      {pronunciation && (
                        <span className="text-sm text-gray-600 font-mono bg-white px-2 py-1 rounded border border-gray-200">
                          {pronunciation}
                        </span>
                      )}
                      
                      {/* Part of Speech */}
                      {partOfSpeech && (
                        <span className="text-[10px] uppercase font-bold text-indigo-600 bg-indigo-100 border border-indigo-200 px-2 py-1 rounded">
                          {partOfSpeech}
                        </span>
                      )}
                      
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleSpeak(searchText, e);
                        }}
                        className="p-2 hover:bg-blue-100 rounded-full transition-colors"
                        title="Play pronunciation"
                      >
                        üîä
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleOpenAssessment({ 
                            id: 'temp', 
                            word: searchText,
                            // userId: '',
                            createdAt: new Date().toISOString(),
                            updatedAt: new Date().toISOString(),
                            occurrence: 0,
                            isStarred: false,
                            pronunciationScores: [],
                          }, e);
                        }}
                        className="p-2 hover:bg-green-100 rounded-full transition-colors"
                        title="Test pronunciation"
                      >
                        üé§
                      </button>
                    </div>

                    {/* Translation */}
                    {isTranslating ? (
                      <div className="text-sm text-gray-500 italic animate-pulse">
                        Loading...
                      </div>
                    ) : translation ? (
                      <div className="bg-white rounded-lg p-3 border border-blue-200">
                        <div className="text-xs text-gray-500 mb-1">
                          üåê Google Translate
                        </div>
                        <div className="text-base text-gray-800 font-medium">
                          {translation}
                        </div>
                      </div>
                    ) : null}
                  </div>
                </div>
              )}

              {/* Create New Button */}
              {searchText && !hasExactMatch && (
                <div
                  className="p-4 bg-indigo-50 border-b border-indigo-100 flex justify-between items-center group cursor-pointer hover:bg-indigo-100 transition-colors"
                  onClick={onCreate}
                >
                  <div className="flex items-center gap-3">
                    <div className="w-10 h-10 rounded-full bg-indigo-200 text-indigo-700 flex items-center justify-center font-bold text-xl">
                      +
                    </div>
                    <div>
                      <div className="font-bold text-indigo-800">
                        Create "{searchText}"
                      </div>
                      <div className="text-xs text-indigo-500">
                        Auto-fill meaning & pronunciation
                      </div>
                    </div>
                  </div>
                  <span className="text-sm font-semibold text-indigo-600 bg-white px-3 py-1 rounded-full shadow-sm">
                    Enter ‚Üµ
                  </span>
                </div>
              )}

              {/* Results List */}
              {results.length > 0 ? (
                <ul className="divide-y divide-gray-100">
                  {results.map((item) => (
                    <li
                      key={item.id}
                      onClick={() => {
                        triggerInteraction(item);
                        onSelect(item);
                      }}
                      className="p-3 hover:bg-indigo-50 cursor-pointer transition-colors group"
                    >
                      <div className="flex justify-between items-start gap-3">
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <span className="font-bold text-lg text-indigo-700">
                              {item.word}
                            </span>
                            
                            {/* Actions nh·ªè trong list */}
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleOpenAssessment(item, e);
                              }}
                              className="text-gray-400 hover:text-green-600 p-1 rounded-full hover:bg-green-100"
                            >
                              üé§
                            </button>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleSpeak(item.word, e);
                              }}
                              className="text-gray-400 hover:text-indigo-600 p-1 rounded-full hover:bg-indigo-100"
                            >
                              üîä
                            </button>
                            
                            {item.partOfSpeech && (
                              <span className="text-[10px] uppercase font-bold text-indigo-500 bg-indigo-50 border border-indigo-100 px-1.5 py-0.5 rounded">
                                {item.partOfSpeech}
                              </span>
                            )}
                          </div>
                          <div className="text-sm text-gray-800 line-clamp-2">
                            {item.meaning || <span className="italic text-gray-400">No meaning</span>}
                          </div>
                        </div>
                        
                        {/* Meta info b√™n ph·∫£i */}
                        <div className="text-right shrink-0 flex flex-col items-end gap-1">
                          {item.topic && (
                            <span className="text-[10px] text-gray-500 bg-gray-100 px-2 py-0.5 rounded-full">
                              {item.topic}
                            </span>
                          )}
                          {item.isStarred && <span className="text-yellow-400 text-xs">‚òÖ</span>}
                        </div>
                      </div>
                    </li>
                  ))}
                </ul>
              ) : (
                !hasExactMatch &&
                searchText && !translation && !isTranslating && (
                  <div className="p-4 text-center text-gray-400 text-sm">
                    No existing words match.
                  </div>
                )
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}


================================================
FILE: apps/frontend/components/vocabulary/VocabFormModal.tsx
================================================

import React from "react";
import { MicrophoneIcon, SpeakerIcon } from "@/components/Icons";
import { VocabFormData } from "@/hooks/vocabulary/useVocabModals";
import { VocabItem } from "@/hooks/vocabulary/useVocabData";

interface Props {
  isOpen: boolean;
  onClose: () => void;
  initialData: VocabFormData;
  setInitialData: (data: VocabFormData) => void;
  isEditMode: boolean;
  onSave: () => void;
  onDelete: (() => void) | undefined;
  isAutoFilling: boolean;
  fetchAutoFillData: (word: string) => Promise<Partial<VocabFormData> | null>;
  handleOpenAssessment: (item: VocabFormData, e?: React.MouseEvent) => void;
  handleSpeak: (text: string, e?: React.MouseEvent) => void;
  selectedVocab: VocabItem | null;
}

export default function VocabFormModal({
  isOpen,
  onClose,
  initialData: formData,
  setInitialData: setFormData,
  isEditMode,
  onSave,
  onDelete,
  isAutoFilling,
  fetchAutoFillData,
  handleOpenAssessment,
  handleSpeak,
  selectedVocab,
}: Props) {
  if (!isOpen) return null;

  const handleAutoFill = async () => {
    if (!isEditMode) {
      const autoData = await fetchAutoFillData(formData.word);
      if (autoData) {
        setFormData({ ...formData, ...autoData });
      }
    }
  };

  return (
    <div
      className="fixed inset-0 bg-black/60 z-[150] flex items-center justify-center p-4 backdrop-blur-sm"
      onClick={onClose}
    >
      <div
        className="bg-white w-full max-w-2xl rounded-xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh]"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="bg-indigo-600 p-6 text-white flex justify-between items-start shrink-0">
          <div className="w-full">
            <div className="text-xs uppercase tracking-wider opacity-80 mb-2">
              {isEditMode ? "Editing Vocabulary" : "Create New Vocabulary"}
            </div>
            <div className="flex items-center gap-3 w-full">
              <input
                value={formData.word || ""}
                onChange={(e) =>
                  setFormData({ ...formData, word: e.target.value })
                }
                onBlur={handleAutoFill}
                className="bg-transparent text-4xl font-bold text-white placeholder-white/50 outline-none w-full border-b border-white/20 pb-1 focus:border-white transition-colors"
                placeholder="Word..."
                autoFocus={!isEditMode}
              />

              {isAutoFilling && (
                <div className="text-xs text-indigo-200 animate-pulse ml-2 whitespace-nowrap">
                  ‚ú® Auto-filling...
                </div>
              )}

              {formData.word && (
                <>
                  <button
                    onClick={(e) => handleOpenAssessment(formData, e)}
                    className="p-2 bg-white/20 rounded-full hover:bg-green-500 text-white transition-colors"
                  >
                    <MicrophoneIcon className="w-6 h-6" />
                  </button>
                  <button
                    onClick={(e) => handleSpeak(formData.word, e)}
                    className="p-2 bg-white/20 rounded-full hover:bg-white/30 text-white"
                  >
                    <SpeakerIcon className="w-6 h-6" />
                  </button>
                </>
              )}
            </div>
          </div>
          <button
            onClick={onClose}
            className="text-white/70 hover:text-white text-2xl font-bold ml-4"
          >
            ‚úï
          </button>
        </div>
        <div className="p-6 space-y-5 overflow-y-auto relative">
          {isAutoFilling && (
            <div className="absolute inset-0 bg-white/50 z-10 flex items-center justify-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
            </div>
          )}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">
                Pronunciation
              </label>
              <input
                value={formData.pronunciation || ""}
                onChange={(e) =>
                  setFormData({
                    ...formData,
                    pronunciation: e.target.value,
                  })
                }
                className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 outline-none font-mono text-sm"
                placeholder="/.../"
              />
            </div>
            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">
                Part Of Speech
              </label>
              <select
                value={formData.partOfSpeech || ""}
                onChange={(e) =>
                  setFormData({ ...formData, partOfSpeech: e.target.value })
                }
                className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 outline-none bg-white"
              >
                <option value="">-- Select --</option>
                <option value="noun">Noun</option>
                <option value="verb">Verb</option>
                <option value="adjective">Adjective</option>
                <option value="adverb">Adverb</option>
                <option value="phrase">Phrase</option>
              </select>
            </div>
          </div>
          <div>
            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">
              Meaning
            </label>
            <textarea
              value={formData.meaning || ""}
              onChange={(e) =>
                setFormData({ ...formData, meaning: e.target.value })
              }
              className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 outline-none min-h-[80px] text-lg font-medium text-gray-800"
              placeholder="Nghƒ©a c·ªßa t·ª´..."
            />
          </div>
          <div>
            <label className="block text-xs font-bold text-gray-400 uppercase mb-1">
              Example
            </label>
            <textarea
              value={formData.example || ""}
              onChange={(e) =>
                setFormData({ ...formData, example: e.target.value })
              }
              className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 outline-none bg-gray-50 italic text-gray-600"
              placeholder="V√≠ d·ª•..."
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">
                Topic
              </label>
              <input
                value={formData.topic || ""}
                onChange={(e) =>
                  setFormData({ ...formData, topic: e.target.value })
                }
                className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 outline-none"
                placeholder="IT, Travel..."
              />
            </div>
            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">
                Related Words
              </label>
              <input
                value={formData.relatedWords || ""}
                onChange={(e) =>
                  setFormData({ ...formData, relatedWords: e.target.value })
                }
                className="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-500 outline-none"
                placeholder="Synonyms..."
              />
            </div>
          </div>
        </div>
        <div className="bg-gray-50 p-4 border-t border-gray-200 flex justify-between items-center shrink-0">
          {selectedVocab ? (
            <div className="text-xs text-gray-400">
              Updated: {new Date(selectedVocab.updatedAt).toLocaleString()}
            </div>
          ) : (
            <div></div>
          )}
          <div className="flex gap-3">
            {isEditMode && onDelete && (
              <button
                onClick={onDelete}
                className="text-red-600 hover:bg-red-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors border border-transparent hover:border-red-200"
              >
                Delete
              </button>
            )}
            <button
              onClick={onClose}
              className="text-gray-600 hover:bg-gray-200 px-5 py-2 rounded-lg text-sm font-medium transition-colors"
            >
              Cancel
            </button>
            <button
              onClick={onSave}
              className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg text-sm font-bold shadow-md transform active:scale-95 transition-all"
            >
              {isEditMode ? "Save Changes" : "Create Word"}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: apps/frontend/components/vocabulary/VocabTable.tsx
================================================

import React from "react";
import {
  VocabItem,
  FilterState,
  SortState,
} from "@/hooks/vocabulary/useVocabData";
import { StarIcon, MicrophoneIcon, SpeakerIcon } from "@/components/Icons";

interface Props {
  vocabs: VocabItem[];
  loading: boolean;
  page: number;
  totalPages: number;
  setPage: (page: number) => void;
  fetchVocabs: (
    pageNum?: number,
    filters?: FilterState,
    sort?: SortState
  ) => void;
  filters: FilterState;
  handleFilterChange: (key: keyof FilterState, value: string) => void;
  handleSort: (key: string) => void;
  sortConfig: SortState;
  columnOrder: string[];
  handleDragStart: (e: React.DragEvent, col: string) => void;
  handleDragOver: (e: React.DragEvent, col: string) => void;
  handleDragEnd: () => void;
  draggedCol: string | null;
  handleRowClick: (item: VocabItem) => void;
  handleToggleStar: (id: string, status: boolean, e: React.MouseEvent) => void;
  handleSpeak: (text: string, e: React.MouseEvent) => void;
  handleOpenAssessment: (item: VocabItem, e: React.MouseEvent) => void;
  triggerInteraction: (vocab: VocabItem) => void;
}

export default function VocabTable({
  vocabs,
  loading,
  page,
  totalPages,
  setPage,
  fetchVocabs,
  filters,
  handleFilterChange,
  handleSort,
  sortConfig,
  columnOrder,
  handleDragStart,
  handleDragOver,
  handleDragEnd,
  draggedCol,
  handleRowClick,
  handleToggleStar,
  handleSpeak,
  handleOpenAssessment,
  triggerInteraction,
}: Props) {
  const handlePageChange = (newPage: number) => {
    setPage(newPage);
    fetchVocabs(newPage, filters, sortConfig);
  };

  const getSortIcon = (colKey: string) =>
    sortConfig.key !== colKey ? (
      <span className="text-gray-300 ml-1 opacity-50">‚Üï</span>
    ) : sortConfig.direction === "asc" ? (
      <span className="ml-1 text-indigo-600">‚ñ≤</span>
    ) : (
      <span className="ml-1 text-indigo-600">‚ñº</span>
    );

  const columnConfig: Record<
    string,
    {
      label: React.ReactNode;
      width: string;
      renderCell: (v: VocabItem) => React.ReactNode;
      renderFilter?: () => React.ReactNode;
      sortKey?: string;
    }
  > = {
    star: {
      label: "‚òÖ",
      width: "w-12",
      sortKey: "isStarred",
      renderCell: (v) => (
        <button
          onClick={(e) => handleToggleStar(v.id, v.isStarred, e)}
          className="hover:bg-gray-100 rounded-full p-1"
        >
          <StarIcon
            filled={v.isStarred}
            className={
              v.isStarred ? "text-yellow-400 w-5 h-5" : "text-gray-300 w-5 h-5"
            }
          />
        </button>
      ),
    },
    updatedAt: {
      label: "Last Active",
      width: "w-32",
      sortKey: "updatedAt",
      renderCell: (v) => (
        <div className="font-mono text-xs text-gray-500">
          {new Date(v.updatedAt).toLocaleDateString()} <br />
          <span className="text-gray-400">
            {new Date(v.updatedAt).toLocaleTimeString()}
          </span>
        </div>
      ),
    },
    topic: {
      label: "Topic",
      width: "w-32",
      sortKey: "topic",
      renderCell: (v) =>
        v.topic && (
          <span className="bg-gray-100 px-2 py-0.5 rounded text-xs">
            {v.topic}
          </span>
        ),
      renderFilter: () => (
        <input
          className="w-full border rounded px-2 py-1 text-xs outline-none focus:border-indigo-500"
          placeholder="Filter..."
          value={filters.topic}
          onChange={(e) => handleFilterChange("topic", e.target.value)}
        />
      ),
    },
    word: {
      label: "Word",
      width: "w-48",
      sortKey: "word",
      renderCell: (v) => (
        <div className="flex items-center justify-between gap-2 font-bold text-indigo-700">
          <span>{v.word}</span>
          <div className="flex items-center gap-1">
            <button
              onClick={(e) => {
                handleOpenAssessment(v, e);
                triggerInteraction(v);
              }}
              className="text-gray-400 hover:text-green-600 p-1 rounded-full hover:bg-green-50"
              title="Practice Pronunciation"
            >
              <MicrophoneIcon className="w-4 h-4" />
            </button>
            <button
              onClick={(e) => {
                handleSpeak(v.word, e);
                triggerInteraction(v);
              }}
              className="text-gray-400 hover:text-indigo-600 p-1 rounded-full hover:bg-indigo-50"
            >
              <SpeakerIcon className="w-4 h-4" />
            </button>
          </div>
        </div>
      ),
      renderFilter: () => (
        <input
          className="w-full border rounded px-2 py-1 text-xs outline-none focus:border-indigo-500"
          placeholder="Filter..."
          value={filters.word}
          onChange={(e) => handleFilterChange("word", e.target.value)}
        />
      ),
    },
    pronunciation: {
      label: "Pronun.",
      width: "w-32",
      renderCell: (v) => (
        <span className="font-mono text-gray-500 text-xs">
          {v.pronunciation}
        </span>
      ),
    },
    meaning: {
      label: "Meaning",
      width: "w-48",
      renderCell: (v) => (
        <span
          className="text-gray-800 text-sm line-clamp-2"
          title={v.meaning || ""}
        >
          {v.meaning}
        </span>
      ),
      renderFilter: () => (
        <input
          className="w-full border rounded px-2 py-1 text-xs outline-none focus:border-indigo-500"
          placeholder="Meaning..."
          value={filters.meaning}
          onChange={(e) => handleFilterChange("meaning", e.target.value)}
        />
      ),
    },
    example: {
      label: "Example",
      width: "w-64",
      renderCell: (v) => (
        <span
          className="italic text-gray-500 text-xs line-clamp-2"
          title={v.example || ""}
        >
          {v.example}
        </span>
      ),
    },
    relatedWords: {
      label: "Related",
      width: "w-40",
      renderCell: (v) => (
        <span className="text-gray-500 text-xs">{v.relatedWords}</span>
      ),
    },
    occurrence: {
      label: "Count",
      width: "w-20",
      sortKey: "occurrence",
      renderCell: (v) => (
        <div className="text-center font-semibold text-gray-500">
          {v.occurrence}
        </div>
      ),
    },
    score: {
      label: "Score",
      width: "w-20",
      renderCell: (v) => {
        const scores = v.pronunciationScores || [];
        if (scores.length === 0)
          return <span className="text-gray-300 text-xs">-</span>;
        const recentScores = scores.slice(-3);
        const avg = Math.round(
          recentScores.reduce((a, b) => a + b, 0) / recentScores.length
        );
        let colorClass = "bg-red-100 text-red-700";
        if (avg >= 80) colorClass = "bg-green-100 text-green-700";
        else if (avg >= 60) colorClass = "bg-yellow-100 text-yellow-700";
        return (
          <div className="flex flex-col items-center">
            <span
              className={`text-xs font-bold px-2 py-0.5 rounded ${colorClass}`}
            >
              {avg}
            </span>
          </div>
        );
      },
    },
    actions: {
      label: "Action",
      width: "w-20",
      renderCell: (v) => (
        <button
          onClick={(e) => {
            e.stopPropagation();
            handleRowClick(v);
          }}
          className="text-indigo-600 text-xs border border-indigo-200 px-2 py-1 rounded hover:bg-indigo-50"
        >
          Edit
        </button>
      ),
    },
  };

  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden flex flex-col">
      <div className="overflow-x-auto pb-4">
        <table className="min-w-full divide-y divide-gray-200 table-fixed">
          <thead className="bg-gray-50 select-none">
            <tr>
              {columnOrder.map((colId) => {
                const config = columnConfig[colId];
                if (!config) return null;
                const isDragging = draggedCol === colId;
                return (
                  <th
                    key={colId}
                    draggable
                    onDragStart={(e) => handleDragStart(e, colId)}
                    onDragOver={(e) => handleDragOver(e, colId)}
                    onDragEnd={handleDragEnd}
                    onClick={() => config.sortKey && handleSort(config.sortKey)}
                    className={`${
                      config.width
                    } px-4 py-3 text-left text-xs font-bold text-gray-500 uppercase border-r border-gray-200 cursor-move hover:bg-gray-100 transition-all duration-200 ${
                      isDragging
                        ? "opacity-50 bg-indigo-50 border-2 border-indigo-300 scale-95 shadow-inner"
                        : ""
                    } ${
                      colId === "actions"
                        ? "sticky right-0 bg-gray-50 shadow-l z-10"
                        : ""
                    }`}
                  >
                    <div className="flex items-center justify-between pointer-events-none">
                      <span>{config.label}</span>
                      {config.sortKey && getSortIcon(config.sortKey)}
                    </div>
                  </th>
                );
              })}
            </tr>
            <tr className="bg-white border-b border-gray-200">
              {columnOrder.map((colId) => {
                const config = columnConfig[colId];
                if (!config) return null;
                return (
                  <td
                    key={colId}
                    className={`p-2 border-r border-gray-100 ${
                      colId === "actions"
                        ? "sticky right-0 bg-white z-10"
                        : ""
                    }`}
                  >
                    {config.renderFilter ? config.renderFilter() : null}
                  </td>
                );
              })}
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {loading ? (
              <tr>
                <td
                  colSpan={columnOrder.length}
                  className="text-center py-10 text-gray-500"
                >
                  Loading data...
                </td>
              </tr>
            ) : vocabs.length === 0 ? (
              <tr>
                <td
                  colSpan={columnOrder.length}
                  className="text-center py-10 text-gray-500"
                >
                  No vocabulary found.
                </td>
              </tr>
            ) : (
              vocabs.map((vocab) => (
                <tr
                  key={vocab.id}
                  className="hover:bg-indigo-50/50 group transition-colors cursor-pointer"
                  onClick={() => handleRowClick(vocab)}
                >
                  {columnOrder.map((colId) => {
                    const config = columnConfig[colId];
                    if (!config) return null;
                    return (
                      <td
                        key={colId}
                        className={`px-4 py-3 text-sm border-r border-gray-100 align-top whitespace-normal break-words ${
                          colId === "actions"
                            ? "sticky right-0 bg-white group-hover:bg-indigo-50/50 shadow-l z-10"
                            : ""
                        }`}
                        onClick={
                          colId === "actions" || colId === "star"
                            ? (e) => e.stopPropagation()
                            : undefined
                        }
                      >
                        {config.renderCell(vocab)}
                      </td>
                    );
                  })}
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
      <div className="p-4 border-t border-gray-200 bg-gray-50 flex justify-between items-center sticky bottom-0 z-20">
        <button
          disabled={page <= 1}
          onClick={() => handlePageChange(page - 1)}
          className="px-4 py-2 bg-white border rounded shadow-sm hover:bg-gray-100 disabled:opacity-50 text-sm font-medium"
        >
          ‚Üê Previous
        </button>
        <span className="text-sm font-medium text-gray-600">
          Page <span className="text-indigo-600 font-bold">{page}</span> of{" "}
          {totalPages}
        </span>
        <button
          disabled={page >= totalPages}
          onClick={() => handlePageChange(page + 1)}
          className="px-4 py-2 bg-white border rounded shadow-sm hover:bg-gray-100 disabled:opacity-50 text-sm font-medium"
        >
          Next ‚Üí
        </button>
      </div>
    </div>
  );
}



================================================
FILE: apps/frontend/contexts/AuthContext.tsx
================================================
[Binary file]


================================================
FILE: apps/frontend/hooks/vocabulary/usePronunciationAssessment.ts
================================================

import { useState, useRef, useEffect } from "react";
import api from "@/lib/api"; // Import api for backend
import axios from "axios"; // Keep for Azure API
import { VocabItem } from "./useVocabData";
import { VocabFormData } from "./useVocabModals";

// --- INTERFACES ---
export interface AssessmentResult {
  AccuracyScore: number;
  FluencyScore?: number;
  CompletenessScore?: number;
  PronScore?: number;
  Words: Array<{
    Word: string;
    AccuracyScore: number;
    ErrorType: string;
    Phonemes: Array<{
      Phoneme: string;
      AccuracyScore: number;
    }>;
  }>;
}

// --- HELPERS ---
async function convertAudioToWav(audioBlob: Blob): Promise<Blob> {
    const audioContext = new (window.AudioContext ||
      (window as any).webkitAudioContext)({
      sampleRate: 16000,
    });
    const arrayBuffer = await audioBlob.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    const pcmData = audioBuffer.getChannelData(0);
    const wavBuffer = encodeWAV(pcmData, 16000);
    return new Blob([wavBuffer], { type: "audio/wav" });
  }
  
function encodeWAV(samples: Float32Array, sampleRate: number) {
    const buffer = new ArrayBuffer(44 + samples.length * 2);
    const view = new DataView(buffer);
    const writeString = (view: DataView, offset: number, string: string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };
    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + samples.length * 2, true);
    writeString(view, 8, "WAVE");
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, "data");
    view.setUint32(40, samples.length * 2, true);
    let offset = 44;
    for (let i = 0; i < samples.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, samples[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return view;
}


const usePronunciationAssessment = (
  token: string | null,
  fetchVocabs: (page?: number) => void,
  page: number
) => {
  const [isAssessmentModalOpen, setIsAssessmentModalOpen] = useState(false);
  const [recordingVocabItem, setRecordingVocabItem] =
    useState<VocabItem | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [assessmentResult, setAssessmentResult] =
    useState<AssessmentResult | null>(null);
  const [assessmentError, setAssessmentError] = useState<string>("");
  const [isProcessingAudio, setIsProcessingAudio] = useState(false);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const [userAudioUrl, setUserAudioUrl] = useState<string | null>(null);

  const handleOpenAssessment = (
    item: VocabItem | VocabFormData,
    e?: React.MouseEvent
  ) => {
    if (e) e.stopPropagation();
    const vocabItem =
      "id" in item
        ? item
        : ({
            ...item,
            id: "temp",
            occurrence: 0,
            isStarred: false,
            pronunciationScores: [],
            createdAt: "",
            updatedAt: "",
          } as VocabItem);

    setRecordingVocabItem(vocabItem);
    setAssessmentResult(null);
    setAssessmentError("");
    setUserAudioUrl(null);
    setIsAssessmentModalOpen(true);
  };

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      audioChunksRef.current = [];
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) audioChunksRef.current.push(event.data);
      };
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunksRef.current, {
          type: "audio/webm",
        });
        const audioUrl = URL.createObjectURL(audioBlob);
        setUserAudioUrl(audioUrl);
        await processAudio(audioBlob);
        stream.getTracks().forEach((track) => track.stop());
      };
      mediaRecorder.start();
      setIsRecording(true);
      setAssessmentError("");
    } catch (err) {
      setAssessmentError("Microphone access denied.");
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  };

  useEffect(() => {
    let timer: NodeJS.Timeout;
    if (isAssessmentModalOpen) {
      timer = setTimeout(() => {
        if (!isRecording) {
          startRecording();
        }
      }, 300);
    } else {
      stopRecording();
    }
    return () => clearTimeout(timer);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAssessmentModalOpen]);

  const processAudio = async (audioBlob: Blob) => {
    if (!recordingVocabItem) return;
    setIsProcessingAudio(true);
    try {
      const azureKey = localStorage.getItem("azureKey");
      const azureRegion = localStorage.getItem("azureRegion");
      if (!azureKey || !azureRegion) throw new Error("Missing Azure Keys.");
      const wavBlob = await convertAudioToWav(audioBlob);
      const assessParams = {
        ReferenceText: recordingVocabItem.word,
        GradingSystem: "HundredMark",
        Granularity: "Phoneme",
        Dimension: "Comprehensive",
        PhonemeAlphabet: "IPA",
      };
      const paramsHeader = btoa(JSON.stringify(assessParams));
      const url = `https://${azureRegion}.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=en-US`;
      const response = await axios.post(url, wavBlob, {
        headers: {
          "Ocp-Apim-Subscription-Key": azureKey,
          "Content-Type": "audio/wav; codecs=audio/pcm; samplerate=16000",
          Accept: "application/json",
          "Pronunciation-Assessment": paramsHeader,
        },
      });
      const data = response.data;
      if (data.NBest && data.NBest[0]) {
        const result = data.NBest[0];
        const score =
          result.PronunciationAssessment?.AccuracyScore || result.AccuracyScore;
        setAssessmentResult({ AccuracyScore: score, Words: result.Words });

        if (recordingVocabItem.id !== "temp") {
          await api.patch(
            `/vocabulary/${recordingVocabItem.id}/score`,
            { score: Math.round(score) },
            { headers: { Authorization: `Bearer ${token}` } }
          );
          fetchVocabs(page);
        }
      } else {
        setAssessmentError("Could not recognize speech.");
      }
    } catch (err: any) {
      setAssessmentError(err.message);
    } finally {
      setIsProcessingAudio(false);
    }
  };

 // apps/frontend/hooks/vocabulary/usePronunciationAssessment.ts

  const handleSpeak = (text: string, e?: React.MouseEvent) => {
    if (e) e.stopPropagation();
    if (!text) return;
    window.speechSynthesis.cancel();

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "en-US";
    utterance.rate = 0.9; // T·ªëc ƒë·ªô ƒë·ªçc (0.9 l√† v·ª´a ph·∫£i)

    // üëá LOGIC M·ªöI: ∆Øu ti√™n tuy·ªát ƒë·ªëi cho Microsoft Aria Online
    const getVoice = () => {
      const voices = window.speechSynthesis.getVoices();
      
      // 1. T√¨m ch√≠nh x√°c gi·ªçng Microsoft Aria Online (∆Øu ti√™n s·ªë 1)
      const ariaOnline = voices.find(v => v.name.includes("Microsoft Aria Online"));
      if (ariaOnline) return ariaOnline;

      // 2. N·∫øu kh√¥ng c√≥ Online, t√¨m gi·ªçng Aria b·∫•t k·ª≥ (∆Øu ti√™n s·ªë 2)
      const ariaAny = voices.find(v => v.name.includes("Aria"));
      if (ariaAny) return ariaAny;

      // 3. Fallback: T√¨m gi·ªçng US English t·ª± nhi√™n (Google US English, etc.)
      return voices.find(v => v.lang === "en-US" && !v.name.includes("Zira")); 
    };

    const preferredVoice = getVoice();

    if (preferredVoice) {
      utterance.voice = preferredVoice;
      // console.log("Using voice:", preferredVoice.name); // B·∫≠t d√≤ng n√†y ƒë·ªÉ debug xem n√≥ ƒëang d√πng gi·ªçng n√†o
    }

    window.speechSynthesis.speak(utterance);
  };

  return {
    isAssessmentModalOpen,
    setIsAssessmentModalOpen,
    recordingVocabItem,
    isRecording,
    assessmentResult,
    assessmentError,
    isProcessingAudio,
    userAudioUrl,
    startRecording,
    stopRecording,
    handleOpenAssessment,
    handleSpeak,
  };
};

export default usePronunciationAssessment;



================================================
FILE: apps/frontend/hooks/vocabulary/usePronunciationAssessmentWithExtension.ts
================================================
// Hook m·ªõi: usePronunciationAssessmentWithExtension.ts
// D√πng cho iframe mode - g·ªçi extension ƒë·ªÉ record thay v√¨ d√πng tr·ª±c ti·∫øp getUserMedia

import { useState, useEffect, useRef } from "react";
import api from "@/lib/api"; // Import api for backend
import axios from "axios"; // For external APIs if needed

export interface AssessmentResult {
  AccuracyScore: number;
  Words: Array<{
    Word: string;
    AccuracyScore: number;
    Phonemes?: Array<{
      Phoneme: string;
      AccuracyScore: number;
    }>;
  }>;
}

// Detect if running in iframe
const isInIframe = typeof window !== 'undefined' && window.self !== window.top;

const usePronunciationAssessmentWithExtension = (token: string | null) => {
  const [isRecording, setIsRecording] = useState(false);
  const [assessmentResult, setAssessmentResult] = useState<AssessmentResult | null>(null);
  const [assessmentError, setAssessmentError] = useState("");
  const [isProcessingAudio, setIsProcessingAudio] = useState(false);
  const [userAudioUrl, setUserAudioUrl] = useState<string | null>(null);
  
  const currentWordRef = useRef<string>("");

  useEffect(() => {
    if (!isInIframe) return;

    // Listen for messages from extension
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== window.location.origin) return;

      const { type, audioData, mimeType, error } = event.data;

      if (type === 'RECORDING_STARTED') {
        setIsRecording(true);
      }

      if (type === 'RECORDING_COMPLETE') {
        setIsRecording(false);
        
        // Convert base64 to blob
        const byteCharacters = atob(audioData);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: mimeType });
        
        // Create audio URL for playback
        const url = URL.createObjectURL(blob);
        setUserAudioUrl(url);
        
        // Send to backend for assessment
        sendAudioForAssessment(blob, currentWordRef.current);
      }

      if (type === 'RECORDING_ERROR') {
        setIsRecording(false);
        setAssessmentError(error || "Microphone access denied");
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, []);

  const startRecording = (word: string) => {
    currentWordRef.current = word;
    setAssessmentResult(null);
    setAssessmentError("");
    setUserAudioUrl(null);

    if (isInIframe) {
      // Request extension to start recording
      window.parent.postMessage({ type: 'START_RECORDING' }, '*');
    } else {
      // Fallback to direct recording (when not in iframe)
      startDirectRecording(word);
    }
  };

  const stopRecording = () => {
    if (isInIframe) {
      // Request extension to stop recording
      window.parent.postMessage({ type: 'STOP_RECORDING' }, '*');
    } else {
      // Fallback to direct recording
      stopDirectRecording();
    }
  };

  // Fallback direct recording for non-iframe mode
  let mediaRecorder: MediaRecorder | null = null;
  let audioChunks: Blob[] = [];

  const startDirectRecording = async (word: string) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioChunks = [];
      mediaRecorder = new MediaRecorder(stream);

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        const url = URL.createObjectURL(audioBlob);
        setUserAudioUrl(url);
        await sendAudioForAssessment(audioBlob, word);
        stream.getTracks().forEach((track) => track.stop());
      };

      mediaRecorder.start();
      setIsRecording(true);
    } catch (error) {
      console.error("Microphone error:", error);
      setAssessmentError("Cannot access microphone");
    }
  };

  const stopDirectRecording = () => {
    if (mediaRecorder && mediaRecorder.state !== "inactive") {
      mediaRecorder.stop();
      setIsRecording(false);
    }
  };

  const sendAudioForAssessment = async (audioBlob: Blob, word: string) => {
    if (!token || !word) return;

    setIsProcessingAudio(true);
    setAssessmentError("");

    try {
      const formData = new FormData();
      formData.append("audio", audioBlob, "recording.webm");
      formData.append("referenceText", word);

      const response = await api.post(
        "/vocabulary/pronunciation-assessment",
        formData,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "multipart/form-data",
          },
        }
      );

      setAssessmentResult(response.data);
    } catch (error: any) {
      console.error("Assessment error:", error);
      setAssessmentError(
        error.response?.data?.message || "Assessment failed"
      );
    } finally {
      setIsProcessingAudio(false);
    }
  };

  return {
    isRecording,
    assessmentResult,
    assessmentError,
    isProcessingAudio,
    userAudioUrl,
    startRecording,
    stopRecording,
  };
};

export default usePronunciationAssessmentWithExtension;


================================================
FILE: apps/frontend/hooks/vocabulary/useQuickSearch.ts
================================================
import { useState, useRef, useEffect } from "react";
import api from "@/lib/api"; // Import api
import { useSearchParams, usePathname } from "next/navigation";
import { VocabItem } from "./useVocabData";

const useQuickSearch = (
  token: string | null,
  handleOpenCreateModal: (word: string) => void
) => {
  const [showSearch, setShowSearch] = useState(false);
  const [quickSearchText, setQuickSearchText] = useState("");
  const [quickSearchResults, setQuickSearchResults] = useState<VocabItem[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const quickSearchDebounce = useRef<NodeJS.Timeout | null>(null);

  const searchParams = useSearchParams();
  const pathname = usePathname();

  useEffect(() => {
    const isSearchPath = pathname?.endsWith("/search");
    const hasSearchParam = searchParams.get("openSearch") === "true";

    if (isSearchPath || hasSearchParam) {
      setShowSearch(true);
      setQuickSearchText("");
      setTimeout(() => {
        if (searchInputRef.current) {
          searchInputRef.current.focus();
        }
      }, 100);
    }
  }, [pathname, searchParams]);

  useEffect(() => {
    let lastKeyPressTime = 0;
    const handleKeyDown = (e: KeyboardEvent) => {
        const target = e.target as HTMLElement;
        const isInputFocused = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable;

        if (isInputFocused && !showSearch) return;


      if (e.code === "Space") {
        const currentTime = new Date().getTime();
        if (currentTime - lastKeyPressTime < 300) {
          e.preventDefault();
          setShowSearch(true);
          setQuickSearchText("");
          setQuickSearchResults([]);
          setTimeout(() => searchInputRef.current?.focus(), 100);
        }
        lastKeyPressTime = currentTime;
      }
      if (e.code === "Escape") {
        setShowSearch(false);
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [showSearch]);

  const handleQuickSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const text = e.target.value;
    setQuickSearchText(text);
    if (quickSearchDebounce.current) clearTimeout(quickSearchDebounce.current);
    quickSearchDebounce.current = setTimeout(
      () => performQuickSearch(text),
      300
    );
  };

  const performQuickSearch = async (text: string) => {
    if (!token || !text.trim()) {
      setQuickSearchResults([]);
      return;
    }
    setIsSearching(true);
    try {
      const res = await api.get("/vocabulary", {
        headers: { Authorization: `Bearer ${token}` },
        params: {
          page: 1,
          limit: 5,
          search: text,
          sortBy: "word",
          sortOrder: "asc",
        },
      });
      setQuickSearchResults(res.data.data);
    } catch (error) {
      console.error("Quick search error", error);
    } finally {
      setIsSearching(false);
    }
  };

  const hasExactMatch = quickSearchResults.some(
    (item) => item.word.toLowerCase() === quickSearchText.trim().toLowerCase()
  );

  return {
    showSearch,
    setShowSearch,
    quickSearchText,
    setQuickSearchText,
    quickSearchResults,
    isSearching,
    searchInputRef,
    hasExactMatch,
    handleQuickSearchChange,
  };
};

export default useQuickSearch;


================================================
FILE: apps/frontend/hooks/vocabulary/useVocabData.ts
================================================

import { useState, useCallback, useEffect, useRef } from "react";
import api from "@/lib/api"; // Import api

// --- INTERFACES ---
export interface VocabItem {
  id: string;
  word: string;
  topic?: string | null;
  partOfSpeech?: string | null;
  pronunciation?: string | null;
  meaning?: string | null;
  example?: string | null;
  relatedWords?: string | null;
  occurrence: number;
  isStarred: boolean;
  pronunciationScores: number[];
  createdAt: string;
  updatedAt: string;
}

export interface FilterState {
  word: string;
  topic: string;
  partOfSpeech: string;
  meaning: string;
}

export interface SortState {
  key: string;
  direction: "asc" | "desc";
}

const useVocabData = (token: string | null) => {
  const [vocabs, setVocabs] = useState<VocabItem[]>([]);
  const [loading, setLoading] = useState(false);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [showStarredOnly, setShowStarredOnly] = useState(false);

  const [filters, setFilters] = useState<FilterState>({
    word: "",
    topic: "",
    partOfSpeech: "",
    meaning: "",
  });

  const [sortConfig, setSortConfig] = useState<SortState>({
    key: "updatedAt",
    direction: "desc",
  });

  const [columnOrder, setColumnOrder] = useState<string[]>([
    "star",
    "updatedAt",
    "topic",
    "word",
    "pronunciation",
    "meaning",
    "example",
    "relatedWords",
    "occurrence",
    "score",
    "actions",
  ]);
  const [draggedCol, setDraggedCol] = useState<string | null>(null);

  const debounceRef = useRef<NodeJS.Timeout | null>(null);

  const fetchVocabs = useCallback(
    async (
      pageNum = 1,
      currentFilters = filters,
      currentSort = sortConfig,
      starred = showStarredOnly
    ) => {
      if (!token) return;
      setLoading(true);
      try {
        const params: any = {
          page: pageNum,
          limit: 20,
          ...currentFilters,
          sortBy: currentSort.key,
          sortOrder: currentSort.direction,
        };
        if (starred) params.isStarred = "true";
        const res = await api.get("/vocabulary", {
          headers: { Authorization: `Bearer ${token}` },
          params: params,
        });
        setVocabs(res.data.data);
        setTotalPages(res.data.meta.lastPage);
        setPage(res.data.meta.page);
      } catch (error) {
        console.error("Fetch error:", error);
      } finally {
        setLoading(false);
      }
    },
    [token, filters, sortConfig, showStarredOnly]
  );

  useEffect(() => {
    fetchVocabs();
  }, [fetchVocabs]);
  
  const handleFilterChange = (field: keyof FilterState, value: string) => {
    const newFilters = { ...filters, [field]: value };
    setFilters(newFilters);
    if (debounceRef.current) clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(
      () => fetchVocabs(1, newFilters, sortConfig),
      500
    );
  };

  const handleSort = (key: string) => {
    let direction: "asc" | "desc" = "asc";
    if (sortConfig.key === key && sortConfig.direction === "asc")
      direction = "desc";
    const newSortConfig = { key, direction };
    setSortConfig(newSortConfig);
    fetchVocabs(1, filters, newSortConfig);
  };

  const handleToggleStar = async (
    id: string,
    currentStatus: boolean,
    e?: React.MouseEvent
  ) => {
    if (e) e.stopPropagation();
    
    // Optimistic update
    const toggleFunc = (list: VocabItem[]) =>
    list.map((item) =>
      item.id === id ? { ...item, isStarred: !currentStatus } : item
    );
    setVocabs(toggleFunc);

    try {
      await api.patch(
        `/vocabulary/${id}`,
        { isStarred: !currentStatus },
        { headers: { Authorization: `Bearer ${token}` } }
      );
    } catch (error) {
      console.error("Failed to star", error);
      // Revert on failure
      setVocabs((prev) => 
        prev.map((item) =>
          item.id === id ? { ...item, isStarred: currentStatus } : item
        )
      );
    }
  };

  const triggerInteraction = async (vocab: VocabItem) => {
    try {
      const newOccurrence = (vocab.occurrence || 0) + 1;
      const newTime = new Date().toISOString();
      
      // Optimistic update
      setVocabs((prev) =>
        prev.map((v) =>
          v.id === vocab.id
            ? { ...v, occurrence: newOccurrence, updatedAt: newTime }
            : v
        )
      );
      
      await api.patch(
        `/vocabulary/${vocab.id}`,
        { occurrence: newOccurrence },
        { headers: { Authorization: `Bearer ${token}` } }
      );
    } catch (e) {
      console.error("Interaction update failed", e);
       // Revert on failure
       setVocabs((prev) =>
       prev.map((v) =>
         v.id === vocab.id
           ? { ...v, occurrence: vocab.occurrence, updatedAt: vocab.updatedAt }
           : v
       )
     );
    }
  };

  const handleDragStart = (e: React.DragEvent, colId: string) => {
    setDraggedCol(colId);
    e.dataTransfer.effectAllowed = "move";
  };

  const handleDragOver = (e: React.DragEvent, colId: string) => {
    e.preventDefault();
    if (!draggedCol || draggedCol === colId) return;
    const newOrder = [...columnOrder];
    const draggedIdx = newOrder.indexOf(draggedCol);
    const targetIdx = newOrder.indexOf(colId);
    if (draggedIdx !== -1 && targetIdx !== -1) {
      newOrder.splice(draggedIdx, 1);
      newOrder.splice(targetIdx, 0, draggedCol);
      setColumnOrder(newOrder);
    }
  };
  
  const handleDragEnd = () => {
    setDraggedCol(null);
  };

  return {
    vocabs,
    loading,
    page,
    setPage,
    totalPages,
    showStarredOnly,
    setShowStarredOnly,
    filters,
    sortConfig,
    columnOrder,
    draggedCol,
    fetchVocabs,
    handleFilterChange,
    handleSort,
    handleToggleStar,
    triggerInteraction,
    handleDragStart,
    handleDragOver,
    handleDragEnd,
  };
};

export default useVocabData;



================================================
FILE: apps/frontend/hooks/vocabulary/useVocabModals.ts
================================================

import { useState, useRef } from "react";
import api from "@/lib/api"; // Import api for backend calls
import axios from "axios"; // Keep for external APIs (DictionaryAPI, Translate)
import { VocabItem } from "./useVocabData";

export interface VocabFormData {
  word: string;
  meaning: string;
  example: string;
  topic: string;
  partOfSpeech: string;
  relatedWords: string;
  pronunciation: string;
}

const useVocabModals = (
  token: string | null,
  fetchVocabs: (page?: number) => void
) => {
  const [selectedVocab, setSelectedVocab] = useState<VocabItem | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isAutoFilling, setIsAutoFilling] = useState(false);
  const [formData, setFormData] = useState<VocabFormData>({
    word: "",
    meaning: "",
    example: "",
    topic: "",
    partOfSpeech: "",
    relatedWords: "",
    pronunciation: "",
  });

  const fileInputRef = useRef<HTMLInputElement>(null);
  const [isUploading, setIsUploading] = useState(false);

  const triggerInteraction = async (vocab: VocabItem) => {
    try {
      const newOccurrence = (vocab.occurrence || 0) + 1;
      await api.patch(
        `/vocabulary/${vocab.id}`,
        { occurrence: newOccurrence },
        { headers: { Authorization: `Bearer ${token}` } }
      );
    } catch (e) {
      console.error("Interaction update failed", e);
    }
  };

  const handleRowClick = (vocab: VocabItem) => {
    setSelectedVocab(vocab);
    setFormData({
      word: vocab.word,
      meaning: vocab.meaning || "",
      example: vocab.example || "",
      topic: vocab.topic || "",
      partOfSpeech: vocab.partOfSpeech || "",
      relatedWords: vocab.relatedWords || "",
      pronunciation: vocab.pronunciation || "",
    });
    setIsModalOpen(true);
    triggerInteraction(vocab);
  };

  const fetchAutoFillData = async (word: string) => {
    if (!word) return null;
    setIsAutoFilling(true);
    try {
      const dictPromise = axios
        .get(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
        .catch(() => null);

      const translatePromise = axios
        .get(
          `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&q=${encodeURIComponent(
            word
          )}`
        )
        .catch(() => null);

      const [dictRes, transRes] = await Promise.all([
        dictPromise,
        translatePromise,
      ]);

      let newData: Partial<VocabFormData> = { word: word };

      if (dictRes && dictRes.data && dictRes.data[0]) {
        const entry = dictRes.data[0];
        if (entry.phonetic) newData.pronunciation = entry.phonetic;
        else if (entry.phonetics && entry.phonetics.length > 0) {
          const p = entry.phonetics.find((x: any) => x.text && x.audio);
          newData.pronunciation = p ? p.text : entry.phonetics[0].text;
        }
        if (entry.meanings && entry.meanings.length > 0) {
          const meaning = entry.meanings[0];
          newData.partOfSpeech = meaning.partOfSpeech;
          if (meaning.definitions) {
            const defWithExample = meaning.definitions.find(
              (d: any) => d.example
            );
            if (defWithExample) newData.example = defWithExample.example;
          }
        }
      }

      if (transRes && transRes.data && transRes.data[0]) {
        const translatedText = transRes.data[0]
          .map((item: any) => item[0])
          .join("");
        newData.meaning = translatedText;
      }
      return newData;
    } catch (error) {
      console.error("Auto-fill error:", error);
      return null;
    } finally {
      setIsAutoFilling(false);
    }
  };

  const handleOpenCreateModal = async (initialWord = "") => {
    setSelectedVocab(null);
    setIsModalOpen(true);
    setFormData({
      word: initialWord,
      meaning: "",
      example: "",
      topic: "",
      partOfSpeech: "",
      relatedWords: "",
      pronunciation: "",
    });
    if (initialWord) {
      const autoData = await fetchAutoFillData(initialWord);
      if (autoData) {
        setFormData((prev) => ({ ...prev, ...autoData }));
      }
    }
  };

  const handleSave = async () => {
    if (!token || !formData.word) {
      alert("Word is required!");
      return;
    }
    try {
      if (selectedVocab) {
        await api.patch(
          `/vocabulary/${selectedVocab.id}`,
          formData,
          { headers: { Authorization: `Bearer ${token}` } }
        );
      } else {
        await api.post(
          "/vocabulary",
          { ...formData, isStarred: false },
          { headers: { Authorization: `Bearer ${token}` } }
        );
      }
      setIsModalOpen(false);
      fetchVocabs();
    } catch (error) {
      console.error("Save failed", error);
      alert("Failed to save.");
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Delete this word?")) return;
    try {
      await api.delete(`/vocabulary/${id}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      fetchVocabs();
      setIsModalOpen(false);
    } catch (e) {
      alert("Failed");
    }
  };

  const handleFileChange = async (
    event: React.ChangeEvent<HTMLInputElement>
  ) => {
    const file = event.target.files?.[0];
    if (!file || !token) return;
    const formData = new FormData();
    formData.append("file", file);
    try {
      setIsUploading(true);
      await api.post(
        "/vocabulary/import/csv",
        formData,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "multipart/form-data",
          },
        }
      );
      alert("Import success!");
      fetchVocabs(1);
    } catch (error) {
      alert("Import failed!");
    } finally {
      setIsUploading(false);
      if (fileInputRef.current) fileInputRef.current.value = "";
    }
  };

  return {
    selectedVocab,
    isModalOpen,
    setIsModalOpen,
    isAutoFilling,
    formData,
    setFormData,
    fileInputRef,
    isUploading,
    handleRowClick,
    handleOpenCreateModal,
    handleSave,
    handleDelete,
    handleFileChange,
    fetchAutoFillData,
  };
};

export default useVocabModals;



================================================
FILE: apps/frontend/hooks/vocabulary/.gitkeep
================================================
[Empty file]


================================================
FILE: apps/frontend/lib/api-metrics.ts
================================================
// apps/frontend/lib/api-metrics.ts
// H√†m d√πng ƒë·ªÉ ƒëo l∆∞·ªùng hi·ªáu su·∫•t API call

export const measureApiCall = async (
  apiName: string,
  apiCallFn: () => Promise<any>
) => {
  const t1_start = performance.now(); // üïí B·∫Øt ƒë·∫ßu T1

  try {
    const response = await apiCallFn();

    const t1_end = performance.now(); // üèÅ K·∫øt th√∫c T1
    const t1_total_ms = (t1_end - t1_start).toFixed(2);

    // L·∫•y T2 t·ª´ Header m√† Backend g·ª≠i v·ªÅ
    // L∆∞u √Ω: T√™n header trong axios th∆∞·ªùng vi·∫øt th∆∞·ªùng h·∫øt
    const t2_server_ms = parseFloat(response.headers['x-server-time'] || '0');

    // T√≠nh ƒë·ªô tr·ªÖ m·∫°ng (Network Latency)
    const network_latency = (parseFloat(t1_total_ms) - t2_server_ms).toFixed(2);

    console.group(`üìä METRICS: ${apiName}`);
    console.log(`1Ô∏è‚É£ T·ªïng th·ªùi gian (T1): ${t1_total_ms} ms`);
    console.log(`2Ô∏è‚É£ Server x·ª≠ l√Ω (T2):   ${t2_server_ms} ms`);
    console.log(`3Ô∏è‚É£ ƒê·ªô tr·ªÖ m·∫°ng (Net):   ${network_latency} ms`);

    // K·∫æT LU·∫¨N T·ª∞ ƒê·ªòNG
    if (parseFloat(network_latency) > 1000) {
      console.warn('üëâ CH·∫¨M DO M·∫†NG (Internet/Wifi)');
    } else if (t2_server_ms > 500) {
      console.warn('üëâ CH·∫¨M DO BACKEND (Code/DB)');
    } else {
      console.log('‚úÖ T·ªëc ƒë·ªô ·ªïn ƒë·ªãnh');
    }
    console.groupEnd();

    return response;
  } catch (error) {
    console.error(`‚ùå API Error: ${apiName}`, error);
    throw error;
  }
};



================================================
FILE: apps/frontend/lib/api.ts
================================================
// apps/frontend/lib/api.ts
import axios from 'axios';

// 1. L·∫•y ƒë·ªãa ch·ªâ t·ª´ bi·∫øn m√¥i tr∆∞·ªùng (∆Øu ti√™n) ho·∫∑c m·∫∑c ƒë·ªãnh v·ªÅ Localhost
export const API_URL = process.env.NEXT_PUBLIC_API_URL || 'https://localhost:5001';

// 2. T·∫°o m·ªôt instance axios d√πng chung cho c·∫£ app
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true, // T·ª± ƒë·ªông g·ª≠i cookie (token) ƒëi k√®m
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;

