Directory structure:
‚îî‚îÄ‚îÄ extension/
    ‚îú‚îÄ‚îÄ background.js
    ‚îú‚îÄ‚îÄ config.js
    ‚îú‚îÄ‚îÄ content.js
    ‚îú‚îÄ‚îÄ manifest.json
    ‚îú‚îÄ‚îÄ popup.css
    ‚îú‚îÄ‚îÄ popup.html
    ‚îú‚îÄ‚îÄ popup.js
    ‚îî‚îÄ‚îÄ content-scripts/
        ‚îú‚îÄ‚îÄ lookup-main.js
        ‚îú‚îÄ‚îÄ lookup-services.js
        ‚îú‚îÄ‚îÄ lookup-ui.js
        ‚îú‚îÄ‚îÄ main.js
        ‚îú‚îÄ‚îÄ messager.js
        ‚îú‚îÄ‚îÄ metrics.js
        ‚îú‚îÄ‚îÄ native-core.js
        ‚îú‚îÄ‚îÄ native-ui.js
        ‚îú‚îÄ‚îÄ shortcuts.js
        ‚îî‚îÄ‚îÄ ui.js

================================================
FILE: background.js
================================================
// apps/extension/background.js

chrome.runtime.onInstalled.addListener(() => {
  console.log("‚úÖ Extension Installed/Reloaded");
  createNextAlarm();
});

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === "vocab_review") {
    console.log(
      "‚è∞ Alarm Triggered: vocab_review at " + new Date().toLocaleTimeString()
    );

    // 1. G·ª≠i tin nh·∫Øn xu·ªëng Tab
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs.length === 0) {
        console.log("‚ö†Ô∏è No active tab found.");
        return;
      }

      console.log(`üì° Sending message to Tab ID: ${tabs[0].id}`);
      chrome.tabs
        .sendMessage(tabs[0].id, { action: "SHOW_FLASHCARD" })
        .catch((err) =>
          console.log(
            "‚ùå Could not send message (Content Script not ready?):",
            err
          )
        );
    });

    // 2. T·∫°o Alarm ti·∫øp theo (Recursive)
    createNextAlarm();
  }
});

function createNextAlarm() {
  // Setup alarm ch·∫°y sau 12 gi√¢y
  chrome.alarms.create("vocab_review", { when: Date.now() + 300000 });
  console.log("‚è≥ Next alarm scheduled in 12s...");
}



================================================
FILE: config.js
================================================
// apps/extension/config.js

// üëá C√îNG T·∫ÆC T·ªîNG: ƒê·ªïi true/false ·ªü ƒë√¢y
const IS_DEV_MODE = false;

const APP_CONFIG = {
  // Backend
  API_URL: IS_DEV_MODE
    ? "https://localhost:5001"
    : "https://vocab-backend-aveq.onrender.com",

  // Frontend
  FRONTEND_URL: IS_DEV_MODE
    ? "https://localhost:3001"
    : "https://c2025-12-09-full-app-english.vercel.app",
};

// Log ra ƒë·ªÉ bi·∫øt ƒëang ch·∫°y m√¥i tr∆∞·ªùng n√†o
console.log(
  `üöÄ Extension Mode: ${IS_DEV_MODE ? "DEV (Local)" : "PROD (Server)"}`
);



================================================
FILE: content.js
================================================
[Binary file]


================================================
FILE: manifest.json
================================================
{
  "manifest_version": 3,
  "name": "Vocabulary Coach & App Connector",
  "version": "2.0",
  "description": "Full App Integration: Iframe, TTS, Azure Speech & Flashcards",
  "icons": {
    "16": "icons/icon16.png",
    "32": "icons/icon32.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "permissions": ["storage", "microphone", "alarms"],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "32": "icons/icon32.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": [
        "config.js",
        "content-scripts/lookup-services.js",
        "content-scripts/lookup-ui.js",
        "content-scripts/native-ui.js",
        "content-scripts/native-core.js",
        "content-scripts/lookup-main.js"
      ],
      "css": ["popup.css"]
    }
  ],
  "host_permissions": [
    "https://translate.google.com/*",
    "https://translate.googleapis.com/*",
    "https://commons.wikimedia.org/*",
    "https://api.duckduckgo.com/*",
    "https://www.googleapis.com/*",
    "https://api.unsplash.com/*",
    "https://*.cognitiveservices.azure.com/*",
    "https://*.onrender.com/*",
    "http://localhost:3000/*",
    "https://localhost:3001/*",
    "http://localhost:5001/*"
  ],
  "web_accessible_resources": [
    {
      "resources": ["popup.css"],
      "matches": ["<all_urls>"]
    }
  ]
}



================================================
FILE: popup.css
================================================
:root {
  --primary-color: #58cc02; /* Xanh l√° ki·ªÉu Duolingo/Elsa */
  --primary-dark: #46a302;
  --accent-color: #1cb0f6; /* Xanh d∆∞∆°ng */
  --text-primary: #3c3c3c;
  --text-secondary: #777777;
  --bg-color: #ffffff;
  --card-bg: #f7f7f7;
  --danger-color: #ff4b4b;
  --warning-color: #ffc800;
  --shadow-soft: 0 10px 40px -10px rgba(0, 0, 0, 0.15);
  --border-radius: 16px;
}

/* Reset & Base */
* {
  box-sizing: border-box;
}

#tts-popup {
  position: absolute;
  background: var(--bg-color);
  color: var(--text-primary);
  padding: 0;
  border-radius: var(--border-radius);
  box-shadow: var(--shadow-soft);
  z-index: 999999;
  min-width: 320px;
  max-width: 400px;
  font-family: "Nunito", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    sans-serif; /* Font tr√≤n tr·ªãa hi·ªán ƒë·∫°i */
  border: 1px solid rgba(0, 0, 0, 0.08);
  overflow: hidden;
  animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes popIn {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(10px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

/* --- Header --- */
.tts-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  background: #fff;
  border-bottom: 1px solid #f0f0f0;
  cursor: move;
  user-select: none;
}

.sound-btn,
.close-btn {
  background: transparent;
  border: none;
  color: #bbbbbb;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  padding: 0;
}

.sound-btn:hover {
  background: #f0f8ff;
  color: var(--accent-color);
}

.close-btn:hover {
  background: #fff0f0;
  color: var(--danger-color);
}

/* --- Content Area --- */
.tts-content {
  padding: 0 20px 20px 20px;
  max-height: 500px;
  overflow-y: auto;
}

/* --- Images Grid --- */
.tts-images-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin: 15px 0;
  width: 100%;
}

.tts-image {
  width: 100%;
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 1;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
  transition: transform 0.2s;
}

.tts-image:hover {
  transform: scale(1.05);
}

.tts-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* --- Phonetic & Meaning --- */
.tts-phonetic {
  display: flex;
  gap: 15px;
  margin-bottom: 15px;
  justify-content: center;
}

.phonetic-item {
  display: flex;
  align-items: center;
  font-size: 14px;
  color: var(--text-secondary);
  background: #f5f5f5;
  padding: 4px 10px;
  border-radius: 20px;
}

.phonetic-item .flag {
  margin-right: 6px;
  font-size: 16px;
}

.phonetic-text {
  font-family: "Lucida Console", monospace;
  font-weight: 600;
  color: var(--text-primary);
}

.tts-meaning {
  font-size: 16px;
  color: var(--text-primary);
  line-height: 1.6;
  text-align: center;
  font-weight: 500;
  margin-bottom: 10px;
}

/* --- Actions (Mic Button) --- */
.tts-actions {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px 0 20px 0;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0), #fff 20%);
}

.mic-btn {
  background: var(--accent-color); /* M√†u xanh ch·ªß ƒë·∫°o */
  border: none;
  box-shadow: 0 4px 0 #118ec7; /* Hi·ªáu ·ª©ng n√∫t b·∫•m 3D */
  color: white;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.1s;
  margin-bottom: 10px;
}

.mic-btn:hover {
  filter: brightness(1.1);
  transform: translateY(-2px);
  box-shadow: 0 6px 0 #118ec7;
}

.mic-btn:active {
  transform: translateY(4px);
  box-shadow: 0 0 0 #118ec7;
}

.mic-btn.recording {
  background: var(--danger-color);
  box-shadow: 0 4px 0 #d63e3e;
  animation: pulse-red 1.5s infinite;
}

@keyframes pulse-red {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 75, 75, 0.4);
  }
  70% {
    box-shadow: 0 0 0 15px rgba(255, 75, 75, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 75, 75, 0);
  }
}

/* --- Assessment Result (ELSA Style) --- */
#assessment-result {
  width: 100%;
}

.assessment-box {
  background: #ffffff;
  padding: 15px;
  text-align: center;
  animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* V√≤ng tr√≤n ƒëi·ªÉm s·ªë */
.total-score-circle {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  border: 5px solid #eee;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: 800;
  margin: 0 auto 5px auto;
  background: #fff;
  color: var(--text-primary);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
}

/* Text Word ch√≠nh */
.word-text {
  font-size: 32px;
  font-weight: 800;
  margin: 10px 0 5px 0;
  color: #2b3b4e; /* M√†u xanh ƒë·∫≠m sang tr·ªçng */
  letter-spacing: -0.5px;
}

/* Container Phonemes */
.analyzed-content {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-top: 5px;
}

.word-block {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.phoneme-row {
  display: flex;
  gap: 4px;
  padding: 4px;
  border-radius: 12px;
  background: transparent;
}

.phoneme-char {
  font-family: "Roboto Mono", monospace;
  font-size: 16px;
  font-weight: 600;
  padding: 6px 10px;
  border-radius: 8px;
  transition: all 0.2s;
  min-width: 32px;
  text-align: center;
}

/* M√†u s·∫Øc ƒëi·ªÉm s·ªë (Color Grading) */
/* Xanh (Excellent) */
.p-perfect {
  background-color: #dff6dd;
  color: #2e7d32;
  border: 1px solid #c8e6c9;
}

/* Xanh nh·∫°t (Good) */
.p-good {
  background-color: #f1f8e9;
  color: #558b2f;
  border: 1px solid #dcedc8;
}

/* V√†ng (Fair) */
.p-fair {
  background-color: #fff8e1;
  color: #fbc02d;
  border: 1px solid #ffecb3;
}

/* ƒê·ªè (Bad) */
.p-bad {
  background-color: #ffebee;
  color: #c62828;
  border: 1px solid #ffcdd2;
  position: relative;
}

/* Loading & Info */
.tts-loading,
.tts-info {
  font-size: 14px;
  color: #999;
  text-align: center;
  padding: 10px;
}
/* --- Flashcard Passive Learning --- */
#vocab-flashcard {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 280px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  z-index: 2147483647; /* Max z-index */
  font-family: "Nunito", sans-serif;
  border: 1px solid rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.flashcard-slide-in {
  animation: slideInRight 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

.flashcard-slide-out {
  animation: slideOutRight 0.5s forwards;
}

@keyframes slideInRight {
  from {
    transform: translateX(120%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(120%);
    opacity: 0;
  }
}

/* Style cho Context Box trong Popup ch√≠nh */
.context-box {
  margin-top: 10px;
  padding: 10px;
  background: #f8f9fa;
  border-left: 3px solid var(--accent-color);
  border-radius: 4px;
  font-size: 13px;
  color: var(--text-secondary);
  text-align: left;
  line-height: 1.4;
}
/* --- Dictionary Styles --- */
.dict-container {
  text-align: left;
  margin: 10px 0;
  padding: 0 10px;
}

.dict-row {
  margin-bottom: 8px;
  line-height: 1.5;
  display: flex;
  align-items: baseline;
}

.dict-pos {
  font-size: 11px;
  text-transform: uppercase;
  color: #888;
  background: #eee;
  padding: 2px 6px;
  border-radius: 4px;
  margin-right: 8px;
  font-weight: 700;
  min-width: 45px;
  text-align: center;
}

.dict-meanings {
  font-size: 15px;
  color: #333;
  font-weight: 500;
}
/* --- New: Primary Meaning Style --- */
.primary-meaning {
  font-size: 18px; /* To h∆°n text th∆∞·ªùng */
  color: var(--primary-dark); /* M√†u xanh ƒë·∫≠m cho d·ªÖ nh√¨n */
  font-weight: 700;
  text-align: center;
  margin: 5px 0 10px 0;
  padding-bottom: 8px;
  border-bottom: 1px dashed #eee; /* G·∫°ch ch√¢n nh·∫π ngƒÉn c√°ch v·ªõi dict */
  line-height: 1.4;
}
/* --- Assessment Action Buttons --- */
.assessment-actions {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
}

.action-btn-small {
  border: none;
  border-radius: 20px;
  padding: 6px 14px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.btn-user-audio {
  background: #ffffff;
  color: #d32f2f; /* M√†u ƒë·ªè ghi √¢m */
}
.btn-user-audio:hover {
  background: #ffebee;
}

.btn-ref-audio {
  background: #ffffff;
  color: #1976d2; /* M√†u xanh Azure */
}
.btn-ref-audio:hover {
  background: #e3f2fd;
}
/* --- FULL FORM MODAL STYLES (Ported from Frontend) --- */
.vocab-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(4px);
  z-index: 2147483650; /* Cao h∆°n c·∫£ Search Wrapper */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  animation: fadeIn 0.2s ease-out;
}

.vocab-modal-content {
  background: #fff;
  width: 100%;
  max-width: 650px;
  max-height: 90vh;
  border-radius: 16px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
    0 10px 10px -5px rgba(0, 0, 0, 0.04);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: scaleIn 0.2s ease-out;
}

@keyframes scaleIn {
  from {
    transform: scale(0.95);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.vocab-modal-header {
  background: #4f46e5; /* Indigo-600 */
  padding: 24px;
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.vocab-modal-title {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  opacity: 0.8;
  margin-bottom: 8px;
}

.vocab-input-large {
  background: transparent;
  font-size: 36px;
  font-weight: 700;
  color: white;
  border: none;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  width: 100%;
  outline: none;
  padding-bottom: 4px;
  transition: border-color 0.2s;
}
.vocab-input-large:focus {
  border-color: white;
}
.vocab-input-large::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.vocab-modal-body {
  padding: 24px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.vocab-grid-2 {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

.vocab-label {
  display: block;
  font-size: 12px;
  font-weight: 700;
  color: #9ca3af; /* Gray-400 */
  text-transform: uppercase;
  margin-bottom: 4px;
}

.vocab-input-field,
.vocab-textarea-field,
.vocab-select-field {
  width: 100%;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 14px;
  outline: none;
  transition: box-shadow 0.2s, border-color 0.2s;
}

.vocab-input-field:focus,
.vocab-textarea-field:focus,
.vocab-select-field:focus {
  border-color: #6366f1;
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
}

.vocab-textarea-field {
  min-height: 80px;
  font-family: inherit;
  resize: vertical;
}

.vocab-modal-footer {
  background: #f9fafb; /* Gray-50 */
  padding: 16px;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.btn-cancel {
  background: transparent;
  color: #4b5563;
  padding: 8px 20px;
  border-radius: 8px;
  font-weight: 500;
  border: none;
  cursor: pointer;
}
.btn-cancel:hover {
  background: #e5e7eb;
}

.btn-save {
  background: #4f46e5;
  color: white;
  padding: 8px 24px;
  border-radius: 8px;
  font-weight: 700;
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  transition: transform 0.1s;
}
.btn-save:hover {
  background: #4338ca;
}
.btn-save:active {
  transform: scale(0.98);
}

/* Auto-fill Animation */
.autofill-loading {
  font-size: 12px;
  color: #bfdbfe;
  margin-left: 10px;
  animation: pulse 1.5s infinite;
}
/* =========================================
   NATIVE SEARCH BAR STYLES (QUICK SEARCH)
   ========================================= */

/* Root container ƒë·ªÉ c√¥ l·∫≠p style */
#vocab-root {
  all: initial; /* Reset style ƒë·ªÉ kh√¥ng b·ªã ·∫£nh h∆∞·ªüng b·ªüi trang web g·ªëc */
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

/* Wrapper: Trong su·ªët ho√†n to√†n & Click xuy√™n qua ƒë∆∞·ª£c */
#vocab-search-wrapper {
  position: fixed;
  inset: 0;
  background: transparent !important; /* Kh√¥ng m√†u n·ªÅn */
  backdrop-filter: none !important; /* Kh√¥ng l√†m m·ªù */
  z-index: 2147483648;
  display: none;
  pointer-events: none; /* QUAN TR·ªåNG: Cho ph√©p click v√†o trang web b√™n d∆∞·ªõi */
}

/* Modal: Hi·ªán r√µ & Nh·∫≠n s·ª± ki·ªán chu·ªôt */
#vocab-search-modal {
  pointer-events: auto;
  background: white;
  width: 600px;
  max-width: 90vw;
  border-radius: 12px;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 20px 50px -5px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(0, 0, 0, 0.05);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 15%;
  left: 50%;
  transform: translateX(-50%);
  transition: opacity 0.2s ease-out;

  /* üëá QUAN TR·ªåNG: Cho ph√©p b√¥i ƒëen vƒÉn b·∫£n trong to√†n b·ªô Modal */
  user-select: text !important;
  -webkit-user-select: text !important;
}

/* Header: Tay n·∫Øm k√©o th·∫£ */
.vocab-header {
  padding: 24px 28px;
  border-bottom: 1px solid #f0f0f0;
  display: flex;
  align-items: center;

  /* üëá Ch·ªâ ch·∫∑n b√¥i ƒëen ·ªü v√πng Header (tr·ª´ √¥ input) ƒë·ªÉ k√©o th·∫£ m∆∞·ª£t */
  cursor: grab;
  user-select: none !important;
  -webkit-user-select: none !important;
  background: #fff;
}

.vocab-header:active {
  cursor: grabbing; /* B√†n tay n·∫Øm l·∫°i khi k√©o */
  background: #fafafa;
}

.vocab-input-affix {
  display: flex;
  align-items: center;
  width: 100%;
  gap: 10px;
  color: #999;
}

.vocab-search-input {
  flex: 1;
  border: none;
  outline: none;
  font-size: 20px;
  font-weight: 300;
  color: #333;
  background: transparent;

  /* üëá C·ª±c k·ª≥ quan tr·ªçng ƒë·ªÉ Paste/Copy ho·∫°t ƒë·ªông */
  cursor: text;
  user-select: text !important;
  -webkit-user-select: text !important;
}

.vocab-search-input::placeholder {
  color: #ccc;
}

/* --- BODY LIST STYLES --- */
.vocab-body {
  max-height: 450px;
  overflow-y: auto;
  background: #fff;
  padding: 8px 0;
}

/* Item Row */
.vocab-list-item {
  padding: 12px 24px; /* TƒÉng padding cho tho√°ng */
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  transition: background 0.1s ease;
  border-left: 4px solid transparent;
}

.vocab-list-item:hover {
  background: #f5f7fa;
  border-left-color: #1890ff;
}

/* Ri√™ng ph·∫ßn Create New th√¨ highlight nh·∫π */
.vocab-create-item {
  background: #f6ffed; /* Xanh l√° si√™u nh·∫°t */
}
.vocab-create-item:hover {
  background: #d9f7be;
  border-left-color: #52c41a;
}

/* Typography */
.vocab-word-text {
  font-size: 18px;
  font-weight: 700;
  color: #333;
}

.vocab-pronun {
  font-family: "Lucida Console", monospace;
  font-size: 13px;
  color: #888;
  margin-left: 8px;
}

.vocab-word-meta {
  font-size: 14px;
  color: #666;
  margin-top: 4px;
  line-height: 1.4;
}

/* Tags */
.vocab-tag {
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 4px;
  background: #eee;
  color: #666;
  font-weight: 700;
  text-transform: uppercase;
  margin-left: 8px;
  border: 1px solid #e0e0e0;
}
.tag-green {
  background: #f6ffed;
  color: #52c41a;
  border-color: #b7eb8f;
}
.tag-blue {
  background: #e6f7ff;
  color: #1890ff;
  border-color: #91d5ff;
}

/* --- ACTION BUTTONS (ROUND STYLE - GI·ªêNG SHIFT) --- */
.vocab-actions {
  display: flex;
  gap: 10px;
  opacity: 0; /* M·∫∑c ƒë·ªãnh ·∫©n */
  transform: translateX(10px);
  transition: all 0.2s ease;
}

/* Hover v√†o d√≤ng th√¨ hi·ªán n√∫t */
.vocab-list-item:hover .vocab-actions {
  opacity: 1;
  transform: translateX(0);
}

/* N√∫t b·∫•m tr√≤n xoe */
.action-btn-circle {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid #eee;
  background: white;
  color: #999;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;

  /* Quan tr·ªçng ƒë·ªÉ click ƒë∆∞·ª£c */
  pointer-events: auto !important;
  user-select: none;
}

.action-btn-circle svg {
  width: 20px;
  height: 20px;
}

/* Hover effects */
.action-btn-circle:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.btn-listen:hover {
  color: #1890ff;
  border-color: #1890ff;
  background: #e6f7ff;
}
.btn-mic:hover {
  color: #52c41a;
  border-color: #52c41a;
  background: #f6ffed;
}
.btn-edit:hover {
  color: #faad14;
  border-color: #faad14;
  background: #fffbe6;
}
.btn-sound:hover {
  color: #1890ff;
  border-color: #1890ff;
  background: #e6f7ff;
}

/* Lu√¥n hi·ªán n√∫t ·ªü d√≤ng Create New ƒë·ªÉ user bi·∫øt m√† b·∫•m */
.vocab-create-item .vocab-actions {
  opacity: 1;
  transform: none;
}
/* --- ASSESSMENT MODAL STYLES (ELSA STYLE) --- */
.assess-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(4px);
  z-index: 2147483660; /* Cao nh·∫•t */
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.2s ease-out;
}

.assess-modal-content {
  background: white;
  width: 100%;
  max-width: 450px;
  border-radius: 24px;
  padding: 30px;
  text-align: center;
  position: relative;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  animation: scaleIn 0.2s ease-out;
}

.assess-word {
  font-size: 32px;
  font-weight: 800;
  color: #1f2937;
  margin-bottom: 5px;
}

.assess-pronun {
  font-family: monospace;
  color: #6b7280;
  font-size: 18px;
  margin-bottom: 20px;
}

/* Score Circle Animation */
.score-circle-container {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 8px solid #f3f4f6;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 auto 25px auto;
  font-size: 40px;
  font-weight: 800;
  transition: all 0.5s ease;
}

/* Phonemes Styles */
.phoneme-list {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin-bottom: 25px;
  background: #f9fafb;
  padding: 15px;
  border-radius: 16px;
}

.phoneme-badge {
  font-family: monospace;
  font-size: 14px;
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 600;
}

.bg-green {
  background: #dcfce7;
  color: #166534;
}
.bg-yellow {
  background: #fef9c3;
  color: #854d0e;
}
.bg-red {
  background: #fee2e2;
  color: #991b1b;
}

/* Control Buttons */
.assess-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
}

.btn-control {
  border: none;
  cursor: pointer;
  transition: transform 0.1s;
  display: flex;
  align-items: center;
  justify-content: center;
}
.btn-control:active {
  transform: scale(0.95);
}

.btn-speaker {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: #f3f4f6;
  color: #4f46e5;
}

.btn-record {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  background: #4f46e5;
  color: white;
  box-shadow: 0 10px 15px -3px rgba(79, 70, 229, 0.3);
}
.btn-record.recording {
  background: #ef4444;
  animation: pulse 1.5s infinite;
}

.btn-playback {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: #ecfdf5;
  color: #059669;
}
.btn-playback:disabled {
  background: #f3f4f6;
  color: #d1d5db;
  cursor: not-allowed;
}

.assess-status {
  margin-top: 15px;
  font-size: 14px;
  color: #6b7280;
  min-height: 20px;
}

/* Header Input (Word) - Chuy·ªÉn th√†nh Textarea style */
.vocab-input-large {
  background: transparent;
  font-size: 32px; /* Gi·∫£m nh·∫π font size ƒë·ªÉ ƒë·ª° b·ªã tr√†n */
  font-weight: 700;
  color: white;
  border: none;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  width: 100%;
  outline: none;
  padding-bottom: 4px;
  transition: border-color 0.2s;

  /* Fix cho textarea */
  resize: none; /* Kh√¥ng cho user k√©o th·ªß c√¥ng */
  overflow: hidden; /* ·∫®n thanh cu·ªôn x·∫•u */
  font-family: inherit;
  line-height: 1.3;
  min-height: 50px;
  display: block;
}

.vocab-input-large:focus {
  border-color: white;
}

.vocab-input-large::placeholder {
  color: rgba(255, 255, 255, 0.5);
}



================================================
FILE: popup.html
================================================
<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Edge TTS Reader - C√†i ƒë·∫∑t</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        width: 450px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .container {
        padding: 20px;
      }

      h2 {
        font-size: 20px;
        margin-bottom: 20px;
        font-weight: 600;
      }

      .guide-section {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-size: 13px;
        line-height: 1.6;
        backdrop-filter: blur(10px);
      }

      .guide-section h3 {
        font-size: 14px;
        margin-bottom: 10px;
        font-weight: 600;
      }

      .guide-section ol {
        padding-left: 20px;
      }

      .guide-section li {
        margin-bottom: 6px;
      }

      .guide-section a {
        color: #fff;
        text-decoration: underline;
      }

      .guide-section a:hover {
        opacity: 0.8;
      }

      .input-group {
        margin-bottom: 15px;
        position: relative;
      }

      .input-group label {
        display: block;
        margin-bottom: 8px;
        font-size: 14px;
        font-weight: 500;
      }

      .input-wrapper {
        position: relative;
        display: flex;
        align-items: center;
      }

      .input-group input {
        flex: 1;
        padding: 10px 40px 10px 12px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 6px;
        font-size: 14px;
        font-family: monospace;
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        transition: all 0.2s;
      }

      .input-group input:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.8);
        background: white;
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
      }

      .toggle-visibility {
        position: absolute;
        right: 8px;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 18px;
        padding: 6px;
        z-index: 10;
        opacity: 0.6;
        transition: opacity 0.2s;
      }

      .toggle-visibility:hover {
        opacity: 1;
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .save-btn {
        background: white;
        color: #667eea;
      }

      .save-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      .test-btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      .test-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
      }

      .status-message {
        margin-top: 15px;
        padding: 12px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        text-align: center;
        display: none;
      }

      .status-message.show {
        display: block;
      }

      .status-message.success {
        background: rgba(76, 175, 80, 0.9);
        color: white;
      }

      .status-message.error {
        background: rgba(244, 67, 54, 0.9);
        color: white;
      }

      .status-message.warning {
        background: rgba(255, 152, 0, 0.9);
        color: white;
      }

      .status-message.loading {
        background: rgba(33, 150, 243, 0.9);
        color: white;
      }

      .info-note {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 6px;
        font-size: 12px;
        margin-top: 15px;
        border-left: 3px solid rgba(255, 255, 255, 0.5);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h2>‚öôÔ∏è C√†i ƒë·∫∑t Google Search API</h2>

      <div class="guide-section">
        <h3>üìå H∆∞·ªõng d·∫´n l·∫•y API Key:</h3>
        <ol>
          <li>
            Truy c·∫≠p
            <a href="https://console.cloud.google.com/" target="_blank"
              >Google Cloud Console</a
            >
          </li>
          <li>T·∫°o d·ª± √°n m·ªõi ho·∫∑c ch·ªçn d·ª± √°n hi·ªán c√≥</li>
          <li>B·∫≠t Custom Search API</li>
          <li>T·∫°o API Key t·ª´ ph·∫ßn "Credentials"</li>
          <li>D√°n API Key v√†o √¥ d∆∞·ªõi</li>
        </ol>
      </div>

      <div class="guide-section">
        <h3>üìå H∆∞·ªõng d·∫´n l·∫•y Search Engine ID:</h3>
        <ol>
          <li>
            Truy c·∫≠p
            <a
              href="https://programmablesearchengine.google.com/"
              target="_blank"
              >Google Programmable Search Engine</a
            >
          </li>
          <li>T·∫°o search engine m·ªõi</li>
          <li>Sao ch√©p Search Engine ID (cx)</li>
          <li>D√°n v√†o √¥ d∆∞·ªõi</li>
        </ol>
      </div>

      <div class="input-group">
        <label>üîë Main Google API Key:</label>
        <div class="input-wrapper">
          <input
            type="password"
            id="api-key-0"
            class="api-key-input"
            placeholder="Key ch√≠nh (b·∫Øt bu·ªôc)"
          />
          <button type="button" class="toggle-visibility">üëÅÔ∏è</button>
        </div>
      </div>

      <div class="input-group">
        <label>üîç Main Search Engine ID (cx):</label>
        <div class="input-wrapper">
          <input
            type="text"
            id="cx-0"
            class="cx-input"
            placeholder="CX ch√≠nh (b·∫Øt bu·ªôc)"
          />
        </div>
      </div>

      <details
        style="
          margin-bottom: 15px;
          background: rgba(0, 0, 0, 0.1);
          border-radius: 6px;
          padding: 10px;
        "
      >
        <summary style="cursor: pointer; font-weight: 600; font-size: 13px">
          ‚ûï M·ªü r·ªông: 4 Backup Keys (D·ª± ph√≤ng)
        </summary>

        <div
          style="
            margin-top: 10px;
            padding-left: 10px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
          "
        >
          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #1:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-1"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 1"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-1"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 1"
            />
          </div>

          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #2:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-2"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 2"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-2"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 2"
            />
          </div>

          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #3:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-3"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 3"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-3"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 3"
            />
          </div>

          <label
            style="
              font-size: 12px;
              margin-top: 10px;
              display: block;
              color: #ddd;
            "
            >Backup Set #4:</label
          >
          <div class="input-wrapper" style="margin-bottom: 5px">
            <input
              type="password"
              id="api-key-4"
              class="api-key-input"
              placeholder="API Key d·ª± ph√≤ng 4"
            />
          </div>
          <div class="input-wrapper">
            <input
              type="text"
              id="cx-4"
              class="cx-input"
              placeholder="CX ID d·ª± ph√≤ng 4"
            />
          </div>
        </div>
      </details>

      <div class="input-group">
        <label for="search-engine-input">Search Engine ID (cx):</label>
        <div class="input-wrapper">
          <input
            type="text"
            id="search-engine-input"
            placeholder="Nh·∫≠p Search Engine ID"
          />
        </div>
      </div>

      <div class="button-group">
        <button class="save-btn" id="save-btn">üíæ L∆∞u</button>
        <button class="test-btn" id="test-btn">üß™ Ki·ªÉm tra</button>
      </div>
      <div
        class="guide-section"
        style="
          margin-top: 20px;
          border-top: 1px solid rgba(255, 255, 255, 0.2);
          padding-top: 15px;
        "
      >
        <h3>üéôÔ∏è C√†i ƒë·∫∑t Azure Speech (Pronunciation):</h3>
        <ol>
          <li>
            T·∫°o resource <strong>Speech Services</strong> tr√™n Azure Portal
          </li>
          <li>L·∫•y Key v√† Region (v√≠ d·ª•: eastus, southeastasia)</li>
        </ol>
      </div>

      <div class="input-group">
        <label for="azure-key-input">Azure Speech Key:</label>
        <div class="input-wrapper">
          <input
            type="password"
            id="azure-key-input"
            placeholder="Nh·∫≠p Azure Subscription Key"
          />
        </div>
      </div>

      <div class="input-group">
        <label for="azure-region-input">Azure Region:</label>
        <div class="input-wrapper">
          <input
            type="text"
            id="azure-region-input"
            placeholder="V√≠ d·ª•: eastus"
          />
        </div>
      </div>
      <div class="status-message" id="status-message"></div>

      <div class="info-note">
        üí° <strong>L∆∞u √Ω:</strong> N·∫øu kh√¥ng c·∫•u h√¨nh Google API, extension s·∫Ω
        t·ª± ƒë·ªông s·ª≠ d·ª•ng Unsplash ƒë·ªÉ l·∫•y h√¨nh ·∫£nh.
      </div>
    </div>

    <script src="popup.js"></script>
  </body>
</html>



================================================
FILE: popup.js
================================================
document.addEventListener("DOMContentLoaded", async () => {
  // Elements cho Azure (Gi·ªØ nguy√™n)
  const azureKeyInput = document.getElementById("azure-key-input");
  const azureRegionInput = document.getElementById("azure-region-input");
  const saveBtn = document.getElementById("save-btn");
  const testBtn = document.getElementById("test-btn");

  // X·ª≠ l√Ω n√∫t m·∫Øt th·∫ßn (Toggle Visibility) cho t·∫•t c·∫£ input password
  document.querySelectorAll(".toggle-visibility").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      // T√¨m input c√πng c·∫•p v·ªõi n√∫t b·∫•m
      const input = e.target.parentElement.querySelector("input");
      if (input) {
        input.type = input.type === "password" ? "text" : "password";
      }
    });
  });

  // --- 1. LOAD DATA ---
  chrome.storage.sync.get(
    ["googleApiKeys", "azureKey", "azureRegion"], // L∆∞u √Ω: key m·ªõi l√† 'googleApiKeys' (d·∫°ng m·∫£ng)
    (result) => {
      // Load Azure
      if (result.azureKey) azureKeyInput.value = result.azureKey;
      if (result.azureRegion) azureRegionInput.value = result.azureRegion;

      // Load Google Keys (List)
      const keys = result.googleApiKeys || [];

      // Loop qua 5 slot ƒë·ªÉ ƒëi·ªÅn d·ªØ li·ªáu
      for (let i = 0; i < 5; i++) {
        const keyInput = document.getElementById(`api-key-${i}`);
        const cxInput = document.getElementById(`cx-${i}`);

        if (keys[i]) {
          if (keyInput) keyInput.value = keys[i].key || "";
          if (cxInput) cxInput.value = keys[i].cx || "";
        }
      }
    }
  );

  // --- 2. SAVE DATA ---
  saveBtn.addEventListener("click", () => {
    const azureKey = azureKeyInput.value.trim();
    const azureRegion = azureRegionInput.value.trim();

    // Gom d·ªØ li·ªáu t·ª´ 5 slot Google
    let googleKeysList = [];
    for (let i = 0; i < 5; i++) {
      const keyVal = document.getElementById(`api-key-${i}`).value.trim();
      const cxVal = document.getElementById(`cx-${i}`).value.trim();

      // Ch·ªâ l∆∞u n·∫øu c√≥ ƒëi·ªÅn Key (CX c√≥ th·ªÉ d√πng chung ho·∫∑c ri√™ng)
      if (keyVal) {
        googleKeysList.push({
          key: keyVal,
          cx: cxVal, // N·∫øu cx tr·ªëng, logic b√™n content.js s·∫Ω handle sau
        });
      }
    }

    // Validation
    if (googleKeysList.length === 0) {
      showStatusMessage("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 1 Google API Key ch√≠nh!", "warning");
      return;
    }

    // Save to Storage
    chrome.storage.sync.set(
      {
        googleApiKeys: googleKeysList, // L∆∞u d·∫°ng m·∫£ng object
        azureKey: azureKey,
        azureRegion: azureRegion,
      },
      () => {
        showStatusMessage(
          `‚úÖ ƒê√£ l∆∞u ${googleKeysList.length} b·ªô key!`,
          "success"
        );
        setTimeout(hideStatusMessage, 3000);
      }
    );
  });

  // --- 3. TEST API (Test key ƒë·∫ßu ti√™n) ---
  testBtn.addEventListener("click", async () => {
    const key0 = document.getElementById("api-key-0").value.trim();
    const cx0 = document.getElementById("cx-0").value.trim();

    if (!key0 || !cx0) {
      showStatusMessage("‚ö†Ô∏è C·∫ßn nh·∫≠p Key & CX ·ªü √¥ ƒë·∫ßu ti√™n ƒë·ªÉ test", "warning");
      return;
    }

    showStatusMessage("‚è≥ ƒêang test Key ch√≠nh...", "loading");

    try {
      const url = `https://www.googleapis.com/customsearch/v1?q=test&cx=${cx0}&searchType=image&key=${key0}&num=1`;
      const response = await fetch(url);

      if (response.ok) {
        showStatusMessage("‚úÖ Key ch√≠nh ho·∫°t ƒë·ªông ngon l√†nh!", "success");
        setTimeout(hideStatusMessage, 3000);
      } else {
        const errorData = await response.json();
        showStatusMessage(
          `‚ùå L·ªói: ${errorData.error?.message || "Check l·∫°i Key/CX"}`,
          "error"
        );
      }
    } catch (error) {
      showStatusMessage(`‚ùå L·ªói m·∫°ng: ${error.message}`, "error");
    }
  });
});

function showStatusMessage(message, type) {
  const statusDiv = document.getElementById("status-message");
  statusDiv.textContent = message;
  statusDiv.className = `status-message show ${type}`;
}

function hideStatusMessage() {
  const statusDiv = document.getElementById("status-message");
  statusDiv.className = "status-message";
}



================================================
FILE: content-scripts/lookup-main.js
================================================
// =======================================================================
// MODULE: MAIN CONTROLLER (Entry Point)
// =======================================================================

let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;
let lastRecordedBlob = null;

// 1. Handle Mark Click
async function onMarkClick(btnElement, statusElement, data) {
  if (!data) return;
  btnElement.disabled = true;
  btnElement.style.opacity = "0.7";
  btnElement.style.transform = "scale(0.9)";
  statusElement.innerHTML = '<span style="color:#2196F3">‚è≥ ƒêang l∆∞u...</span>';

  try {
    await apiSaveVocabulary(data);
    btnElement.style.background = "#4CAF50";
    btnElement.style.boxShadow = "0 4px 0 #388E3C";
    statusElement.innerHTML =
      '<span style="color:#4CAF50;">‚úÖ ƒê√£ l∆∞u v√†o s·ªï t·ª´!</span>';
    await saveToHistory(data.text, data);
  } catch (err) {
    btnElement.style.background = "#FF9800";
    if (err.message.includes("Ch∆∞a ƒëƒÉng nh·∫≠p")) {
      statusElement.innerHTML =
        '<span style="color:#F44336">‚ö†Ô∏è Vui l√≤ng ƒëƒÉng nh·∫≠p App!</span>';
    } else {
      statusElement.innerHTML = `<span style="color:#F44336">‚ùå L·ªói: ${err.message}</span>`;
    }
  } finally {
    btnElement.disabled = false;
    btnElement.style.opacity = "1";
    btnElement.style.transform = "scale(1)";
  }
}

// 2. Handle Mic Click
async function handleMicClick(referenceText, btnElement, existingVocab) {
  if (!isRecording) {
    try {
      if (!navigator.mediaDevices) {
        alert("Mic not supported");
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
      mediaRecorder.onstop = async () => {
        const resultDiv = document.getElementById("assessment-result");
        if (resultDiv)
          resultDiv.innerHTML =
            '<div style="font-size:12px; color:#ddd; text-align:center;">‚è≥ Processing...</div>';
        try {
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          lastRecordedBlob = audioBlob;
          if (audioBlob.size < 1000) throw new Error("No audio detected.");

          // 1. G·ªçi Azure l·∫•y ƒëi·ªÉm (Code c≈©)
          const result = await assessPronunciation(audioBlob, referenceText);

          // üëá [NEW CODE] T·ª± ƒë·ªông l∆∞u ƒëi·ªÉm v√† th·ªùi gian n·∫øu t·ª´ ƒë√£ t·ªìn t·∫°i
          if (
            existingVocab &&
            existingVocab.id &&
            result.NBest &&
            result.NBest[0]
          ) {
            const score = result.NBest[0].AccuracyScore;

            // G·ªçi API l∆∞u ƒëi·ªÉm ng·∫ßm (kh√¥ng c·∫ßn await ƒë·ªÉ UI ph·∫£n h·ªìi nhanh)
            apiAddScore(existingVocab.id, score).then((success) => {
              if (success) console.log("‚úÖ Score & Time synced to DB!");
            });

            // C·∫≠p nh·∫≠t l·∫°i UI Badge ƒëi·ªÉm ngay l·∫≠p t·ª©c (Optional - Visual feedback)
            // B·∫°n c√≥ th·ªÉ update l·∫°i bi·∫øn existingVocab.pronunciationScores local ·ªü ƒë√¢y n·∫øu mu·ªën
          }
          // üëÜ [END NEW CODE]

          renderAssessmentResult(result, resultDiv, referenceText, {
            playUserAudio: () => {
              const u = URL.createObjectURL(lastRecordedBlob);
              new Audio(u).play();
            },
            speakEdge: speakWithEdgeTTS,
          });
        } catch (err) {
          if (resultDiv)
            resultDiv.innerHTML = `<div style="color:#ff5252; text-align:center;">‚ùå ${err.message}</div>`;
        } finally {
          stream.getTracks().forEach((t) => t.stop());
        }
      };
      mediaRecorder.start();
      isRecording = true;
      btnElement.classList.add("recording");
    } catch (err) {
      alert("Mic Error: " + err.message);
    }
  } else {
    if (mediaRecorder) mediaRecorder.stop();
    isRecording = false;
    btnElement.classList.remove("recording");
  }
}

// 3. Main Event Listener
document.addEventListener("keydown", async (e) => {
  if (e.key === "Shift") {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();

    if (selectedText) {
      let contextText = "";
      try {
        if (selection.anchorNode && selection.anchorNode.parentElement) {
          const parentText = selection.anchorNode.parentElement.innerText;
          const idx = parentText.indexOf(selectedText);
          if (idx !== -1) {
            contextText = parentText
              .substring(
                Math.max(0, idx - 100),
                Math.min(parentText.length, idx + selectedText.length + 100)
              )
              .trim()
              .replace(/\s+/g, " ");
          }
        }
      } catch (err) {}
      if (contextText.length > 200)
        contextText = "..." + contextText.substring(0, 200) + "...";

      const rect = selection.getRangeAt(0).getBoundingClientRect();
      const popup = createPopup();
      isPopupOpen = true;

      const topPos =
        rect.top + window.scrollY - 450 < window.scrollY
          ? rect.bottom + window.scrollY + 10
          : rect.top + window.scrollY - 450;
      const leftPos =
        rect.left + window.scrollX + 350 > window.innerWidth
          ? window.innerWidth - 360
          : rect.left + window.scrollX;

      popup.style.top = `${topPos}px`;
      popup.style.left = `${leftPos}px`;
      popup.innerHTML =
        '<div class="tts-content"><div class="tts-loading">‚è≥ ƒêang ph√¢n t√≠ch...</div></div>';
      popup.style.display = "block";

      speakWithEdgeTTS(selectedText);

      let data = await getFromCache(selectedText);
      if (!data) {
        const isLong = selectedText.split(/\s+/).length > 5;
        const [translation, images] = await Promise.all([
          getTranslation(selectedText, contextText),
          isLong ? [] : getImages(selectedText),
        ]);
        data = {
          translation,
          phonetics: await getPhoneticForText(selectedText),
          images,
          text: selectedText,
          contextText,
        };
        if (translation) await saveToCache(selectedText, data);
      } else if (contextText && !data.contextMeaning) {
        const tr = await getTranslation(selectedText, contextText);
        if (tr) data.translation = tr;
      }

      // üëá [UPDATE] Logic ki·ªÉm tra DB
      let existingVocab = null;
      try {
        existingVocab = await apiCheckVocabulary(selectedText);
      } catch (e) {}

      // G·ªôp th√¥ng tin existing v√†o data
      data.existing = existingVocab; // üëà Th√™m c√°i n√†y ƒë·ªÉ UI bi·∫øt

      renderPopupContent(data, isSoundEnabled, {
        toggleSound: toggleSoundState,
        closePopup,
        speakEdge: speakWithEdgeTTS,
        handleMic: (referenceText, btnElement) =>
          handleMicClick(referenceText, btnElement, existingVocab),
        handleMark: (btn, status) => onMarkClick(btn, status, data),
      });
    } else if (isPopupOpen) {
      closePopup();
    }
  } else if (e.key === "Escape" && isPopupOpen) {
    closePopup();
  }
});

// 4. Flashcard Listener
// 4. Flashcard Listener
chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
  if (request.action === "SHOW_FLASHCARD") {
    console.log("üì© Received SHOW_FLASHCARD message");

    try {
      // Step 1: L·∫•y danh s√°ch t·ª´ Starred t·ª´ Backend
      const list = await apiGetStarredVocabulary();

      if (list && list.length > 0) {
        // Step 2: L·∫•y index hi·ªán t·∫°i t·ª´ Storage (Logic Xoay V√≤ng)
        const storageData = await chrome.storage.local.get([
          "flashcardCurrentIndex",
        ]);
        let currentIndex = storageData.flashcardCurrentIndex || 0;

        // Validate: N·∫øu index v∆∞·ª£t qu√° ƒë·ªô d√†i list (do x√≥a b·ªõt t·ª´), reset v·ªÅ 0
        if (currentIndex >= list.length) {
          currentIndex = 0;
        }

        // Pick t·ª´ theo th·ª© t·ª±
        const selectedItem = list[currentIndex];
        console.log(
          `üîÑ Rotational Pick [${currentIndex + 1}/${list.length}]:`,
          selectedItem.word
        );

        // Step 3: T√≠nh to√°n Index ti·∫øp theo v√† L∆∞u l·∫°i ngay
        const nextIndex = (currentIndex + 1) % list.length; // Quay v√≤ng v·ªÅ 0 n·∫øu h·∫øt list
        await chrome.storage.local.set({ flashcardCurrentIndex: nextIndex });

        // Step 4: Map Data
        const flashcardItem = {
          word: selectedItem.word,
          data: {
            translation: selectedItem.meaning || "No definition",
            pronunciation: selectedItem.pronunciation || "",
            partOfSpeech: selectedItem.partOfSpeech || "",
            images: [],
          },
        };

        // Step 5: Show UI (Gi·ªØ nguy√™n logic c≈©)
        showFlashcard(flashcardItem, {
          speakEdge: speakWithEdgeTTS,

          // Mic Logic
          onMic: () => {
            if (window.NativeUI) {
              window.NativeUI.renderAssessmentModal(
                {
                  ...selectedItem,
                  pronunciation: selectedItem.pronunciation || "",
                },
                {
                  onSpeak: (t) => speakWithEdgeTTS(t),
                  onRecord: async (onSuccess, onError) => {
                    try {
                      const stream = await navigator.mediaDevices.getUserMedia({
                        audio: true,
                      });
                      const mediaRecorder = new MediaRecorder(stream);
                      const chunks = [];
                      mediaRecorder.ondataavailable = (e) =>
                        chunks.push(e.data);
                      mediaRecorder.onstop = async () => {
                        const blob = new Blob(chunks, { type: "audio/webm" });
                        window.lastRecordedBlob = blob;
                        try {
                          const result = await assessPronunciation(
                            blob,
                            selectedItem.word
                          );
                          if (
                            selectedItem.id &&
                            result.NBest &&
                            result.NBest[0]
                          ) {
                            apiAddScore(
                              selectedItem.id,
                              result.NBest[0].AccuracyScore
                            );
                          }
                          if (result.NBest) onSuccess(result.NBest[0]);
                          else onError("No result");
                        } catch (err) {
                          onError(err.message);
                        }
                        stream.getTracks().forEach((t) => t.stop());
                      };
                      mediaRecorder.start();
                      window.currentRecorder = mediaRecorder;
                    } catch (e) {
                      onError("Mic Error: " + e.message);
                    }
                  },
                  onStop: () => {
                    if (window.currentRecorder) window.currentRecorder.stop();
                  },
                  onPlayback: () => {
                    if (window.lastRecordedBlob) {
                      const url = URL.createObjectURL(window.lastRecordedBlob);
                      new Audio(url).play();
                    }
                  },
                }
              );
            }
          },

          // Edit Logic
          onEdit: () => {
            if (window.NativeUI) {
              window.NativeUI.renderFormModal(
                { ...selectedItem, isEditMode: true },
                {
                  onAutoFill: () => null,
                  onSave: async (d) => {
                    await apiUpdateVocabulary(d.id, d);
                  },
                }
              );
            }
          },
        });
      } else {
        console.log(
          "‚ö†Ô∏è No starred words found. Please star some words in App."
        );
      }
    } catch (e) {
      console.error("üî• Flashcard Error:", e);
    }
  }
});



================================================
FILE: content-scripts/lookup-services.js
================================================
// =======================================================================
// MODULE: SERVICES (API, Audio, Caching)
// =======================================================================

const BACKEND_URL = APP_CONFIG.API_URL;
let isSoundEnabled = true;

// --- 1. SETTINGS & AUDIO ---
function toggleSoundState() {
  isSoundEnabled = !isSoundEnabled;
  if (!isSoundEnabled) window.speechSynthesis.cancel();
  return isSoundEnabled;
}

async function speakWithEdgeTTS(text) {
  if (!isSoundEnabled || !text) return;
  window.speechSynthesis.cancel();

  try {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "en-US";
    utterance.rate = 0.9;

    // Fix l·ªói Chrome load voice ch·∫≠m
    let voices = window.speechSynthesis.getVoices();
    if (voices.length === 0) {
      await new Promise((resolve) => {
        window.speechSynthesis.onvoiceschanged = () => {
          voices = window.speechSynthesis.getVoices();
          resolve();
        };
      });
    }

    // ∆Øu ti√™n Microsoft Aria Online
    const ariaVoice =
      voices.find((v) => v.name.includes("Microsoft Aria Online")) ||
      voices.find((v) => v.name.includes("Aria")) ||
      voices.find(
        (v) => v.name.includes("Natural") && v.lang.startsWith("en-US")
      ) ||
      voices.find((v) => v.lang === "en-US");

    if (ariaVoice) utterance.voice = ariaVoice;
    window.speechSynthesis.speak(utterance);
  } catch (error) {
    console.error("TTS Error:", error);
  }
}

// --- 2. BACKEND API (SAVE VOCAB) ---
// apps/extension/content-scripts/lookup-services.js

// --- 2. BACKEND API (SAVE VOCAB) ---
async function apiSaveVocabulary(data) {
  // üëá 1. LOG CHECK CONFIG
  console.log(
    `%c[EXT-DEBUG] üöÄ Starting Save...`,
    "color: cyan; font-weight: bold"
  );
  console.log(`[EXT-DEBUG] Backend URL:`, BACKEND_URL);

  try {
    const meaning =
      typeof data.translation === "string"
        ? data.translation
        : data.translation?.wordMeaning || "";

    const partOfSpeech =
      data.translation?.dict && data.translation.dict.length > 0
        ? data.translation.dict[0].pos
        : "";

    const pronunciation = data.phonetics?.us
      ? data.phonetics.us.replace(/\//g, "")
      : "";

    const payload = {
      word: data.text,
      meaning: meaning,
      example: data.contextText || "",
      pronunciation: pronunciation,
      partOfSpeech: partOfSpeech,
      topic: "Extension",
      isStarred: false,
    };

    // üëá 2. LOG REQUEST
    console.log(`[EXT-DEBUG] Payload:`, payload);
    console.log(`[EXT-DEBUG] Sending request to: ${BACKEND_URL}/vocabulary`);

    const response = await fetch(`${BACKEND_URL}/vocabulary`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      credentials: "include",
    });

    // üëá 3. LOG RESPONSE STATUS
    console.log(`[EXT-DEBUG] Response Status:`, response.status);

    if (!response.ok) {
      const errText = await response.text();
      console.error(`[EXT-DEBUG] Server Error Body:`, errText); // Xem server tr·∫£ v·ªÅ l·ªói g√¨

      if (response.status === 401) throw new Error("Ch∆∞a ƒëƒÉng nh·∫≠p (401)");
      if (response.status === 403) throw new Error("B·ªã ch·∫∑n quy·ªÅn (403)");
      throw new Error(`L·ªói Server: ${response.status}`);
    }

    const json = await response.json();
    console.log(`[EXT-DEBUG] Success Data:`, json);
    return json;
  } catch (error) {
    // üëá 4. LOG NETWORK ERROR (Quan tr·ªçng nh·∫•t)
    console.error(`[EXT-DEBUG] üî• FATAL ERROR:`, error);

    if (error.message.includes("Failed to fetch")) {
      console.warn(
        `[EXT-DEBUG] üëâ G·ª£i √Ω: C√≥ th·ªÉ do l·ªói SSL, CORS, ho·∫∑c ch∆∞a add host_permissions trong manifest.`
      );
    }
    throw error;
  }
}

// --- 3. CACHING SYSTEM ---
async function getFromCache(key) {
  const storageKey = `cache_${key.toLowerCase().trim()}`;
  const result = await chrome.storage.local.get([storageKey]);
  const cachedItem = result[storageKey];
  if (cachedItem && Date.now() - cachedItem.timestamp < 24 * 60 * 60 * 1000) {
    return cachedItem.data;
  }
  return null;
}

async function saveToCache(key, data) {
  const storageKey = `cache_${key.toLowerCase().trim()}`;
  await chrome.storage.local.set({
    [storageKey]: { data: data, timestamp: Date.now() },
  });
}

async function saveToHistory(word, data) {
  try {
    const result = await chrome.storage.local.get(["vocabHistory"]);
    let history = result.vocabHistory || [];
    history = history.filter(
      (item) =>
        item && item.word && item.word.toLowerCase() !== word.toLowerCase()
    );
    history.unshift({ word: word, data: data, timestamp: Date.now() });
    if (history.length > 50) history.pop();
    await chrome.storage.local.set({ vocabHistory: history });
  } catch (e) {
    console.warn("History Error:", e);
  }
}

// --- 4. GOOGLE TRANSLATE API ---
async function getTranslation(text, contextText = "") {
  try {
    let contextMeaning = null;
    if (contextText && contextText.length > 0 && contextText !== text) {
      try {
        const urlCtx = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&q=${encodeURIComponent(
          contextText
        )}`;
        const resCtx = await fetch(urlCtx);
        if (resCtx.ok) {
          const dataCtx = await resCtx.json();
          if (dataCtx && dataCtx[0])
            contextMeaning = dataCtx[0].map((item) => item[0]).join("");
        }
      } catch (e) {}
    }

    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=vi&dt=t&dt=bd&q=${encodeURIComponent(
      text
    )}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error("Google API Error");
    const data = await response.json();

    if (data) {
      const mainMeaning = data[0]
        ? data[0].map((item) => item[0]).join("")
        : "";
      let dict = [];
      if (data[1]) {
        data[1].forEach((group) => {
          dict.push({ pos: group[0], terms: group[1].slice(0, 5) });
        });
      }
      return {
        wordMeaning: mainMeaning,
        contextMeaning: contextMeaning,
        dict: dict,
      };
    }
  } catch (error) {
    return null;
  }
  return null;
}

// --- 5. IMAGE API ---
async function tryFetchGoogleImage(searchTerm, apiKey, cx) {
  try {
    const url = `https://www.googleapis.com/customsearch/v1?q=${encodeURIComponent(
      searchTerm
    )}&cx=${cx}&searchType=image&key=${apiKey}&num=3`;
    const response = await fetch(url);
    if (response.status === 403 || response.status === 429)
      throw new Error(`QUOTA_EXCEEDED`);
    if (!response.ok) return null;
    const data = await response.json();
    if (data.items && data.items.length > 0)
      return data.items.map((item) => item.link);
  } catch (e) {
    if (e.message === "QUOTA_EXCEEDED") throw e;
  }
  return null;
}

async function getImages(englishText) {
  const searchTerm = englishText.trim();
  let images = [];
  const result = await chrome.storage.sync.get([
    "googleApiKeys",
    "googleApiKey",
    "googleSearchEngineId",
  ]);
  let keyList = result.googleApiKeys || [];
  if (
    keyList.length === 0 &&
    result.googleApiKey &&
    result.googleSearchEngineId
  ) {
    keyList.push({ key: result.googleApiKey, cx: result.googleSearchEngineId });
  }

  if (keyList.length > 0) {
    for (const { key, cx } of keyList) {
      if (!key || !cx) continue;
      try {
        const res = await tryFetchGoogleImage(searchTerm, key, cx);
        if (res) {
          images = res;
          break;
        }
      } catch (err) {
        continue;
      }
    }
  }
  // Fallback Unsplash
  if (images.length === 0) {
    try {
      const res = await fetch(
        `https://api.unsplash.com/search/photos?query=${encodeURIComponent(
          searchTerm
        )}&per_page=3&client_id=E8nbwS_cEWGVX4rM0e_-Eq6IpI_QKlO4eFEKfOl3AUo`
      );
      if (res.ok) {
        const data = await res.json();
        if (data.results) images = data.results.map((i) => i.urls.regular);
      }
    } catch (e) {}
  }
  return images;
}

// --- 6. PHONETICS (UPDATED FROM OLD CODE) ---

// Helper: L·∫•y phi√™n √¢m t·ª´ng t·ª´ (Logic c≈©)
async function getPhoneticForWord(word) {
  try {
    const response = await fetch(
      `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
        word.trim()
      )}`
    );
    if (!response.ok) return null;

    const data = await response.json();
    if (data && data[0]) {
      const result = { uk: null, us: null };

      // ∆Øu ti√™n l·∫•y t·ª´ file audio ƒë·ªÉ bi·∫øt ch√≠nh x√°c gi·ªçng
      data[0].phonetics?.forEach((p) => {
        if (p.text) {
          if (p.audio && p.audio.includes("-uk")) {
            result.uk = p.text;
          } else if (p.audio && p.audio.includes("-us")) {
            result.us = p.text;
          } else if (!result.us && !result.uk) {
            result.us = p.text;
          }
        }
      });

      // Fallback n·∫øu kh√¥ng t√¨m th·∫•y trong phonetics array
      if (!result.uk && !result.us && data[0].phonetic) {
        result.us = data[0].phonetic;
      }
      return result;
    }
  } catch (error) {}
  return null;
}

// Main: L·∫•y phi√™n √¢m cho c·∫£ c√¢u/ƒëo·∫°n (Logic c≈©)
async function getPhoneticForText(text) {
  const words = text
    .trim()
    .split(/\s+/)
    .filter((w) => w.length > 0);
  const isLongText = words.length > 5;

  // Ch·∫°y song song request cho t·ª´ng t·ª´
  const phonetics = await Promise.all(
    words.map(async (word) => {
      const cleanWord = word.replace(/[.,!?;:'"()]/g, "");
      if (!cleanWord) return null;
      return await getPhoneticForWord(cleanWord);
    })
  );

  const ukParts = [];
  const usParts = [];

  phonetics.forEach((p, idx) => {
    if (p) {
      if (!isLongText && p.uk) ukParts.push(p.uk);

      if (p.us) usParts.push(p.us);
      else if (p.uk) usParts.push(p.uk); // Fallback UK sang US n·∫øu thi·∫øu
      else {
        // Fallback word g·ªëc n·∫øu kh√¥ng c√≥ phi√™n √¢m
        const cleanWord = words[idx].replace(/[.,!?;:'"()]/g, "");
        usParts.push(cleanWord);
      }
    } else {
      const cleanWord = words[idx].replace(/[.,!?;:'"()]/g, "");
      if (!isLongText) ukParts.push(cleanWord);
      usParts.push(cleanWord);
    }
  });

  const format = (parts) => {
    if (parts.length === 0) return null;
    const combined = parts
      .map((part) => (part ? part.replace(/^\/|\/$/g, "") : "")) // B·ªè d·∫•u / th·ª´a
      .filter(Boolean)
      .join(" ");
    return combined ? `/${combined}/` : null; // B·ªçc l·∫°i b·∫±ng //
  };

  return {
    uk: format(ukParts),
    us: format(usParts),
  };
}

// Helper: Convert Audio
async function convertAudioToWav(audioBlob) {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)({
    sampleRate: 16000,
  });
  const arrayBuffer = await audioBlob.arrayBuffer();
  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
  const pcmData = audioBuffer.getChannelData(0);

  const buffer = new ArrayBuffer(44 + pcmData.length * 2);
  const view = new DataView(buffer);
  const writeString = (view, offset, string) => {
    for (let i = 0; i < string.length; i++)
      view.setUint8(offset + i, string.charCodeAt(i));
  };
  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + pcmData.length * 2, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, 16000, true);
  view.setUint32(28, 32000, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, "data");
  view.setUint32(40, pcmData.length * 2, true);
  let offset = 44;
  for (let i = 0; i < pcmData.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, pcmData[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
  }
  return new Blob([view], { type: "audio/wav" });
}

async function assessPronunciation(audioBlob, referenceText) {
  try {
    const result = await chrome.storage.sync.get(["azureKey", "azureRegion"]);
    const key = result.azureKey;
    const region = result.azureRegion;
    if (!key || !region) throw new Error("Ch∆∞a nh·∫≠p Azure Key/Region.");

    const wavBlob = await convertAudioToWav(audioBlob);
    const assessParams = {
      ReferenceText: referenceText,
      GradingSystem: "HundredMark",
      Granularity: "Phoneme",
      Dimension: "Comprehensive",
      PhonemeAlphabet: "IPA",
    };
    const paramsHeader = btoa(JSON.stringify(assessParams));

    const url = `https://${region}.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=en-US`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Ocp-Apim-Subscription-Key": key,
        "Content-Type": "audio/wav; codecs=audio/pcm; samplerate=16000",
        Accept: "application/json",
        "Pronunciation-Assessment": paramsHeader,
      },
      body: wavBlob,
    });

    if (!response.ok) throw new Error(`Azure Error ${response.status}`);
    return await response.json();
  } catch (e) {
    throw e;
  }
}
// --- [NEW] CHECK VOCAB EXISTENCE ---
async function apiCheckVocabulary(word) {
  try {
    const response = await fetch(
      `${BACKEND_URL}/vocabulary/check?word=${encodeURIComponent(word)}`,
      {
        method: "GET",
        headers: { "Content-Type": "application/json" },
        credentials: "include", // ƒê·ªÉ l·∫•y cookie auth
      }
    );
    if (response.ok) {
      const data = await response.json();
      return data; // Tr·∫£ v·ªÅ object t·ª´ v·ª±ng n·∫øu c√≥, ho·∫∑c null/r·ªóng
    }
  } catch (e) {
    console.warn("Check vocab failed:", e);
  }
  return null;
}
// --- [NEW] UPDATE SCORE TO BACKEND ---
async function apiAddScore(vocabId, score) {
  // N·∫øu vocabId l√† "temp" ho·∫∑c kh√¥ng c√≥ ID -> Kh√¥ng l∆∞u ƒë∆∞·ª£c (ch·ªâ luy·ªán t·∫≠p)
  if (!vocabId || vocabId === "temp") return false;

  try {
    const response = await fetch(`${BACKEND_URL}/vocabulary/${vocabId}/score`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ score: Math.round(score) }),
      credentials: "include",
    });
    return response.ok;
  } catch (e) {
    console.error("Save score failed:", e);
    return false;
  }
}

// T√¨m ki·∫øm danh s√°ch t·ª´ (cho Quick Search)
async function apiSearchVocabulary(keyword) {
  try {
    if (!keyword) return [];
    const res = await fetch(
      `${BACKEND_URL}/vocabulary?search=${encodeURIComponent(keyword)}&limit=5`,
      {
        headers: { "Content-Type": "application/json" },
        credentials: "include",
      }
    );
    if (res.ok) {
      const json = await res.json();
      return json.data; // Tr·∫£ v·ªÅ m·∫£ng items
    }
  } catch (e) {}
  return [];
}

// H√†m Save ƒë·∫ßy ƒë·ªß (thay th·∫ø ho·∫∑c b·ªï sung cho apiSaveVocabulary c≈©)
async function apiCreateFullVocabulary(payload) {
  // Payload: { word, meaning, example, topic, partOfSpeech, pronunciation, relatedWords }
  const response = await fetch(`${BACKEND_URL}/vocabulary`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
    credentials: "include",
  });
  if (!response.ok) throw new Error("Save failed");
  return await response.json();
}
async function apiUpdateVocabulary(id, data) {
  try {
    const payload = {
      word: data.word,
      meaning: data.meaning,
      example: data.example,
      topic: data.topic,
      partOfSpeech: data.partOfSpeech,
      pronunciation: data.pronunciation,
      relatedWords: data.relatedWords,
      // Backend kh√¥ng nh·∫≠n 'isEditMode' n√™n ƒë·ª´ng g·ª≠i
    };

    const response = await fetch(`${BACKEND_URL}/vocabulary/${id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      credentials: "include",
    });

    if (!response.ok) throw new Error("Update failed");
    return await response.json();
  } catch (error) {
    throw error;
  }
}
// --- [NEW] D·ªäCH VI·ªÜT -> ANH ---
async function translateViToEn(vietnameseText) {
  try {
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=vi&tl=en&dt=t&q=${encodeURIComponent(
      vietnameseText
    )}`;
    const response = await fetch(url);
    if (!response.ok) return null;
    const data = await response.json();
    if (data && data[0]) {
      return data[0].map((item) => item[0]).join("");
    }
  } catch (error) {
    console.error("Translate VI->EN error:", error);
  }
  return null;
}
// ... (c√°c code c≈© gi·ªØ nguy√™n)

// --- [NEW] FETCH STARRED VOCABULARY ---
async function apiGetStarredVocabulary() {
  try {
    // G·ªçi API l·∫•y danh s√°ch t·ª´ ƒë√£ Star (L·∫•y limit 50 t·ª´ m·ªõi nh·∫•t ƒë·ªÉ random)
    const res = await fetch(
      `${BACKEND_URL}/vocabulary?isStarred=true&limit=50`,
      {
        method: "GET",
        headers: { "Content-Type": "application/json" },
        credentials: "include", // Quan tr·ªçng ƒë·ªÉ g·ª≠i Cookie Auth
      }
    );

    if (res.ok) {
      const json = await res.json();
      return json.data; // Tr·∫£ v·ªÅ m·∫£ng VocabItem
    }
  } catch (e) {
    console.error("Fetch starred failed:", e);
  }
  return [];
}



================================================
FILE: content-scripts/lookup-ui.js
================================================
// =======================================================================
// MODULE: UI RENDERING
// =======================================================================

let popup = null;
let isPopupOpen = false;
let isDragging = false;
let dragOffset = { x: 0, y: 0 };

function createPopup() {
  if (popup) popup.remove();
  popup = document.createElement("div");
  popup.id = "tts-popup";
  popup.style.display = "none";
  document.body.appendChild(popup);
  return popup;
}

function closePopup() {
  if (popup) popup.style.display = "none";
  window.speechSynthesis.cancel();
  isPopupOpen = false;
}

function enableDragging(header) {
  header.style.cursor = "move";
  header.addEventListener("mousedown", (e) => {
    if (e.target.closest("button")) return;
    isDragging = true;
    const rect = popup.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    header.style.cursor = "grabbing";
  });
  document.addEventListener("mousemove", (e) => {
    if (!isDragging) return;
    e.preventDefault();
    popup.style.left = e.clientX - dragOffset.x + "px";
    popup.style.top = e.clientY - dragOffset.y + "px";
  });
  document.addEventListener("mouseup", () => {
    isDragging = false;
    header.style.cursor = "move";
  });
}

function renderPopupContent(data, isSoundEnabled, callbacks) {
  if (!popup) return;
  const { toggleSound, closePopup, speakEdge, handleMark, handleMic } =
    callbacks;

  const existing = data.existing;

  // Logic t√≠nh ƒëi·ªÉm trung b√¨nh 3 l·∫ßn g·∫ßn nh·∫•t (n·∫øu c√≥)
  let scoreBadge = "";
  if (
    existing &&
    existing.pronunciationScores &&
    existing.pronunciationScores.length > 0
  ) {
    const scores = existing.pronunciationScores.slice(-3); // L·∫•y 3 ƒëi·ªÉm cu·ªëi
    const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
    let color = avg >= 80 ? "#4CAF50" : avg >= 60 ? "#FFC107" : "#F44336";
    scoreBadge = `<span style="position:absolute; top:-5px; right:-5px; background:${color}; color:white; font-size:10px; padding:2px 5px; border-radius:10px; border:1px solid white;">${avg}</span>`;
  }

  // üëá [UPDATE] Render n√∫t Mark
  let markBtnHtml = "";
  if (existing) {
    // A. ƒê√É C√ì: Hi·ªán n√∫t "ƒê√£ l∆∞u" (M√†u x√°m ho·∫∑c Xanh ƒë·∫≠m, kh√¥ng cho click save n·ªØa)
    markBtnHtml = `
        <button id="mark-btn-disabled" class="mic-btn" style="width:55px; height:55px; background:#E0E0E0; box-shadow:none; cursor:default; position:relative;" title="ƒê√£ c√≥ trong b·ªô t·ª´ v·ª±ng">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="#4CAF50" stroke="#4CAF50" stroke-width="2">
              <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
            ${scoreBadge}
        </button>`;
  } else {
    // B. CH∆ØA C√ì: Hi·ªán n√∫t Save nh∆∞ c≈©
    markBtnHtml = `
        <button id="mark-btn" class="mic-btn" style="width:55px; height:55px; background:#FF9800; box-shadow: 0 4px 0 #F57C00;" title="L∆∞u t·ª´ n√†y">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
        </button>`;
  }

  let content = `
      <div class="tts-header" id="popup-header">
        <button id="sound-toggle" class="sound-btn">${
          isSoundEnabled ? "üîä" : "üîá"
        }</button>
        <div style="flex:1"></div>
        <button id="close-popup" class="close-btn">‚úï</button>
      </div>

      <div class="tts-actions">
        <div style="display:flex; gap:15px; align-items:center;">
            <button id="replay-tts-btn" class="mic-btn" style="width:45px; height:45px; background:#4CAF50;" title="Nghe l·∫°i">
               <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
            </button>
            
            ${markBtnHtml}

            <button id="mic-btn" class="mic-btn" style="width:45px; height:45px;" title="Check ph√°t √¢m">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
            </button>
        </div>
        <div id="save-status" style="margin-top:8px; font-size:12px; font-weight:600; min-height:18px;"></div>
        <div id="assessment-result"></div>
      </div>
      
      <div class="tts-content">`;

  // Images
  if (data.images && data.images.length) {
    content += `<div class="tts-images-container">${data.images
      .map(
        (url) =>
          `<div class="tts-image"><img src="${url}" onerror="this.style.display='none'"/></div>`
      )
      .join("")}</div>`;
  }
  // 2. Hi·ªÉn th·ªã Phi√™n √¢m
  if (data.phonetics && (data.phonetics.us || data.phonetics.uk)) {
    content += `<div class="tts-phonetic">
            ${
              data.phonetics.uk
                ? `<div class="phonetic-item"><span class="flag">üá¨üáß</span><span class="phonetic-text">${data.phonetics.uk}</span></div>`
                : ""
            }
            ${
              data.phonetics.us
                ? `<div class="phonetic-item"><span class="flag">üá∫üá∏</span><span class="phonetic-text">${data.phonetics.us}</span></div>`
                : ""
            }
        </div>`;
  }
  // Meaning
  if (data.translation) {
    content += `<div class="word-text" style="font-size:24px; text-align:center; margin-bottom:5px;">${data.text}</div>`;
    const mainMeaning =
      typeof data.translation === "string"
        ? data.translation
        : data.translation.wordMeaning;
    if (mainMeaning)
      content += `<div class="primary-meaning">${mainMeaning}</div>`;

    if (data.translation.contextMeaning) {
      content += `<div class="context-box"><strong>Ng·ªØ c·∫£nh:</strong><br/><em style="color:#777">"...${
        data.contextText || ""
      }..."</em><br/>üëâ <span style="color:#2e7d32; font-weight:600;">${
        data.translation.contextMeaning
      }</span></div>`;
    }
  } else {
    content += `<div class="tts-info">Kh√¥ng t√¨m th·∫•y b·∫£n d·ªãch.</div>`;
  }

  content += `</div>`; // End .tts-content
  popup.innerHTML = content;

  // Events
  enableDragging(document.getElementById("popup-header"));
  document.getElementById("close-popup").onclick = closePopup;
  document.getElementById("sound-toggle").onclick = toggleSound;
  document.getElementById("replay-tts-btn").onclick = () =>
    speakEdge(data.text);

  // Ch·ªâ g√°n s·ª± ki·ªán click n·∫øu n√∫t mark-btn t·ªìn t·∫°i (t·ª©c l√† ch∆∞a l∆∞u)
  const markBtn = document.getElementById("mark-btn");
  if (markBtn) {
    markBtn.onclick = (e) => {
      e.stopPropagation();
      handleMark(markBtn, document.getElementById("save-status"));
    };
  }

  // Mic Event
  const micBtn = document.getElementById("mic-btn");
  micBtn.onclick = (e) => {
    e.stopPropagation();
    handleMic(data.text, micBtn, data.existing); // üëà Th√™m data.existing
  };
}

function renderAssessmentResult(data, container, referenceText, callbacks) {
  if (!container) return;
  if (!data || data.error) {
    container.innerHTML = `<div style="color:#ff5252; text-align:center;">‚ö†Ô∏è ${
      data?.error || "L·ªói API"
    }</div>`;
    return;
  }
  const result = data.NBest[0];
  const totalScore =
    result.AccuracyScore || result.PronunciationAssessment?.AccuracyScore || 0;
  const words = result.Words || [];
  let scoreColor =
    totalScore >= 80 ? "#4caf50" : totalScore >= 60 ? "#ffeb3b" : "#ff5252";

  let html = `<div class="assessment-box" style="background:rgba(0,0,0,0.3); padding:15px; border-radius:8px; margin-top:10px;">
    <div class="assessment-actions">
        <button id="btn-play-user" class="action-btn-small btn-user-audio">üó£Ô∏è My Voice</button>
        <button id="btn-play-standard" class="action-btn-small btn-ref-audio">üéß Standard</button>
    </div>
    <div class="total-score-circle" style="border-color: ${scoreColor}; color: ${scoreColor}">${Math.round(
    totalScore
  )}</div>
    <div class="analyzed-content">`;

  words.forEach((word) => {
    const wScore =
      word.AccuracyScore || word.PronunciationAssessment?.AccuracyScore || 0;
    const errorType =
      word.ErrorType || word.PronunciationAssessment?.ErrorType || "None";
    let wordColor =
      errorType === "Omission" ? "#777" : wScore < 60 ? "#ff5252" : "#fff";
    let phonemeHtml = "";
    if (errorType !== "Omission") {
      (word.Phonemes || []).forEach((p) => {
        let pClass =
          p.AccuracyScore >= 90
            ? "p-perfect"
            : p.AccuracyScore >= 80
            ? "p-good"
            : p.AccuracyScore >= 60
            ? "p-fair"
            : "p-bad";
        phonemeHtml += `<span class="phoneme-char ${pClass}" title="/${p.Phoneme}/: ${p.AccuracyScore}">${p.Phoneme}</span>`;
      });
    } else {
      phonemeHtml = `<span style="font-size:10px; color:#999;">(missed)</span>`;
    }
    html += `<div class="word-block"><span class="word-text" style="color:${wordColor}">${word.Word}</span><div class="phoneme-row">${phonemeHtml}</div></div>`;
  });
  html += `</div></div>`;
  container.innerHTML = html;

  setTimeout(() => {
    const btnUser = document.getElementById("btn-play-user");
    const btnStandard = document.getElementById("btn-play-standard");
    if (btnUser) btnUser.onclick = callbacks.playUserAudio;
    if (btnStandard)
      btnStandard.onclick = () => callbacks.speakEdge(referenceText);
  }, 0);
}

[cite_start]; // [cite: 704]
function showFlashcard(item, callbacks) {
  // 1. X√≥a th·∫ª c≈©
  const oldCard = document.getElementById("vocab-flashcard");
  if (oldCard) oldCard.remove();

  // 2. L·∫•y tr·∫°ng th√°i √¢m thanh ƒë√£ l∆∞u (M·∫∑c ƒë·ªãnh l√† B·∫≠t)
  chrome.storage.local.get(["flashcard_sound_on"], (result) => {
    // L∆∞u √Ω: !== false nghƒ©a l√† undefined (l·∫ßn ƒë·∫ßu) c≈©ng l√† True
    let isSoundOn = result.flashcard_sound_on !== false;

    // 3. T·∫°o th·∫ª
    const card = document.createElement("div");
    card.id = "vocab-flashcard";
    card.className = "flashcard-slide-in";

    // Style G·ªçn nh·∫π, Hi·ªán ƒë·∫°i
    Object.assign(card.style, {
      cursor: "pointer",
      borderLeft: "5px solid #58cc02", // M√†u xanh th∆∞∆°ng hi·ªáu
      fontFamily: "'Segoe UI', sans-serif",
      display: "flex",
      flexDirection: "column",
      maxWidth: "280px", // G·ªçn g√†ng
      background: "#fff",
      boxShadow: "0 5px 20px rgba(0,0,0,0.15)",
      borderRadius: "8px",
      overflow: "hidden",
    });

    // Icons SVG
    const ICON_CLOSE = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
    const ICON_SOUND_ON = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#555" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;
    const ICON_SOUND_OFF = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#ff4d4f" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;
    const ICON_MIC = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>`;

    // 4. Chu·∫©n b·ªã HTML cho Phi√™n √¢m & T·ª´ lo·∫°i
    const pronunHtml = item.data.pronunciation
      ? `<span style="font-family:monospace; font-size:12px; color:#888; margin-left:8px;">/${item.data.pronunciation}/</span>`
      : "";

    const posHtml = item.data.partOfSpeech
      ? `<span style="font-size:10px; font-weight:700; color:#1890ff; background:#e6f7ff; border:1px solid #91d5ff; padding:1px 4px; border-radius:4px; margin-left:6px; text-transform:uppercase; vertical-align:middle;">${item.data.partOfSpeech}</span>`
      : "";

    // 5. N·ªôi dung HTML
    card.innerHTML = `
      <div style="padding:12px 12px 4px 12px; display:flex; justify-content:space-between; align-items:flex-start;">
          <div>
              <div style="display:flex; align-items:center; flex-wrap:wrap;">
                  <span style="font-size:18px; color:#333; font-weight:800; line-height:1.2;">${
                    item.word
                  }</span>
                  ${posHtml}
              </div>
              <div style="margin-top:2px;">${pronunHtml}</div>
          </div>
          <button id="fc-close" style="background:none; border:none; cursor:pointer; padding:4px;">${ICON_CLOSE}</button>
      </div>

      <div style="padding:4px 12px 12px 12px;">
          <p style="margin:0; font-size:15px; color:#444; line-height:1.4;">${
            item.data.translation
          }</p>
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center; padding:8px 12px; background:#f9f9f9; border-top:1px solid #eee;">
          <div style="display:flex; gap:8px;">
              <button id="fc-sound-btn" title="B·∫≠t/T·∫Øt ƒë·ªçc t·ª± ƒë·ªông" style="background:#fff; border:1px solid #ddd; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s;">
                  ${isSoundOn ? ICON_SOUND_ON : ICON_SOUND_OFF}
              </button>
              <button id="fc-mic-btn" title="Luy·ªán ph√°t √¢m" style="background:#fff; border:1px solid #ddd; border-radius:50%; width:32px; height:32px; display:flex; align-items:center; justify-content:center; cursor:pointer; color:#f57c00;">
                  ${ICON_MIC}
              </button>
          </div>
          <div id="fc-timer" style="font-size:11px; font-weight:bold; color:#aaa;">12s</div>
      </div>
    `;

    document.body.appendChild(card);

    // --- LOGIC ---

    // A. Auto Speak (Ch·ªâ ƒë·ªçc n·∫øu Sound ƒëang ON)
    if (isSoundOn) {
      callbacks.speakEdge(item.word);
    }

    // B. Toggle Sound & Save Memory
    const btnSound = document.getElementById("fc-sound-btn");
    btnSound.onclick = (e) => {
      e.stopPropagation();
      isSoundOn = !isSoundOn; // ƒê·ªïi tr·∫°ng th√°i

      // Update UI Icon
      btnSound.innerHTML = isSoundOn ? ICON_SOUND_ON : ICON_SOUND_OFF;

      // Save v√†o Storage (Quan tr·ªçng!)
      chrome.storage.local.set({ flashcard_sound_on: isSoundOn });

      if (!isSoundOn) window.speechSynthesis.cancel();
      else callbacks.speakEdge(item.word);
    };

    // C. C√°c n√∫t kh√°c
    document.getElementById("fc-mic-btn").onclick = (e) => {
      e.stopPropagation();
      card.remove();
      if (callbacks.onMic) callbacks.onMic();
    };

    document.getElementById("fc-close").onclick = (e) => {
      e.stopPropagation();
      card.remove();
      window.speechSynthesis.cancel();
    };

    // Click v√†o card ƒë·ªÉ Edit
    card.onclick = (e) => {
      if (e.target.closest("button")) return;
      card.remove();
      if (callbacks.onEdit) callbacks.onEdit();
    };

    // Timer Auto Close
    let timeLeft = 12;
    const interval = setInterval(() => {
      timeLeft--;
      const t = document.getElementById("fc-timer");
      if (t) t.innerText = `${timeLeft}s`;
      if (timeLeft <= 0) {
        clearInterval(interval);
        card.classList.add("flashcard-slide-out");
        setTimeout(() => {
          if (card.parentNode) card.remove();
        }, 500);
      }
    }, 1000);
  });
}



================================================
FILE: content-scripts/main.js
================================================
[Empty file]


================================================
FILE: content-scripts/messager.js
================================================
[Empty file]


================================================
FILE: content-scripts/metrics.js
================================================
// apps/extension/content-scripts/metrics.js
// H√†m d√πng ƒë·ªÉ ƒëo l∆∞·ªùng hi·ªáu su·∫•t API call t·ª´ Extension

export const measureApiCall = async (apiName, apiCallFn) => {
  const t1_start = performance.now(); // üïí B·∫Øt ƒë·∫ßu T1

  try {
    const response = await apiCallFn();

    const t1_end = performance.now(); // üèÅ K·∫øt th√∫c T1
    const t1_total_ms = (t1_end - t1_start).toFixed(2);

    // L·∫•y T2 t·ª´ Header m√† Backend g·ª≠i v·ªÅ
    const t2_server_ms = parseFloat(
      response.headers?.get?.("x-server-time") || "0"
    );

    // T√≠nh ƒë·ªô tr·ªÖ m·∫°ng (Network Latency)
    const network_latency = (parseFloat(t1_total_ms) - t2_server_ms).toFixed(2);

    console.group(`üìä METRICS: ${apiName}`);
    console.log(`1Ô∏è‚É£ T·ªïng th·ªùi gian (T1): ${t1_total_ms} ms`);
    console.log(`2Ô∏è‚É£ Server x·ª≠ l√Ω (T2):   ${t2_server_ms} ms`);
    console.log(`3Ô∏è‚É£ ƒê·ªô tr·ªÖ m·∫°ng (Net):   ${network_latency} ms`);

    // K·∫æT LU·∫¨N T·ª∞ ƒê·ªòNG
    if (parseFloat(network_latency) > 1000) {
      console.warn("üëâ CH·∫¨M DO M·∫†NG (Internet/Wifi)");
    } else if (t2_server_ms > 500) {
      console.warn("üëâ CH·∫¨M DO BACKEND (Code/DB)");
    } else {
      console.log("‚úÖ T·ªëc ƒë·ªô ·ªïn ƒë·ªãnh");
    }
    console.groupEnd();

    return response;
  } catch (error) {
    console.error(`‚ùå API Error: ${apiName}`, error);
    throw error;
  }
};



================================================
FILE: content-scripts/native-core.js
================================================
console.log("‚úÖ Native Core Loaded - Smart Ranking Mode");

window.NativeCore = (function () {
  let debounceTimer = null;
  let latestQuery = "";
  let lastDbResults = [];
  let currentApiData = null; // Cache k·∫øt qu·∫£ Translate
  let currentMode = localStorage.getItem("vocab_last_mode") || "EN";

  // --- HELPER: T√çNH ƒêI·ªÇM ∆ØU TI√äN (Ranking) ---
  function sortResultsByRelevance(items, keyword, mode) {
    if (!keyword || items.length === 0) return items;
    const searchStr = keyword.toLowerCase().trim();

    return items.sort((a, b) => {
      const scoreA = calculateScore(a, searchStr, mode);
      const scoreB = calculateScore(b, searchStr, mode);
      return scoreB - scoreA; // ƒêi·ªÉm cao x·∫øp tr√™n
    });
  }

  function calculateScore(item, keyword, mode) {
    let score = 0;
    // 1. ∆Øu ti√™n kh·ªõp ch√≠nh x√°c t·ª´ g·ªëc (Word)
    if (item.word.toLowerCase() === keyword) return 1000;

    // 2. Logic so s√°nh Meaning (Cho Mode VI)
    if (mode === "VI" && item.meaning) {
      const meaningLower = item.meaning.toLowerCase();

      // T√°ch nghƒ©a b·∫±ng d·∫•u ph·∫©y, ch·∫•m ph·∫©y (Vd: "t√°o, qu·∫£ t√°o; t√°o t√¢y")
      const parts = meaningLower.split(/[,;]+/).map((p) => p.trim());

      // Case A: Kh·ªõp ch√≠nh x√°c 1 segment (Vd: search "t√°o" kh·ªõp segment "t√°o") -> ∆Øu ti√™n cao nh·∫•t
      if (parts.includes(keyword)) {
        score += 500;
      }
      // Case B: B·∫Øt ƒë·∫ßu b·∫±ng t·ª´ kh√≥a (Vd: "t√°o qu√¢n") -> ∆Øu ti√™n nh√¨
      else if (parts.some((p) => p.startsWith(keyword + " "))) {
        score += 100;
      }
      // Case C: Ch·ªâ ch·ª©a t·ª´ kh√≥a (Vd: "c·∫•u t·∫°o") -> ∆Øu ti√™n th·∫•p
      else if (meaningLower.includes(keyword)) {
        score += 10;
      }
    }
    // 3. Logic cho Mode EN (Word match)
    else if (mode === "EN") {
      if (item.word.toLowerCase().startsWith(keyword)) score += 100;
      else if (item.word.toLowerCase().includes(keyword)) score += 10;
    }

    // Bonus: ƒêi·ªÉm tr·ª´ nh·∫π n·∫øu t·ª´ qu√° d√†i (ƒë·ªÉ ∆∞u ti√™n t·ª´ ng·∫Øn g·ªçn h∆°n)
    score -= item.word.length * 0.1;

    return score;
  }

  // --- 1. LOGIC AUTO-FILL (Gi·ªØ nguy√™n) ---
  async function fetchAutoFillData(word) {
    if (!word) return null;
    try {
      const dictPromise = fetch(
        `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
          word
        )}`
      )
        .then((r) => (r.ok ? r.json() : null))
        .catch(() => null);
      const translatePromise = getTranslation(word);
      const [dictRes, transRes] = await Promise.all([
        dictPromise,
        translatePromise,
      ]);

      let newData = {};
      if (dictRes && dictRes[0]) {
        const entry = dictRes[0];
        if (entry.phonetic) newData.pronunciation = entry.phonetic;
        else if (entry.phonetics && entry.phonetics.length > 0) {
          const p = entry.phonetics.find((x) => x.text && x.audio);
          newData.pronunciation = p ? p.text : entry.phonetics[0]?.text || "";
        }
        if (entry.meanings && entry.meanings.length > 0) {
          const m = entry.meanings[0];
          newData.partOfSpeech = m.partOfSpeech;
          if (m.definitions) {
            const def = m.definitions.find((d) => d.example);
            if (def) newData.example = def.example;
          }
        }
      }
      if (transRes) {
        const mean =
          typeof transRes === "string" ? transRes : transRes.wordMeaning;
        if (mean) newData.meaning = mean;
      }
      return newData;
    } catch (e) {
      console.error("Autofill error:", e);
      return null;
    }
  }

  // --- 2. HANDLE SAVE ---
  async function handleSaveVocab(data) {
    try {
      if (data.id) {
        await apiUpdateVocabulary(data.id, data);
        console.log("‚úÖ Updated successfully");
      } else {
        await apiCreateFullVocabulary(data);
        console.log("‚úÖ Created successfully");
      }
      // Reload search, √©p ki·ªÉu EN ƒë·ªÉ t√¨m ch√≠nh x√°c t·ª´ v·ª´a t·∫°o
      runSearch(data.word, "EN");
    } catch (e) {
      alert("Save failed: " + e.message + "\n(Check Login or Network)");
    }
  }

  // --- 3. ASSESSMENT HANDLER ---
  function onOpenAssessment(vocab) {
    const vocabItem = vocab.id
      ? vocab
      : {
          id: "temp",
          word: vocab.word,
          pronunciation: vocab.pronunciation || "",
        };

    window.NativeUI.renderAssessmentModal(vocabItem, {
      onSpeak: (text) => speakWithEdgeTTS(text),
      onRecord: async (onSuccess, onError) => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          const mediaRecorder = new MediaRecorder(stream);
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: "audio/webm" });
            window.lastRecordedBlob = blob;
            try {
              const result = await assessPronunciation(blob, vocabItem.word);
              if (vocabItem.id !== "temp" && result.NBest && result.NBest[0]) {
                const score = result.NBest[0].AccuracyScore;
                await apiAddScore(vocabItem.id, score);
              }
              if (result.NBest) onSuccess(result.NBest[0]);
              else onError("No result");
            } catch (err) {
              onError(err.message);
            }
            stream.getTracks().forEach((t) => t.stop());
          };
          mediaRecorder.start();
          window.currentRecorder = mediaRecorder;
        } catch (e) {
          onError("Mic Error: " + e.message);
        }
      },
      onStop: () => {
        if (window.currentRecorder) window.currentRecorder.stop();
      },
      onPlayback: () => {
        if (window.lastRecordedBlob) {
          const url = URL.createObjectURL(window.lastRecordedBlob);
          new Audio(url).play();
        }
      },
    });
  }

  // --- [FIXED] POPUP LOGIC (Th√™m onSpeak/onMic) ---

  // --- FIX POPUP C√ÇM & LOGIC T·∫†O T·ª™ ---

  async function onOpenCreate(englishWord, meaningVal = "") {
    const h = getHandlers(); // L·∫•y handlers (ch·ª©a onSpeak ƒë√£ fix Aria)

    window.NativeUI.renderFormModal(
      { word: englishWord, meaning: meaningVal, isEditMode: false },
      {
        onSave: handleSaveVocab,
        onAutoFill: fetchAutoFillData,
        onSpeak: h.onSpeak, // üëà Ph·∫£i c√≥ d√≤ng n√†y th√¨ n√∫t loa trong Popup m·ªõi k√™u
        onMic: h.onMic,
      }
    );
  }

  async function onEdit(item) {
    const h = getHandlers();

    window.NativeUI.renderFormModal(
      { ...item, isEditMode: true },
      {
        onSave: handleSaveVocab,
        onAutoFill: fetchAutoFillData,
        onSpeak: h.onSpeak, // üëà Fix l·ªói loa
        onMic: h.onMic,
      }
    );
  }

  // --- 5. INPUT & HANDLERS ---
  function handleInput(text) {
    latestQuery = text;
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      runSearch(text.trim());
    }, 50); // Gi·∫£m delay xu·ªëng 50ms cho c·∫£m gi√°c nhanh h∆°n
  }
  function setMode(newMode) {
    if (currentMode === newMode) return;
    currentMode = newMode;
    localStorage.setItem("vocab_last_mode", newMode); // L∆∞u v√†o Storage
    runSearch(latestQuery, true);
  }
  async function handleEnter(text) {
    const rawInput = text.trim();
    if (!rawInput) return;

    // 1. ∆Øu ti√™n m·ªü t·ª´ c√≥ trong DB
    const exactMatch = lastDbResults.find(
      (i) => i.word.toLowerCase() === rawInput.toLowerCase()
    );
    if (exactMatch) {
      onEdit(exactMatch);
      return;
    }

    // 2. N·∫øu kh√¥ng, m·ªü form t·∫°o m·ªõi (D√πng t·ª´ ƒë√£ d·ªãch n·∫øu c√≥)
    const wordToCreate =
      currentApiData && currentApiData.trans
        ? typeof currentApiData.trans === "string"
          ? currentApiData.trans
          : currentApiData.trans.wordMeaning
        : rawInput;

    onOpenCreate(wordToCreate, currentMode === "VI" ? rawInput : "");
  }

  function getHandlers() {
    return {
      mode: currentMode,
      rawInput: latestQuery,
      onInput: handleInput,
      onModeChange: setMode,
      onEnter: handleEnter,

      // Force English Voice (Aria)
      onSpeak: (text) => {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "en-US";
        const voices = window.speechSynthesis.getVoices();
        const ariaVoice = voices.find(
          (v) => v.name.includes("Aria") && v.name.includes("English")
        );
        const googleVoice = voices.find((v) =>
          v.name.includes("Google US English")
        );
        if (ariaVoice) u.voice = ariaVoice;
        else if (googleVoice) u.voice = googleVoice;
        window.speechSynthesis.speak(u);
      },

      onOpenCreate: (word) => onOpenCreate(word),
      onEdit: onEdit,
      onMic: onOpenAssessment, // ƒê·∫£m b·∫£o h√†m n√†y ƒë∆∞·ª£c truy·ªÅn xu·ªëng
      onInteract: handleInteraction,

      // Th√™m Handler Save ƒë·ªÉ Popup g·ªçi ƒë∆∞·ª£c
      onSave: handleSaveVocab,
    };
  }

  async function runSearch(rawInput, forceRefresh = false) {
    if (!rawInput) {
      window.NativeUI.renderSearchModal("", [], null, getHandlers());
      return;
    }

    if (forceRefresh) {
      lastDbResults = [];
      currentApiData = null;
    }

    const runQuery = rawInput;

    // TASK 1: GOOGLE TRANSLATE (Ch·∫°y cho c·∫£ 2 mode)
    // Mode VI: D·ªãch Vi·ªát -> Anh
    // Mode EN: D·ªãch Anh -> Vi·ªát (ƒê·ªÉ l·∫•y nghƒ©a hi·ªÉn th·ªã)
    const promiseTrans =
      currentMode === "VI"
        ? translateViToEn(runQuery)
        : getTranslation(runQuery); // H√†m n√†y tr·∫£ v·ªÅ object ho·∫∑c string t√πy implement

    promiseTrans
      .then(async (result) => {
        if (latestQuery !== runQuery) return;

        if (result) {
          // Chu·∫©n h√≥a data
          const transText =
            typeof result === "string" ? result : result.wordMeaning;

          // Mode VI: transText l√† ti·∫øng Anh -> L·∫•y Phonetic
          // Mode EN: runQuery l√† ti·∫øng Anh -> L·∫•y Phonetic t·ª´ runQuery (n·∫øu c·∫ßn, ho·∫∑c DB ƒë√£ c√≥)
          let phonetics = "";
          if (currentMode === "VI") {
            phonetics = await getPhoneticForText(transText);
          }

          currentApiData = {
            trans: transText, // K·∫øt qu·∫£ d·ªãch
            phonetics: phonetics,
          };
          renderUI();
        }
      })
      .catch((e) => console.log("Trans Err", e));

    // TASK 2: DATABASE SEARCH (Ch·∫°y song song)
    apiSearchVocabulary(runQuery)
      .then((results) => {
        if (latestQuery !== runQuery) return;
        lastDbResults = results;
        renderUI();
      })
      .catch((err) => console.log("DB err", err));
  }

  function renderUI() {
    window.NativeUI.renderSearchModal(
      latestQuery,
      lastDbResults,
      currentApiData,
      getHandlers()
    );
  }

  // üëá [NEW] H√ÄM C·∫¨P NH·∫¨T COUNT & TIME (INTERACTION)
  async function handleInteraction(item) {
    if (!item || !item.id) return;

    // T√≠nh to√°n count m·ªõi (tƒÉng 1)
    const newCount = (item.occurrence || 0) + 1;

    // Update local cache ngay l·∫≠p t·ª©c ƒë·ªÉ UI ph·∫£n h·ªìi (n·∫øu c·∫ßn)
    item.occurrence = newCount;

    try {
      // G·ªçi API PATCH tr·ª±c ti·∫øp ƒë·ªÉ update count
      // (Backend Prisma s·∫Ω t·ª± ƒë·ªông update c·ªôt 'updatedAt' th√†nh gi·ªù hi·ªán t·∫°i)
      await fetch(`https://localhost:5001/vocabulary/${item.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ occurrence: newCount }),
        credentials: "include",
      });
      // console.log(`Interact: ${item.word} -> ${newCount}`);
    } catch (e) {
      console.error("Interaction update failed", e);
    }
  }

  function toggle() {
    const modal = document.getElementById("vocab-search-wrapper");
    // N·∫øu ƒëang hi·ªán -> ·∫®n
    if (modal && modal.style.display === "block") {
      window.NativeUI.hideAll();
    } else {
      // N·∫øu ƒëang ·∫©n -> Hi·ªán l·∫°i (D·ªØ li·ªáu c≈© v·∫´n c√≤n trong bi·∫øn lastDbResults/latestQuery)
      renderUI();
      setTimeout(() => {
        const input = document.getElementById("native-search-input");
        if (input) input.focus();
      }, 100);
    }
  }

  async function handleSelection() {
    const sel = window.getSelection().toString().trim();
    if (!sel) return;
    const rect = window.getSelection().getRangeAt(0).getBoundingClientRect();
    speakWithEdgeTTS(sel);
    const [trans, phonetics] = await Promise.all([
      getTranslation(sel),
      getPhoneticForText(sel),
    ]);
    if (trans) {
      window.NativeUI.renderPopup({ text: sel, trans, phonetics }, rect, {
        onSpeak: (t) => speakWithEdgeTTS(t),
        onOpenCreate: (w) => onOpenCreate(w),
      });
    }
  }

  return {
    toggle,
    handleSelection,
    handleEnter,
    handleInteraction,
    // üëá EXPOSE H√ÄM N√ÄY ƒê·ªÇ FLASHCARD G·ªåI
    openEdit: onEdit,
    // üëá EXPOSE H√ÄM N√ÄY ƒê·ªÇ FLASHCARD G·ªåI MIC
    openAssessment: onOpenAssessment,
  };
})();

// Global Listeners
window.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.code === "KeyQ") {
    e.preventDefault();
    window.NativeCore.toggle();
  }
});
window.addEventListener("keyup", (e) => {
  if (e.key === "Escape") {
    window.NativeUI.hideAll();
  }
});



================================================
FILE: content-scripts/native-ui.js
================================================
console.log("‚úÖ Native UI Loaded");

window.NativeUI = (function () {
  let root = null;
  let searchWrapper = null;
  let searchModal = null; // üëá Bi·∫øn tham chi·∫øu t·ªõi Modal
  let formWrapper = null;
  let miniPopup = null;
  let assessWrapper = null; // New wrapper for assessment modal

  // üëá [UPDATED] B·ªò ICON CHU·∫®N ƒê·∫∏P (L·∫•y t·ª´ Shift Popup)
  const ICONS = {
    search:
      '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>',
    mic: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>',
    sound:
      '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>',
    mark: '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>',
    close:
      '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
  };

  // --- 1. H√ÄM X·ª¨ L√ù K√âO TH·∫¢ & L∆ØU V·ªä TR√ç ---
  function enableDragAndPersist(headerEl, modalEl) {
    let isDragging = false;
    let startX, startY, initialLeft, initialTop;

    // A. Kh√¥i ph·ª•c v·ªã tr√≠ c≈© (n·∫øu c√≥)
    const savedPos = localStorage.getItem("vocab_widget_pos");
    if (savedPos) {
      const { top, left } = JSON.parse(savedPos);
      // Ki·ªÉm tra xem v·ªã tr√≠ c√≥ b·ªã tr√¥i ra kh·ªèi m√†n h√¨nh kh√¥ng
      const safeTop = Math.min(Math.max(0, top), window.innerHeight - 50);
      const safeLeft = Math.min(Math.max(0, left), window.innerWidth - 50);

      modalEl.style.top = safeTop + "px";
      modalEl.style.left = safeLeft + "px";
      modalEl.style.transform = "none"; // B·ªè cƒÉn gi·ªØa m·∫∑c ƒë·ªãnh
    }

    // B. B·∫Øt ƒë·∫ßu k√©o
    headerEl.onmousedown = (e) => {
      // Ch·ªâ k√©o khi click v√†o v√πng tr·ªëng c·ªßa header (tr√°nh input)
      if (
        e.target.tagName === "INPUT" ||
        e.target.closest(".vocab-mode-flag") ||
        e.target.tagName === "BUTTON"
      )
        return;

      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;

      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i (t√≠nh c·∫£ khi ƒëang d√πng transform)
      const rect = modalEl.getBoundingClientRect();
      initialLeft = rect.left;
      initialTop = rect.top;

      // X√≥a transform ƒë·ªÉ chuy·ªÉn sang d√πng top/left tuy·ªát ƒë·ªëi m∆∞·ª£t m√†
      modalEl.style.transform = "none";
      modalEl.style.left = initialLeft + "px";
      modalEl.style.top = initialTop + "px";
      modalEl.style.width = rect.width + "px"; // C·ªë ƒë·ªãnh chi·ªÅu r·ªông ƒë·ªÉ kh√¥ng b·ªã co gi√£n
    };

    // C. ƒêang k√©o
    const onMouseMove = (e) => {
      if (!isDragging) return;
      e.preventDefault(); // Ch·∫∑n b√¥i ƒëen text

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      modalEl.style.left = `${initialLeft + dx}px`;
      modalEl.style.top = `${initialTop + dy}px`;
    };

    // D. Th·∫£ chu·ªôt (L∆∞u v·ªã tr√≠)
    const onMouseUp = () => {
      if (!isDragging) return;
      isDragging = false;

      // L∆∞u v√†o LocalStorage
      const pos = {
        top: parseInt(modalEl.style.top || 0),
        left: parseInt(modalEl.style.left || 0),
      };
      localStorage.setItem("vocab_widget_pos", JSON.stringify(pos));
    };

    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  }

  function init() {
    if (document.getElementById("vocab-root")) return;
    root = document.createElement("div");
    root.id = "vocab-root";
    document.body.appendChild(root);
    const style = document.createElement("style");
    style.innerHTML = `
      .vocab-mode-flag {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        width: 34px;
        height: 34px;
        border-radius: 50%;
        background: #fff;
        border: 1px solid #e0e0e0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        cursor: pointer;
        z-index: 20;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        user-select: none;
        transition: all 0.2s;
      }
      .vocab-mode-flag:hover { transform: translateY(-50%) scale(1.1); box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
      .google-trans-box { background: #f8f9fa; border-bottom: 1px solid #eee; padding: 12px 16px; cursor: pointer; transition: background 0.1s; }
      .google-trans-box:hover { background: #e8f0fe; }
      .google-main-text { font-size: 16px; color: #1a73e8; font-weight: 600; margin-bottom: 2px; }
      .google-sub-text { font-size: 11px; color: #5f6368; }
      .vocab-list-item { cursor: pointer; padding: 10px 16px; border-bottom: 1px solid #f1f1f1; display: flex; align-items: flex-start; gap: 10px; transition: background 0.1s; }
      .vocab-list-item:hover { background: #f5f5f5; }
      .vocab-actions { display: flex; gap: 8px; align-items: center; margin-left: auto; }
      .vocab-score-badge { font-size:10px; color:#fff; padding:1px 6px; border-radius:10px; margin-left:6px; font-weight:bold; }
      .vocab-search-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-size: 14px;
        color: #333;
        resize: none; /* Kh√¥ng cho user k√©o gi√£n th·ªß c√¥ng */
        overflow: hidden; /* ·∫®n thanh cu·ªôn */
        min-height: 24px;
        line-height: 1.5;
        font-family: inherit;
        padding-top: 4px; 
      }
      .action-btn-circle {
        width: 28px; height: 28px; border-radius: 50%; border: 1px solid #ddd;
        background: #fff; display: flex; align-items: center; justify-content: center;
        cursor: pointer; color: #5f6368; padding: 0; z-index: 10;
      }
      .action-btn-circle:hover { background: #f1f3f4; color: #1a73e8; border-color: #1a73e8; }
      .action-btn-circle svg { width: 16px; height: 16px; }
    `;
    root.appendChild(style);
    // 1. Search Wrapper
    searchWrapper = document.createElement("div");
    searchWrapper.id = "vocab-search-wrapper";
    searchWrapper.innerHTML = `
      <div id="vocab-search-modal">
        <div class="vocab-header" id="vocab-drag-handle" style="position:relative;">
          <div class="vocab-input-affix" style="padding-right: 45px;"> ${ICONS.search}
            <textarea class="vocab-search-input" id="native-search-input" placeholder="Search..." autocomplete="off" rows="1"></textarea>
          </div>
          <div id="vocab-mode-trigger"></div>
        </div>
        <div id="vocab-modal-body" class="vocab-body"></div>
        <div id="vocab-modal-assessment"></div>
      </div>
    `;
    root.appendChild(searchWrapper);

    // üëá KH·ªûI T·∫†O DRAG
    searchModal = document.getElementById("vocab-search-modal");
    const dragHandle = document.getElementById("vocab-drag-handle");
    enableDragAndPersist(dragHandle, searchModal);

    // 2. Full Form Modal Wrapper
    formWrapper = document.createElement("div");
    formWrapper.className = "vocab-modal-overlay";
    formWrapper.style.display = "none";
    root.appendChild(formWrapper);

    // 3. Mini Popup
    miniPopup = document.createElement("div");
    miniPopup.id = "vocab-mini-popup";
    root.appendChild(miniPopup);

    // 4. Assessment Modal Wrapper
    if (!document.getElementById("vocab-assess-wrapper")) {
      assessWrapper = document.createElement("div");
      assessWrapper.id = "vocab-assess-wrapper";
      assessWrapper.className = "assess-modal-overlay";
      assessWrapper.style.display = "none";
      root.appendChild(assessWrapper);

      assessWrapper.onclick = (e) => {
        if (e.target === assessWrapper) assessWrapper.style.display = "none";
      };
    } else {
      assessWrapper = document.getElementById("vocab-assess-wrapper");
    }

    // Close events
    searchWrapper.onclick = (e) => {
      if (e.target === searchWrapper) hideAll();
    };
    // üëá [FIX 1]: X√ìA ho·∫∑c COMMENT d√≤ng n√†y ƒë·ªÉ ch·∫∑n click ra ngo√†i b·ªã t·∫Øt
    // formWrapper.onclick = (e) => {
    //   if (e.target === formWrapper) formWrapper.style.display = "none";
    // };
    searchWrapper.addEventListener("keydown", (e) => e.stopPropagation());
  }

  function hideAll() {
    if (searchWrapper) searchWrapper.style.display = "none";
    if (formWrapper) formWrapper.style.display = "none";
    if (miniPopup) miniPopup.style.display = "none";
    if (assessWrapper) assessWrapper.style.display = "none";
    window.speechSynthesis.cancel();
  }

  // --- RENDER FORM MODAL (POPUP CHI TI·∫æT) ---
  function renderFormModal(data, handlers) {
    if (!formWrapper) return;

    // Style l·∫°i wrapper ƒë·ªÉ n√≥ n·∫±m ƒë√® l√™n search nh∆∞ng ƒë·ªôc l·∫≠p
    formWrapper.innerHTML = "";
    formWrapper.style.display = "flex"; // Hi·ªán form

    const isEdit = data.isEditMode;

    // Meaning value for prefill
    const meaningVal = data.meaning || "";
    // HTML Header c√≥ Mic v√† Loa
    const html = `
      <div class="vocab-modal-content" style="width: 400px; background: #fff; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); overflow: hidden; display: flex; flex-direction: column;">
        <div class="vocab-header" style="justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; background: #f8f9fa;">
           <div style="font-weight: 700; font-size: 16px; color: #333; display: flex; align-items: center; gap: 10px;">
              ${isEdit ? "Edit Word" : "New Word"}
              
              <button type="button" class="action-btn-circle btn-sound" id="btn-popup-speak" title="Listen">${
                ICONS.sound
              }</button>
              <button type="button" class="action-btn-circle btn-mic" id="btn-popup-mic" title="Practice">${
                ICONS.mic
              }</button>
           </div>
           
           <div id="btn-close-form" style="cursor: pointer; padding: 4px; color: #666;">${
             ICONS.close
           }</div>
        </div>

        <div class="vocab-body" style="padding: 16px; overflow-y: auto; max-height: 60vh;">
            <div style="margin-bottom: 12px;">
                <label style="display:block; font-size:11px; font-weight:600; color:#5f6368; margin-bottom:4px;">WORD</label>
                <input id="input-word" value="${
                  data.word || ""
                }" class="vocab-form-input" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px; font-weight:bold; color:#1a73e8;">
            </div>
            
            <div style="display:flex; gap:10px; margin-bottom: 12px;">
                <div style="flex:1">
                    <label style="display:block; font-size:11px; font-weight:600; color:#5f6368; margin-bottom:4px;">TYPE</label>
                    <input id="input-pos" value="${
                      data.partOfSpeech || ""
                    }" class="vocab-form-input" placeholder="n, v, adj..." style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px;">
                </div>
                <div style="flex:1">
                    <label style="display:block; font-size:11px; font-weight:600; color:#5f6368; margin-bottom:4px;">IPA</label>
                    <input id="input-ipa" value="${
                      data.pronunciation || ""
                    }" class="vocab-form-input" placeholder="/.../" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px;">
                </div>
            </div>

            <div style="margin-bottom: 12px;">
                <label style="display:block; font-size:11px; font-weight:600; color:#5f6368; margin-bottom:4px;">MEANING</label>
                <textarea id="input-mean" rows="2" class="vocab-form-input" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px; resize:vertical;">${meaningVal}</textarea>
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="display:block; font-size:11px; font-weight:600; color:#5f6368; margin-bottom:4px;">EXAMPLE</label>
                <textarea id="input-ex" rows="2" class="vocab-form-input" style="width:100%; padding:8px; border:1px solid #ddd; border-radius:6px; resize:vertical;">${
                  data.example || ""
                }</textarea>
            </div>

            <button id="btn-save-form" style="width:100%; background:#1a73e8; color:white; padding:10px; border:none; border-radius:6px; font-weight:600; cursor:pointer;">
                ${isEdit ? "Update Vocabulary" : "Save to Library"}
            </button>
        </div>
      </div>
    `;

    formWrapper.innerHTML = html;

    // --- BIND EVENTS ---

    // 1. Close Button: Ch·ªâ ƒë√≥ng formWrapper
    document.getElementById("btn-close-form").onclick = () => {
      formWrapper.style.display = "none";
      // Search Modal v·∫´n gi·ªØ nguy√™n b√™n d∆∞·ªõi
    };

    // 2. Speak Button: Lu√¥n d√πng handlers.onSpeak ƒë·ªÉ c√≥ gi·ªçng Aria
    document.getElementById("btn-popup-speak").onclick = () => {
      const currentWord = document.getElementById("input-word").value;
      // G·ªçi handler t·ª´ Core ƒë·ªÉ d√πng gi·ªçng Aria
      if (handlers.onSpeak) handlers.onSpeak(currentWord);
    };

    // 3. Mic Button
    document.getElementById("btn-popup-mic").onclick = () => {
      const currentWord = document.getElementById("input-word").value;
      const currentIpa = document.getElementById("input-ipa").value;
      // G·ªçi Modal Assessment
      window.NativeCore.openAssessment({
        word: currentWord,
        pronunciation: currentIpa,
        id: data.id || "temp_form",
      });
    };

    // 4. Save Button (Gi·ªØ nguy√™n logic c≈©)
    document.getElementById("btn-save-form").onclick = async () => {
      const newData = {
        id: data.id,
        word: document.getElementById("input-word").value,
        partOfSpeech: document.getElementById("input-pos").value,
        pronunciation: document.getElementById("input-ipa").value,
        meaning: document.getElementById("input-mean").value,
        example: document.getElementById("input-ex").value,
        occurrence: data.occurrence || 1,
      };

      // G·ªçi h√†m save handler truy·ªÅn t·ª´ Core
      if (handlers.onSave) {
        // Show loading text
        document.getElementById("btn-save-form").textContent = "Saving...";
        await handlers.onSave(newData);
        formWrapper.style.display = "none"; // ƒê√≥ng form sau khi save xong
      }
    };
  }
  function renderSearchModal(keyword, dbResults, apiData, handlers) {
    init(); // ƒê·∫£m b·∫£o init ƒë√£ ch·∫°y
    searchWrapper.style.display = "block";

    const input = document.getElementById("native-search-input");
    const body = document.getElementById("vocab-modal-body");
    const modeTrigger = document.getElementById("vocab-mode-trigger");
    const mode = handlers.mode || "EN";
    const userTyped = handlers.rawInput || "";

    // 1. RENDER FLAG BUTTON
    const flagIcon = mode === "VI" ? "üáªüá≥" : "üá¨üáß";
    modeTrigger.innerHTML = `<div class="vocab-mode-flag" title="Chuy·ªÉn ch·∫ø ƒë·ªô" style="cursor:pointer;">${flagIcon}</div>`;
    modeTrigger.onclick = (e) => {
      e.stopPropagation();
      handlers.onModeChange(mode === "VI" ? "EN" : "VI");
    };

    // 2. INPUT HANDLING
    input.setAttribute(
      "placeholder",
      mode === "VI" ? "Nh·∫≠p ti·∫øng Vi·ªát..." : "Type English..."
    );
    if (document.activeElement !== input) {
      input.value = userTyped;
      input.focus();
    }
    // Auto height
    input.style.height = "auto";
    input.style.height = input.scrollHeight + "px";

    if (!input.dataset.hasEvent) {
      input.oninput = (e) => {
        e.target.style.height = "auto";
        e.target.style.height = e.target.scrollHeight + "px";
        handlers.onInput(e.target.value);
      };
      input.addEventListener("keydown", (e) => {
        e.stopPropagation();
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handlers.onEnter(input.value);
        }
      });
      ["paste", "copy", "cut", "selectstart"].forEach((evt) =>
        input.addEventListener(evt, (e) => e.stopPropagation())
      );
      input.dataset.hasEvent = "true";
    }

    // 3. RENDER BODY
    let html = "";

    // A. GOOGLE RESULT (STYLE C·ª®NG ƒê·ªÇ HI·ªÜN N√öT)
    if (apiData && apiData.trans) {
      const transText =
        typeof apiData.trans === "string"
          ? apiData.trans
          : apiData.trans.wordMeaning;
      const phonetics = apiData.phonetics?.us || "";
      const label =
        mode === "VI" ? "D·ªãch Anh (T·ª± ƒë·ªông)" : "Nghƒ©a ti·∫øng Vi·ªát (Google)";

      // üëá Style tr·ª±c ti·∫øp cho n√∫t (width, height, background) ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªán 100%
      const btnStyle = `width:30px; height:30px; border-radius:50%; border:1px solid #ddd; background:#fff; display:flex; align-items:center; justify-content:center; cursor:pointer; padding:0; min-width:30px; color:#555;`;

      html += `
        <div class="google-trans-box" id="google-result-box" style="padding:12px 16px; border-bottom:1px solid #eee; background:#f8f9fa; cursor:pointer;">
             <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                <div style="flex:1; margin-right:10px;">
                    <div class="google-main-text" style="font-size:16px; color:#1a73e8; font-weight:bold; margin-bottom:4px; word-break:break-word;">
                        ${transText}
                    </div>
                    <div class="google-sub-text" style="font-size:11px; color:#666;">
                        ${
                          phonetics
                            ? `<span style="color:#333;">/${phonetics}/</span> ‚Ä¢ `
                            : ""
                        }
                        ${label}
                    </div>
                </div>
                
                <div style="display:flex; gap:8px; align-items:center;">
                     <button type="button" style="${btnStyle}" id="btn-trans-speak" title="Nghe">${
        ICONS.sound
      }</button>
                     <button type="button" style="${btnStyle}" id="btn-trans-mic" title="Luy·ªán n√≥i">${
        ICONS.mic
      }</button>
                </div>
             </div>
        </div>`;
    }

    // B. DATABASE RESULTS
    if (dbResults && dbResults.length > 0) {
      dbResults.forEach((item) => {
        const isMatch = item.word.toLowerCase() === keyword.toLowerCase();
        let scoreHtml = "";
        if (item.pronunciationScores && item.pronunciationScores.length > 0) {
          const avg = Math.round(
            item.pronunciationScores.reduce((a, b) => a + b, 0) /
              item.pronunciationScores.length
          );
          const color =
            avg >= 80 ? "#4caf50" : avg >= 60 ? "#fbc02d" : "#ef4444";
          scoreHtml = `<span style="font-size:10px; background:${color}; color:#fff; padding:1px 6px; border-radius:10px; margin-left:6px; font-weight:bold;">${avg}</span>`;
        }

        const btnStyle = `width:28px; height:28px; border-radius:50%; border:1px solid #ddd; background:#fff; display:flex; align-items:center; justify-content:center; cursor:pointer; padding:0; min-width:28px; color:#555;`;

        html += `
            <div class="vocab-list-item" id="item-${
              item.id
            }" style="padding:10px 16px; border-bottom:1px solid #f1f1f1; display:flex; align-items:flex-start; cursor:pointer;">
                <div style="flex:1;">
                    <div class="vocab-word-text" style="${
                      isMatch ? "color:#1a73e8; font-weight:700" : ""
                    }">
                        ${item.word}
                        ${
                          item.pronunciation
                            ? `<span style="color:#666; font-weight:400; margin-left:4px;">/${item.pronunciation}/</span>`
                            : ""
                        }
                        ${scoreHtml}
                    </div>
                    <div class="vocab-word-meta" style="font-size:12px; color:#666; margin-top:2px;">
                       ${
                         item.partOfSpeech
                           ? `<span style="border:1px solid #eee; padding:0 4px; border-radius:4px; margin-right:4px;">${item.partOfSpeech}</span>`
                           : ""
                       } 
                       ${item.meaning || ""}
                    </div>
                </div>
                <div style="display:flex; gap:8px; align-items:center; margin-left:10px;">
                    <button type="button" style="${btnStyle}" id="btn-speak-${
          item.id
        }">${ICONS.sound}</button>
                    <button type="button" style="${btnStyle}" id="btn-mic-${
          item.id
        }">${ICONS.mic}</button>
                </div>
            </div>`;
      });
    } else if (!apiData && keyword) {
      html += `<div style="padding:20px; text-align:center; color:#999;">ƒêang t√¨m ki·∫øm...</div>`;
    }

    body.innerHTML = html;

    // 4. BIND EVENTS
    if (apiData && apiData.trans) {
      const transText =
        typeof apiData.trans === "string"
          ? apiData.trans
          : apiData.trans.wordMeaning;

      const box = document.getElementById("google-result-box");
      if (box)
        box.onclick = (e) => {
          if (e.target.closest("button")) return;
          // Mode VI: L∆∞u t·ª´ Anh (transText), Nghƒ©a (keyword)
          // Mode EN: L∆∞u t·ª´ Anh (keyword), Nghƒ©a (User nh·∫≠p)
          const wordToSave = mode === "VI" ? transText : keyword;
          const meaningToSave = mode === "VI" ? keyword : "";
          handlers.onOpenCreate(wordToSave, meaningToSave);
        };

      const btnSpeak = document.getElementById("btn-trans-speak");
      if (btnSpeak)
        btnSpeak.onclick = (e) => {
          e.stopPropagation();
          // Lu√¥n ƒë·ªçc t·ª´ Ti·∫øng Anh
          const textToSpeak = mode === "VI" ? transText : keyword;
          handlers.onSpeak(textToSpeak);
        };

      const btnMic = document.getElementById("btn-trans-mic");
      if (btnMic)
        btnMic.onclick = (e) => {
          e.stopPropagation();
          const textToPractice = mode === "VI" ? transText : keyword;
          handlers.onMic({
            word: textToPractice,
            id: "temp_google",
            pronunciation: apiData.phonetics?.us || "",
          });
        };
    }

    if (dbResults) {
      dbResults.forEach((item) => {
        const row = document.getElementById(`item-${item.id}`);
        if (row) {
          row.onclick = (e) => {
            if (e.target.closest("button")) return;
            handlers.onInteract(item);
            handlers.onEdit(item);
          };
          document.getElementById(`btn-speak-${item.id}`).onclick = (e) => {
            e.stopPropagation();
            handlers.onInteract(item);
            handlers.onSpeak(item.word);
          };
          document.getElementById(`btn-mic-${item.id}`).onclick = (e) => {
            e.stopPropagation();
            handlers.onInteract(item);
            handlers.onMic(item);
          };
        }
      });
    }
  }

  // Helper Speak: Update ƒë·ªÉ h·ªó tr·ª£ set ng√¥n ng·ªØ ti·∫øng Anh chu·∫©n
  function speak(text) {
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "en-US"; // üëà Quan tr·ªçng: √âp gi·ªçng Anh M·ªπ
    window.speechSynthesis.speak(u);
  }

  // Return API
  return {
    renderSearchModal,
    renderPopup: window.NativeUI?.renderPopup || function () {},
    renderFormModal,
    renderAssessmentModal,
    hideAll,
    speak: speak, // S·ª≠ d·ª•ng h√†m speak ƒë√£ n√¢ng c·∫•p
  };

  // ... (C√°c h√†m kh√°c gi·ªØ nguy√™n) ...

  function renderPopup(data, rect, handlers) {
    init();
    miniPopup.style.display = "block";
    searchWrapper.style.display = "none";
    let top = rect.bottom + 10;
    let left = rect.left;
    if (top + 200 > window.innerHeight) top = rect.top - 200;
    miniPopup.style.top = top + "px";
    miniPopup.style.left = left + "px";
    const trans = data.trans;
    const meaning = typeof trans === "string" ? trans : trans.wordMeaning;
    miniPopup.innerHTML = `
        <div style="padding:16px;">
            <div style="font-weight:700; font-size:18px; color:#1890ff; margin-bottom:4px;">${
              data.text
            }</div>
            <div style="color:#888; font-family:monospace; margin-bottom:8px;">${
              data.phonetics?.us || ""
            }</div>
            <div style="margin-bottom:12px; color:#333;">${meaning}</div>
            <div style="display:flex; gap:8px;">
                <button id="pp-listen" class="ant-btn ant-btn-icon">${
                  ICONS.sound
                }</button>
                <button id="pp-mic" class="ant-btn ant-btn-icon">${
                  ICONS.mic
                }</button>
                <div style="flex:1"></div>
                <button id="pp-add" class="ant-btn ant-btn-primary">Add to DB</button>
            </div>
            <div id="pp-assessment"></div>
        </div>
      `;
    document.getElementById("pp-listen").onclick = () =>
      handlers.onSpeak(data.text);
    document.getElementById("pp-mic").onclick = () =>
      handleMicClick(data.text, document.getElementById("pp-assessment"));
    document.getElementById("pp-add").onclick = () => {
      hideAll();
      handlers.onOpenCreate(data.text);
    };
  }

  // --- [NEW] RENDER ASSESSMENT MODAL ---
  function renderAssessmentModal(vocab, handlers) {
    init();
    assessWrapper.style.display = "flex";

    const renderContent = (result = null, isRecording = false, error = "") => {
      let scoreHtml = `<div style="color:#e5e7eb; font-size:48px;">?</div>`;
      let borderColor = "#f3f4f6";
      let phonemeHtml = "";

      if (result) {
        const score = Math.round(result.AccuracyScore);
        borderColor =
          score >= 80 ? "#4caf50" : score >= 60 ? "#fbc02d" : "#ef4444";
        scoreHtml = `<div style="color:${borderColor}">${score}</div>`;

        if (result.Words && result.Words[0] && result.Words[0].Phonemes) {
          phonemeHtml = result.Words[0].Phonemes.map((p) => {
            const bgClass =
              p.AccuracyScore >= 80
                ? "bg-green"
                : p.AccuracyScore >= 60
                ? "bg-yellow"
                : "bg-red";
            return `<span class="phoneme-badge ${bgClass}" title="${p.AccuracyScore}">${p.Phoneme}</span>`;
          }).join("");
        }
      }

      assessWrapper.innerHTML = `
            <div class="assess-modal-content">
                <button id="assess-close" style="position:absolute; top:15px; right:15px; background:none; border:none; font-size:20px; cursor:pointer; color:#9ca3af;">‚úï</button>
                <div class="assess-word">${vocab.word}</div>
                <div class="assess-pronun">/${vocab.pronunciation || ""}/</div>
                <div class="score-circle-container" style="border-color: ${borderColor}">
                    ${scoreHtml}
                </div>
                ${
                  phonemeHtml
                    ? `<div class="phoneme-list">${phonemeHtml}</div>`
                    : ""
                }
                <div class="assess-controls">
                    <button id="btn-listen-sample" class="btn-control btn-speaker" title="Nghe m·∫´u">
                       ${ICONS.sound}
                    </button>
                    <button id="btn-record-toggle" class="btn-control btn-record ${
                      isRecording ? "recording" : ""
                    }">
                       ${
                         isRecording
                           ? '<div style="width:20px; height:20px; background:white; border-radius:4px;"></div>'
                           : ICONS.mic
                       }
                    </button>
                    <button id="btn-playback-user" class="btn-control btn-playback" title="Nghe l·∫°i" ${
                      !result ? "disabled" : ""
                    }>
                       <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                    </button>
                </div>
                <div class="assess-status">
                    ${
                      isRecording
                        ? '<span style="color:#ef4444">Listening...</span>'
                        : error
                        ? `<span style="color:#ef4444">${error}</span>`
                        : result
                        ? vocab.id !== "temp"
                          ? '<span style="color:#10b981">‚úÖ Score Saved!</span>'
                          : '<span style="color:#f59e0b">‚ö†Ô∏è Practice Mode (Not Saved)</span>'
                        : "Click mic to start"
                    }
                </div>
            </div>
          `;

      document.getElementById("assess-close").onclick = () =>
        (assessWrapper.style.display = "none");
      document.getElementById("btn-listen-sample").onclick = () =>
        handlers.onSpeak(vocab.word);

      document.getElementById("btn-record-toggle").onclick = () => {
        if (isRecording) handlers.onStop();
        else
          handlers.onRecord(
            (res) => renderContent(res, false),
            (err) => renderContent(null, false, err)
          );
        if (!isRecording) renderContent(null, true);
      };

      document.getElementById("btn-playback-user").onclick = () =>
        handlers.onPlayback();
    };

    renderContent();
  }

  function renderAssessmentResult(data, container) {
    if (!data || !data.NBest) {
      container.innerHTML = `<div style="color:red; text-align:center; padding:10px;">Error</div>`;
      return;
    }
    const result = data.NBest[0];
    const score = Math.round(result.AccuracyScore);
    const color = score >= 80 ? "#52c41a" : score >= 60 ? "#faad14" : "#ff4d4f";
    let html = `...`; // Old assessment result renderer can be deprecated or kept for mini-popups
    container.innerHTML = html;
    container.style.display = "block";
  }

  async function handleMicClick(text, container) {
    // This logic should now be in native-core.js
    // It will call renderAssessmentModal instead
  }

  return {
    renderSearchModal,
    renderPopup,
    renderFormModal,
    renderAssessmentModal,
    hideAll,
  };
})();



================================================
FILE: content-scripts/shortcuts.js
================================================
// This file is intentionally left blank to avoid redundant hotkey listeners.
// The logic has been consolidated into main.js.


================================================
FILE: content-scripts/ui.js
================================================
// ui.js
let iframeElement = null;

export const createOverlay = () => {
  if (iframeElement) return; // ƒê√£ t·ªìn t·∫°i th√¨ th√¥i

  // 1. T·∫°o Iframe
  iframeElement = document.createElement("iframe");

  // 2. Style cho Iframe (Full m√†n h√¨nh, ƒë√® l√™n t·∫•t c·∫£)
  Object.assign(iframeElement.style, {
    position: "fixed",
    top: "0",
    left: "0",
    width: "100vw",
    height: "100vh",
    border: "none",
    zIndex: "2147483647", // Max z-index
    backgroundColor: "rgba(0,0,0,0.5)", // M√†u n·ªÅn t·ªëi m·ªù
    display: "block",
  });

  // 3. Load trang Vocabulary c·ªßa Frontend v√†o
  // Th√™m param ?openSearch=true ƒë·ªÉ React bi·∫øt ƒë∆∞·ªùng m·ªü Popup ngay l·∫≠p t·ª©c
  iframeElement.src = `${APP_CONFIG.FRONTEND_URL}/vocabulary?openSearch=true&iframeMode=true`;
  iframeElement.allow = "microphone; camera"; // Quan tr·ªçng: Cho ph√©p d√πng Mic trong Iframe

  document.body.appendChild(iframeElement);

  // 4. Focus v√†o iframe ƒë·ªÉ g√µ ph√≠m ƒë∆∞·ª£c ngay
  iframeElement.onload = () => {
    iframeElement.contentWindow.focus();
  };
};

export const removeOverlay = () => {
  if (iframeElement) {
    iframeElement.remove();
    iframeElement = null;
  }
};

export const toggleOverlay = () => {
  if (iframeElement) {
    removeOverlay();
  } else {
    createOverlay();
  }
};


